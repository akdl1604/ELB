// LET_AlignClientDlg.cpp : 구현 파일
//

#include "stdafx.h"
#include "LET_AlignClient.h"
#include "LET_AlignClientDlg.h"
#include "afxdialogex.h"
#include "JXIniFile.h"
#include <cmath>
#include "CommPLC.h"
#include "ComPLC_RS.h"
#include "ImageProcessing/MathUtil.h"

#include "Job/CJob_1Cam1ShotAlign.h"

#include <fstream>
#include "UI_Control/Graphics/GraphicPolyline.h"
#include "UI_Control/Graphics/GraphicLines.h"
#include "INIReader.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define MM_TEST_DATA 20000
UINT g_nUserMsg;

// 응용 프로그램 정보에 사용되는 CAboutDlg 대화 상자입니다.

#include <vector>
using namespace std;

BYTE m_nSendByte[1024 * 2048];


CJob_1Cam1ShotAlign g_Job_1Cam1ShotAlign[MAX_JOB];

template<typename ... Args> std::string string_format(const std::string& format, Args ... args)
{
	size_t size = snprintf(nullptr, 0, format.c_str(), args ...) + 1; // Extra space for '\0' 
	if (size <= 0) { throw std::runtime_error("Error during formatting."); }
	std::unique_ptr<char[]> buf(new char[size]);
	snprintf(buf.get(), size, format.c_str(), args ...);
	return std::string(buf.get(), buf.get() + size - 1); // We don't want the '\0' inside 
}
struct STPARAM
{
	CLET_AlignClientDlg *m_pDlg;
	int id;

	STPARAM(CLET_AlignClientDlg *pDlg, int num)	:m_pDlg(pDlg), id(num) {}
};

void ProperPath(CString &strPath)
{
	if (strPath.Right(1) != _T("\\"))
		strPath += _T("\\");
}
void UnProperPath(CString &strPath)
{
	if (strPath.Right(1) == _T("\\"))
		strPath = strPath.Left(strPath.GetLength() - 1);
}
BOOL RemoveDir(CString strDir, BOOL bOnlyFile=FALSE)
{
	CFileFind finder;
	BOOL bWorking = TRUE;
	CString strDirFile = strDir + CString(_T("\\*.*"));

	if (finder.FindFile(strDir, TRUE) == false)		return FALSE;
	
	bWorking = finder.FindFile(strDirFile);
	while (bWorking)
	{
		bWorking = finder.FindNextFile();
		if (finder.IsDots())			continue;

		if (finder.IsDirectory() && !bOnlyFile)			RemoveDir(finder.GetFilePath(), FALSE);
		else											::DeleteFile(finder.GetFilePath());
	}
	
	finder.Close();

	if (!bOnlyFile)										::RemoveDirectory(strDir);

	return TRUE;
}
BOOL RemoveDirByDay(CString szPath, int nDays , CLET_AlignClientDlg *pMain)
{
	CTime tCur, tTarget, tCreate;
	CString szDir, szFilePath, szFileName;
	CFileFind finder;
	BOOL bRet = TRUE;

	try
	{
		tCur = CTime::GetCurrentTime();
		tTarget = tCur - CTimeSpan(nDays, 0, 0, 0); //일, 시, 분, 초

		ProperPath(szPath);							//이전 포스팅 참조;;
		szDir.Format(_T("%s*.*"), szPath);

		bRet = finder.FindFile(szDir);
		while (bRet )
		{
			if (pMain->m_bAutoStart) break;

			bRet = finder.FindNextFile();
			if (finder.IsDirectory())
			{
				//폴더일 경우
				if (finder.GetFileName() == L"." || finder.GetFileName() == L"..")
					continue;
				finder.GetCreationTime(tCreate);
				if (tCreate >= tTarget)				continue;

				szFileName = finder.GetFileName();
				szFilePath = szPath + szFileName;	// szFilePath = GetFolderPath(szDir) + szFileName;
				RemoveDir(szFilePath);				// 이전 포스팅 참조
			}
			else
			{
				//파일일 경우
			}
		}
	}
	catch (...)
	{
		bRet = FALSE;
	}

	return bRet;
}

BOOL RemoveFileByDay(CString szPath, int nDays, CLET_AlignClientDlg* pMain, BOOL bOnlyFile = TRUE)
{
	CTime tCur, tTarget, tCreate;
	CString szDir, szFilePath, szFileName;
	CFileFind finder;
	BOOL bRet = TRUE;

	try
	{
		tCur = CTime::GetCurrentTime();
		tTarget = tCur - CTimeSpan(nDays, 0, 0, 0); //일, 시, 분, 초

		ProperPath(szPath);							//이전 포스팅 참조;;
		szDir.Format(_T("%s*.*"), szPath);

		BOOL bWorking = TRUE;
		CString strDirFile = szDir;
		CString strDir;
		int nLength = szDir.GetLength();
		int nFind = szDir.ReverseFind(_T('\\'));
		strDir = szDir.Left(nFind);

		if (finder.FindFile(strDir, TRUE) == false)		return FALSE;

		bWorking = finder.FindFile(strDirFile);
		while (bWorking)
		{
			if (pMain->m_bAutoStart) break;

			bWorking = finder.FindNextFile();
			if (finder.IsDots())			continue;
			if (finder.GetFileName() == L"." || finder.GetFileName() == L"..")
				continue;

			finder.GetCreationTime(tCreate);
			if (tCreate >= tTarget)				continue;

			if (finder.IsDirectory() && !bOnlyFile)			RemoveDir(finder.GetFilePath(), FALSE);
			else											::DeleteFile(finder.GetFilePath());
		}

		finder.Close();

		if (!bOnlyFile)										::RemoveDirectory(strDir);

	}
	catch (...)
	{
		bRet = FALSE;
	}

	return bRet;
}
class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

	// 대화 상자 데이터입니다.
	enum { IDD = IDD_ABOUTBOX };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 지원입니다.

// 구현입니다.
protected:
	DECLARE_MESSAGE_MAP()
};
CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)
{
}
void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()

// CLET_AlignClientDlg 대화 상자
CLET_AlignClientDlg::CLET_AlignClientDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(CLET_AlignClientDlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	
	m_nCurForm = 0;
	m_nOldForm = 0;
	m_nCurPane = 0;
	m_nOldPane = 0;
	m_nCur_B_Pane = 0;
	m_nOld_B_Pane = 0;

	m_nStartReadBitAddr = 0;
	m_nStartWriteBitAddr = 0;
	m_nStartReadWordAddr = 0;
	m_nStartWriteWordAddr = 0;
	m_nSizeReadBit = 0;
	m_nSizeWriteBit = 0;
	m_nSizeReadWord = 0;
	m_nSizeWriteWord = 0;

	m_nPLCAliveCount = 0;
	m_nPLCAlive = 0;
	m_dMarkInputTime = 120;

	m_nCalibrationAck = 0;
	m_nCalibrationModeOnAck = 0;
	m_nCalibRevisionAck = 0;	

	m_dbFocusEnergy = 0.0;
	m_dbAvgGray = 0.0;
	m_dMarkRegistRatio = 1.0;
	m_dCalibrationMarkMinScore = 65.0;
	m_dCurrentRotateOffsetX = 0.0;
	m_nCurrentCircleAccDec = 0.0;
	m_nCurrentNotchAcc = 0.0;
	m_nCurrentNotchDec = 0.0;
	m_nCurrentCircleCount = 0;
	m_nSecondCircleOffset_Y = 0.0;
	m_dCircleSecondThetaPos = 0.0;
	m_nThirdCircleOffset_Y = 0.0;
	m_dCircleThirdThetaPos = 0.0;
	m_nFourCircleOffset_Y = 0.0;
	m_dCircleFourThetaPos = 0.0;
	m_dNozzleCurrentAngle = 0;
	m_dCircleRadius_PN = 0;
	m_dNozzleTipSize = 0;
	m_nNozzleAlignCount = 0;

	m_bSaveReslutImage = TRUE;
	m_bSaveRawImage = TRUE;
	m_nSaveTerm = 30;
	m_nHDD_UsedRate = 90;
	m_bUsePlcTime = FALSE;

	m_nExistResult = 0; //210110
	m_dExistResultData = 0; //210110
	m_nSeqTotalInspGrabCount = 0;
	m_nSeqCurrentInspGrabCount = 0;

	m_nServerIP = 127 << 24 | 1;
	m_nServerPort = 8234;
	m_strComFolerName = "Z:\\";
	m_strRDP_LogDir = "Z:\\";

	m_bPLCConnect = FALSE;
	m_bPlcAlive = FALSE;
	m_bProgramEnd = FALSE;
	m_bAutoStart = FALSE;
	m_bInitCheck = FALSE;
	m_bThreadPLCSignalCheckEnd = TRUE;
	m_bConnectServer = FALSE;
	m_bFocusMeasure = FALSE;
	m_bAutoSearch = FALSE;
	m_bSimulationStart = FALSE;
	m_bELB_LightControlMethod = TRUE;

	m_nBitData = NULL;
	m_nBitWriteData = NULL;
	m_nBitPreData = NULL;
	m_nBitWritePreData = NULL;
	m_nWordData = NULL;
#ifndef _DAHUHA
	m_pBaslerCam = NULL;
#endif
	m_dlgMsg = NULL;
	m_hHeaderBar = NULL;
	m_pKeyboardDlg = NULL;
	m_pDlgCaliper = NULL;
	m_pCamLightControlDlg = NULL;

	m_pCameraViewImage = NULL;
	m_pIplSrcImage = NULL;
	m_bUseSubInspCamView = NULL;
	m_pDlgMessage = NULL;

	m_pSrcImage = NULL;
	m_pProcImage = NULL;
	m_pSaveImageBuf = NULL;

	for (int i = 0; i < MAX_CAMERA; i++)
	{
		m_bGrabEnd[i] = FALSE;
		m_bLiveDisplay[i] = FALSE;
		m_bProcessEnd[i] = FALSE;
		m_bPrealignStartFlag[i] = FALSE;
		m_bProcessResult[i] = FALSE;
		m_dCurrentSearchPos[i] = 0;
		m_dCurrentRobotSearchPos[i] = 0;
		m_dScanImageLength[i] = 0;

		m_pManualInputMark[i] = NULL;
		m_pManualInputMark1Cam[i] = NULL;
		m_PatternMatching[i].init_job(i);
		m_hInspEndEvent[i] = CreateEvent(NULL, TRUE, FALSE, FALSE);
		m_bSubInspJudge[i] = TRUE;
	}

	for (int i = 0; i < MAX_FORM; i++)	m_pForm[i] = NULL;
	for (int i = 0; i < MAX_PANE; i++)	m_pPane[i] = NULL;
#ifndef _DAHUHA
	PylonInitialize();
#endif
	memset(m_stCamInfo, 0, sizeof(m_stCamInfo));

	memset(m_nSaveImageRingBufIndex, 0, sizeof(m_nSaveImageRingBufIndex));
	memset(m_nSaveImageRingBufIndex_Curr, 0, sizeof(m_nSaveImageRingBufIndex_Curr));
	memset(m_cSaveImageRingBufPath, 0, sizeof(m_cSaveImageRingBufPath));
	memset(m_cSaveImageRingBufPath_Raw, 0, sizeof(m_cSaveImageRingBufPath_Raw));
	memset(m_stSaveImageInfo, 0, sizeof(m_stSaveImageInfo));
	memset(m_stInsp_DistanceResult, 0, sizeof(m_stInsp_DistanceResult));
	memset(m_stSaveImage_DistanceResult, 0, sizeof(m_stSaveImage_DistanceResult));
	memset(m_nRetryCount, 0, sizeof(m_nRetryCount));


	memset(m_nInspRequestRead, 0, sizeof(m_nInspRequestRead));
	memset(m_nInspWordDataRead, 0, sizeof(m_nInspWordDataRead));
	memset(m_nAlignRequestRead, 0, sizeof(m_nAlignRequestRead));
	memset(m_nAlignOkWrite, 0, sizeof(m_nAlignOkWrite));
	memset(m_nAlignNgWrite, 0, sizeof(m_nAlignNgWrite));
	memset(m_nAlignLcheckNgWrite, 0, sizeof(m_nAlignLcheckNgWrite));
	memset(m_nAlignManualMarkWrite, 0, sizeof(m_nAlignManualMarkWrite));
	memset(m_nInspAckWrite, 0, sizeof(m_nInspAckWrite));
	memset(m_nInspOkWrite, 0, sizeof(m_nInspOkWrite));
	memset(m_nInspNgWrite, 0, sizeof(m_nInspNgWrite));
	memset(m_nInspResultWrite, 0, sizeof(m_nInspResultWrite));
	memset(m_nCurrentXMotorPos, 0, sizeof(m_nCurrentXMotorPos));
	memset(m_nCurrentYMotorPos, 0, sizeof(m_nCurrentYMotorPos));
	memset(m_nCurrentTMotorPos, 0, sizeof(m_nCurrentTMotorPos));
	memset(m_nRevisionXMotorPos, 0, sizeof(m_nRevisionXMotorPos));
	memset(m_nRevisionYMotorPos, 0, sizeof(m_nRevisionYMotorPos));
	memset(m_nRevisionTMotorPos, 0, sizeof(m_nRevisionTMotorPos));
	memset(m_nSeqScanInspGrabCount, 0, sizeof(m_nSeqScanInspGrabCount));

	memset(m_dbRevisionData, 0, sizeof(m_dbRevisionData));
	memset(m_dbLcheckLength, 0, sizeof(m_dbLcheckLength));
	memset(m_dbLCheck, 0, sizeof(m_dbLCheck));
	memset(m_dbLCheckSpec, 0, sizeof(m_dbLCheckSpec));
	memset(m_bLcheckNG, 0, sizeof(m_bLcheckNG));

	memset(m_bInspResult, 0, sizeof(m_bInspResult));
	memset(m_bSimulGrabEnd, 0, sizeof(m_bSimulGrabEnd));
	memset(m_dReeltoStageDistance, 0, sizeof(m_dReeltoStageDistance));
	memset(m_dDisplayDir, 0, sizeof(m_dDisplayDir));


	ZeroMemory(m_dCPos, sizeof(m_dCPos));
	for (int i = 0; i < NUM_ALIGN_POINTS; i++)
	{
		m_dDistanceInspJudgeResult[i] = TRUE;
		m_dDistanceInspDataResult[i] = 0;
		m_dDistanceInspSubJudgeResult[i] = TRUE;
		m_dDistanceInspSubDataResult[i] = 0;
	}

	InitializeCriticalSection(&m_csSendPacket);
	InitializeCriticalSection(&m_cs);
	InitializeCriticalSection(&m_csScanWrite);
	InitializeCriticalSection(&m_csScanBurInsp);

	InitializeSRWLock(&g_srwlock); // 초기화 동기화 객체 Tkyuha 20211027
	InitializeSRWLock(&g_srScratchwlock); // 초기화 동기화 객체 Tkyuha 20221121
	m_hDummyEvent = CreateEvent(NULL, TRUE, FALSE, FALSE);
	

	m_nSeqNozzleGrabCount = -1;
	m_binitNozzleCheck = FALSE;

	m_ELB_TraceResult.m_vELB_RotateCenter = cv::Point2d(0, 0);
	m_ELB_TraceResult.m_vELB_ReverseRotateCenter = cv::Point2d(0, 0);
	m_ELB_TraceResult.m_vELB_ImageRotateCenter = cv::Point2d(0, 0);
	m_ELB_TraceResult.m_ELB_ResultXY = cv::Point2d(0, 0);

	for (int i = 0; i < 2; i++)
	{
		m_ELB_DiffInspResult[i].m_vELB_RotateCenter = cv::Point2d(0, 0);
		m_ELB_DiffInspResult[i].m_vELB_ReverseRotateCenter = cv::Point2d(0, 0);
		m_ELB_DiffInspResult[i].m_vELB_ImageRotateCenter = cv::Point2d(0, 0);
		m_ELB_DiffInspResult[i].m_ELB_ResultXY = cv::Point2d(0, 0);
	}

	m_hMetalSearchEvent = NULL;
	m_hMetalSearchEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	m_nSpecRowCount = 2;

	//KJH 2021-10-30 Save End Check 변수 추가
	m_bSaveFinishCheck = FALSE;

	memset(m_nPrealignGrabRetry, 0, sizeof(m_nPrealignGrabRetry));
	memset(auto_seq_test, 0, sizeof(auto_seq_test));
	each_job_method = FALSE;
	m_nNozzleSideCamMode = 0;
	m_dDummyStart_posXY = CPoint(100,100);
	m_dDummyInspRangeHeight = 200;
	
	memset(Process_Live, 0, sizeof(Process_Live));

	for (int i = 0; i < MAX_JOB; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			nFilmInspect[i][j] = 0;
		}
		for (int z = 0; z < NUM_POS; z++)
		{
			//hsj 2022-02-14 reference 변경 유무
			m_bChangeReference[i][z] = FALSE;
			m_bChangeFixture[i][z] = FALSE;
		}
		//KJH 2022-03-17 VisionActTime Display 추가
		m_clockStartTime[i] = 0;
		m_dActTime[i] = "";
		m_dSeqTime[i] = "";
	}
	//2022.06.18 ksm 전체 Reference 추가 시 Flag
	m_bAllReferflag = FALSE;

	m_nLogInUserLevelType = USER;

	m_bCleaningLive = FALSE;
	
#ifdef _SDV_VAT
	char m_modelName[MAX_PATH] = { "AMF755ZE01" };
	char m_ver[MAX_PATH] = { "VisionVersion1.0" };
	m_classSamsungVATWraper.InitVAT_DLL();
	m_classSamsungVATWraper.Agent_Initial(m_modelName, m_ver);
#endif
	
	for (int i = 0; i < 2; i++)
	{
		m_pCInspChartDlg[i] = NULL;
	}

	m_nExceptionJudgeCount = 0;
	m_dbCirceErrorLossRate = 0.0; //Tkyuha 221108 원찾는 에러율 보고용
}

CLET_AlignClientDlg::~CLET_AlignClientDlg()
{
	if (m_hMetalSearchEvent) CloseHandle(m_hMetalSearchEvent);

	for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
	{
#ifdef _DAHUHA
		if (m_pDahuhaCam[nCam].isconnected() != NULL)
		{
			TRACE(_T("[DEBUG] ~CBplDispenserAlignView() %d번 그랩을 종료 합니다. \n"), nCam);
			m_pDahuhaCam[nCam].grabStop();
			TRACE(_T("[DEBUG] ~CBplDispenserAlignView() %d번 카메라로부터 연결을 해제합니다. \n"), nCam);
			m_pDahuhaCam[nCam].disconnect();

			while (1) 
			{
				if (m_pDahuhaCam[nCam].isconnected() && m_pDahuhaCam[nCam].isgrabbing())			TRACE(_T("[DEBUG] GrabContinuous \n"));
				if (m_pDahuhaCam[nCam].isconnected() && !m_pDahuhaCam[nCam].isgrabbing())			break;
			}
		}
#else
		if (m_pBaslerCam[nCam] != NULL)
		{
			m_pBaslerCam[nCam]->GrabContinuous(FALSE);
			Sleep(100);

			while (1) {
				if (m_pBaslerCam[nCam] && m_pBaslerCam[nCam]->IsGrabContinuous())		TRACE(_T("[DEBUG] GrabContinuous \n"));
				if (m_pBaslerCam[nCam] && !m_pBaslerCam[nCam]->IsGrabbing())					break;
			}

			delete m_pBaslerCam[nCam];
		}
#endif
		if (m_pManualInputMark[nCam] != NULL) delete m_pManualInputMark[nCam];
	}

	for (int i = 0; i < vt_job_info.size(); i++)
	{
		if (m_pManualInputMark1Cam[i] != NULL)	delete m_pManualInputMark1Cam[i];
	}

#ifndef _DAHUHA
	if (m_pBaslerCam != NULL)		delete[]m_pBaslerCam;
#endif
	if (m_pDlgCaliper != NULL)		delete[]m_pDlgCaliper;
#ifndef _DAHUHA
	PylonTerminate();
#endif
	releaseBuffer();

	DeleteCriticalSection(&m_csSendPacket);
	DeleteCriticalSection(&m_cs);
	DeleteCriticalSection(&m_csScanWrite);
	DeleteCriticalSection(&m_csScanBurInsp);

	for (int i = 0; i < MAX_ALARM_DLG; i++)
	{
		if (m_pDlgAlarm[i] != NULL) delete m_pDlgAlarm[i];
	}

	if (m_dlgMsg != NULL) 				delete m_dlgMsg;
	if (m_pKeyboardDlg != NULL) 		delete m_pKeyboardDlg;
	if (m_pDlgMessage != NULL) 			delete m_pDlgMessage;
	if (m_pCamLightControlDlg != NULL) 	delete m_pCamLightControlDlg;
	if (m_pOffsetDlg != NULL) 			delete m_pOffsetDlg;
	if (m_pPFScaleCalc != NULL) 		delete m_pPFScaleCalc;
	if (m_pSelectDlg != NULL)			delete m_pSelectDlg;
	if (m_pListDlg != NULL)				delete m_pListDlg;
	if (m_pVAT_SimulatorDlg != NULL)	delete m_pVAT_SimulatorDlg;
	if (m_pCalculator_Dlg != NULL)	delete m_pCalculator_Dlg;
	

	for (int i = 0; i < 5; i++)  m_ELB_TraceResult.m_vTraceProfile[i].clear();

	m_ELB_RefData.clear();
	m_RectExistBlob.clear();
}
void CLET_AlignClientDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}
LRESULT CLET_AlignClientDlg::OnDumpFileMessage(WPARAM wParam, LPARAM lParam)
{
	AfxMessageBox(_T("Program Dump File Created!"));

	return 1;
}

BEGIN_MESSAGE_MAP(CLET_AlignClientDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_TIMER()
	ON_MESSAGE(WM_VIEW_CONTROL, OnViewControl)
	ON_MESSAGE(LM_SET_DUMPMESSAGE, &CLET_AlignClientDlg::OnDumpFileMessage)
	ON_WM_CLOSE()
	ON_WM_COPYDATA()
	ON_REGISTERED_MESSAGE(g_nUserMsg, &CLET_AlignClientDlg::OnMessageFunc)
END_MESSAGE_MAP()

// CLET_AlignClientDlg 메시지 처리기

BOOL CLET_AlignClientDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 시스템 메뉴에 "정보..." 메뉴 항목을 추가합니다.

	// IDM_ABOUTBOX는 시스템 명령 범위에 있어야 합니다.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 이 대화 상자의 아이콘을 설정합니다. 응용 프로그램의 주 창이 대화 상자가 아닐 경우에는
	//  프레임워크가 이 작업을 자동으로 수행합니다.
	SetIcon(m_hIcon, TRUE);			// 큰 아이콘을 설정합니다.
	SetIcon(m_hIcon, FALSE);		// 작은 아이콘을 설정합니다.


	// TODO: 여기에 추가 초기화 작업을 추가합니다.	
	int screenx = GetSystemMetrics(SM_CXSCREEN);
	int screeny = GetSystemMetrics(SM_CYSCREEN);
	SetWindowPos(NULL, 0, 0, screenx, screeny, SWP_NOZORDER);

	this->SetBackgroundColor(COLOR_UI_BODY, 0);

	char arch[_MAX_PATH];
	if (_getcwd(arch, _MAX_PATH) == NULL)
	{
		AfxMessageBox("Can't get a current path.");
		return FALSE;
	}
	else
	{
		memcpy(m_szWorkingPath, arch, MAX_PATH);

		m_strDir.Format("%s\\", arch);
		if (_access(m_strDir, 0) != 0) _mkdir(m_strDir);

		m_strSystemDir = m_strDir + "System\\";
		if (_access(m_strSystemDir, 0) != 0) _mkdir(m_strSystemDir);

		m_strConfigDir = m_strDir + "Config\\";
		if (_access(m_strConfigDir, 0) != 0) _mkdir(m_strConfigDir);

		m_strModelDir = m_strDir + "Model\\";
		if (_access(m_strModelDir, 0) != 0) _mkdir(m_strModelDir);

		m_strMachineDir = m_strDir + "Machine\\";
		if (_access(m_strMachineDir, 0) != 0) _mkdir(m_strMachineDir);

		m_strDir = "D" + m_strDir.Right(m_strDir.GetLength() - 1);		// LOG와 결과는 E 드라이브에	나머지는 D
		if (_access(m_strDir, 0) != 0) _mkdir(m_strDir);

		m_strResultDir = m_strDir + "Result\\";
		if (_access(m_strResultDir, 0) != 0) _mkdir(m_strResultDir);

		m_strHistoryDir = m_strDir + "History\\";
		if (_access(m_strHistoryDir, 0) != 0) _mkdir(m_strHistoryDir);

		m_strImageDir = m_strResultDir + "Image\\";
		if (_access(m_strImageDir, 0) != 0) _mkdir(m_strImageDir);

		m_strVideoDir = m_strResultDir + "Video\\";
		if (_access(m_strVideoDir, 0) != 0) _mkdir(m_strVideoDir);
	}

	theApp.m_pFrame = this;
	readLastModel();

	m_strCurrentModelName = m_strLastModel;
	m_strCurrModel = m_strLastModel;
	m_strCurrentModelPath.Format("%s%s\\", m_strModelDir, m_strLastModel);

	if (_access(m_strCurrentModelPath, 0) != 0)	_mkdir(m_strCurrentModelPath);

	m_iniFile.SetFileName(m_strSystemDir + _T("LET_AlignClient.ini"));
	m_iniCameraFile.SetFileName(m_strConfigDir + _T("Camera.ini"));
	m_iniViewerFile.SetFileName(m_strConfigDir + _T("Viewer.ini"));
	m_iniAlgoFile.SetFileName(m_strConfigDir + _T("Algorithm.ini"));
	m_iniJobFile.SetFileName(m_strConfigDir + _T("JobInfo.ini"));

	// 탄착군 표시 하기 위하여 데이타 베이스에 저장 함 Tkyuha 20211221
	m_dbResultDataBase.InitDataBase(m_strResultDir);
	m_dbResultDataBase.CreateDataBase();

	CSimpleSplashWnd _splash(this, IDB_BMP_LOADING);

	_splash.SetStatusText(_T("  Loading Ini Files.."), 10);
	Sleep(100);

	Loadini();
	LoadPlcIni();
	LoadCameraini();
	LoadJobInfo();
	LoadAlgoini();
	LoadViewerini();

	initPLC_CommunationAddress();
	initPLC_Time();

	for (int job = 0; job < vt_job_info.size(); job++)
	{
		CString path;
		path.Format("%s%s\\%s\\", m_strModelDir, m_strCurrModel, vt_job_info[job].job_name.c_str());
		if (_access(path, 0) != 0)	_mkdir(path);

		path.Format("%s%s\\", m_strMachineDir, vt_job_info[job].job_name.c_str());
		if (_access(path, 0) != 0)	_mkdir(path);
	}


	_splash.SetStatusText(_T("  Init GUI.."), 30);

	// kbj 2012-12-31 추가된 시스템 옵션 읽는 부분추가.
	load_system_option();	// Init_gui, LoadJobInfo 이후에 호출 되어야 함.

	init_gui();

	//KJH 2021-11-17 ELB Server Check 기능 우선 막음
	/*
	convertIP(m_strServerIP, &m_nServerIP);
	initSocket();
	*/
	connectLightCtrl_NewType();

	_splash.SetStatusText(_T("  Init Buffer.."), 50);

	initBuffer();

	m_ManualAlignMeasure.m_pMain = this;

	_splash.SetStatusText(_T("  Load Model Data.."), 60);

	allModelChange(m_strCurrentModelName);

	_splash.SetStatusText(_T("  Init Caliper.."), 70);
	initCaliper();

	_splash.SetStatusText(_T("  Init Cameras.."), 80);

	init_camera();
	init_manual_input_mark();

	//----- Register Callback Thread -----//
	m_thdTime.RegisterCallback(this, &CLET_AlignClientDlg::OnUpdateTime);
	m_thdTime.Start();

	m_dlgMsg = new CDlgMsg;
	m_dlgMsg->Create(IDD_DIALOG_MSG, this);
	m_dlgMsg->ShowWindow(SW_HIDE);

	m_pKeyboardDlg = new COnscreenKeyboardDlg;
	m_pKeyboardDlg->Create(IDD_ONSCREENKEYBOARD_DIALOG, this);
	m_pKeyboardDlg->ShowWindow(SW_HIDE);
	m_pKeyboardDlg->OnInitDialog();

	// YCS 2022-08-20 차트 다이얼로그 추가
	if (this->vt_job_info[0].algo_method == CLIENT_TYPE_FILM_INSP)
	{
		for (int i = 0; i < 2; i++)
		{
			m_pCInspChartDlg[i] = new CInspChartView(i);
			m_pCInspChartDlg[i]->Create(IDD_DIALOG_SCATTER);
			m_pCInspChartDlg[i]->ShowWindow(SW_HIDE);
		}
	}

	m_pDlgMessage = new CDlgMessage;
	m_pDlgMessage->Create(IDD_DLG_MESSAGE, this);
	m_pDlgMessage->ShowWindow(SW_HIDE);

	m_pCamLightControlDlg = new CCamLightControlDlg;
	m_pCamLightControlDlg->Create(IDD_DIALOG_CAMLIGHT_CONTROL, this);
	m_pCamLightControlDlg->ShowWindow(SW_HIDE);

	m_pOffsetDlg = new COffsetDlg;
	m_pOffsetDlg->Create(IDD_OFFSET_DIALOG, this);
	m_pOffsetDlg->ShowWindow(SW_HIDE);
	CRect Rect;
	m_pOffsetDlg->GetClientRect(&Rect);
	m_pOffsetDlg->MoveWindow(500, 500, Rect.Width(), Rect.Height());

	m_pPFScaleCalc = new CPFScaleCalc;
	m_pPFScaleCalc->Create(IDD_DIALOG_PF_SCALE_CALC, this);
	m_pPFScaleCalc->ShowWindow(SW_HIDE);

	m_pVAT_SimulatorDlg = new CVAT_SimulatorDlg;
	m_pVAT_SimulatorDlg->Create(IDD_DIALOG_SDV_VAT_SIMULATOR, this);
	m_pVAT_SimulatorDlg->ShowWindow(SW_HIDE);

	m_pCalculator_Dlg = new An_engineering_calculator;
	m_pCalculator_Dlg->Create(IDD_AN_ENGINEERING_CALCULATOR, this);
	m_pCalculator_Dlg->ShowWindow(SW_HIDE);

	m_pListDlg = new CDlgList;
	m_pListDlg->Create(IDD_DIALOG_LIST, this);
	m_pListDlg->ShowWindow(SW_HIDE);

	//2022.07.05 ksm Job Select 후 List 보이기
	m_pSelectDlg = new CDlgSelectJob;
	m_pSelectDlg->Create(IDD_DLG_SELECT_JOB, this);
	m_pSelectDlg->GetClientRect(&Rect);
	m_pSelectDlg->ShowWindow(SW_HIDE);

	for (int i = 0; i < MAX_ALARM_DLG; i++)
	{
		m_pDlgAlarm[i] = new CDlgAlarm;

		switch (i) {
		case 0:	m_pDlgAlarm[i]->m_strTitle.Format("Lack Of Cink Warning");		break;
		case 1:	m_pDlgAlarm[i]->m_strTitle.Format("Lack Of Cink InterLock");	break;
		}
		m_pDlgAlarm[i]->Create(IDD_DLG_ALARM, this);
		m_pDlgAlarm[i]->ShowWindow(SW_HIDE);

		replaceWindowPos(m_pDlgAlarm[i], i);
	}

	_splash.SetStatusText(_T("  Connect to PLC.."), 90);

	init_plc_connection();

	initialize_job();

	init_algorithm();		// set algorhim thread
	init_calib_data();		// read calibration	data;

	SetTimer(TIMER_IMAGE_SAVE, 100, NULL);
	SetTimer(TIMER_PLC_ALIVE_CHECK, 1000, NULL);

	//hsj 2022-09-23 ELB ZONE1~4에서만 동작하도록 수정
	//LET_AlignClient.ini에서 CLIENT_ID PC에 맞게 수정해야함..
	//if (m_nClientID > 2 && m_nClientID < 7)
	//if(vt_job_info[0].algo_method == CLIENT_TYPE_ELB_CENTER_ALIGN)
	//	SetTimer(TIMER_CLEANING_LIVE_MODE, 1000, NULL);

	// on
	for (int i = 0; i < vt_job_info.size(); i++)
	{
		int nMetho = vt_job_info[i].algo_method;
		if (nMetho == CLIENT_TYPE_ASSEMBLE_INSP || nMetho == CLIENT_TYPE_4CAM_1SHOT_ALIGN)
			LightUse(LIGHT_OFF, i);
		else LightUse(LIGHT_ON, i);
	}

	_splash.SetStatusText(_T("  Initialize Complete.."), 100);
	Sleep(100);
	g_nUserMsg = RegisterWindowMessage(_T("USER_MSG"));

	// 회전 중심 전송
	if (vt_job_info[0].algo_method == CLIENT_TYPE_ELB_CENTER_ALIGN)
	{
		double rotateX = GetMachine(0).getRotateX(0, 0);
		double rotateY = GetMachine(0).getRotateY(0, 0);
		long pDataCount[4] = { 0, };
		pDataCount[0] = LOWORD(rotateX * MOTOR_SCALE);
		pDataCount[1] = HIWORD(rotateX * MOTOR_SCALE);
		pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
		pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
		// KBJ 2022-11-14 회전중심과 Rotate 시 동일한 어드레스 사용하여 예외처리 추가
		int find_method = vt_job_info[0].model_info.getAlignInfo().getMarkFindMethod();
		if (find_method != METHOD_CIRCLE)
		{
			g_CommPLC.SetWord(vt_job_info[0].plc_addr_info.write_word_start + 14, 4, pDataCount);
		}

		CString trace_file, metal_file, mask_range_file;
		trace_file.Format("%s%s\\%s_%d%s", m_strCurrentModelPath, vt_job_info[0].job_name.c_str(), "Trace", 0, "Data.ini");
		metal_file.Format("%s%s\\%s_%d%s", m_strCurrentModelPath, vt_job_info[0].job_name.c_str(), "MetalTrace", 0, "Data.ini");
		mask_range_file.Format("%s%s\\%s_%d%s", m_strCurrentModelPath, vt_job_info[0].job_name.c_str(), "Trace_AreaMask", 0,
			(vt_job_info[0].model_info.getAlignInfo().getMarkFindMethod() == METHOD_NOTCH) ? "Notch.bin" : "Circle.bin");

		read_trace_data(trace_file);
		read_metal_trace_data(metal_file);
		read_trace_mask_data(mask_range_file);
	}

	m_pCircleProgress.Init(this, 100, 20);
	m_pCircleProgress.SetCircleAppearance(100, 150);
	m_vInspWetOutResult.clear();

	// YCS 2022-08-20 필름검사 데이터 저장 벡터 초기화
	for(int i = 0; i < 2; i++) m_vInspFilmResult[i].clear();

	// KBJ 2022-03-16 SetInspPara VIew into the Model View
	CFormModelView* pModelView = (CFormModelView*)m_pForm[FORM_MODEL];
	for (int nJob = 0; nJob < vt_job_info.size(); nJob++)
	{
		TabModelAlgoPage* pModelPage = (TabModelAlgoPage*)pModelView->c_TabModelPage[nJob];
		pModelPage->m_pInspectionDlg->InItDialog();
		pModelPage->m_pInspectionDlg->EnableWindow(false);
		pModelPage->m_pInspectionDlg->m_ctlPropGrid.SetCustomColors(COLOR_BTN_BODY, COLOR_GRAY, COLOR_UI_BODY, COLOR_GRAY, COLOR_BTN_BODY, COLOR_GRAY, COLOR_DDARK_GRAY);
		pModelPage->m_pInspectionDlg->m_ctlPropGrid.Invalidate();
	}

	// KBJ 2022-07-06 SpecGrid Title 재변경
	::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RENEW_TITLE, NULL);

	// KBJ 2022-08-09 프로그램 실행 시 오토모드로 전환되도록 수정.
	CPaneBottom* pPane = (CPaneBottom*)m_pPaneBottom[B_PANE_BOTTOM];
	pPane->OnBnClickedBtnAutoStart();

	if (vt_job_info[0].algo_method == CLIENT_TYPE_ELB_CENTER_ALIGN)
	{
		CFormMainView* pForm = (CFormMainView*)m_pForm[FORM_MAIN];
		pForm->change_job_main_view(1);
	}
	else if (vt_job_info[0].algo_method == CLIENT_TYPE_FILM_INSP)
	{
		CPaneAuto* pPaneAuto = (CPaneAuto*)m_pPane[PANE_AUTO];
		pPaneAuto->m_TabSpecView.SetCurSel(2);
		pPaneAuto->RenewSpecChart(2);
	}
	//AfxBeginThread(Thread_LogDelete, this, THREAD_PRIORITY_LOWEST);
	AfxBeginThread(Thread_LogDelete2, this, THREAD_PRIORITY_LOWEST);
	AfxBeginThread(Thread_Check_Model_Process_Able, this, THREAD_PRIORITY_LOWEST);

	init_model_process_addr();

	return TRUE;  // 포커스를 컨트롤에 설정하지 않으면 TRUE를 반환합니다.
}

void CLET_AlignClientDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 대화 상자에 최소화 단추를 추가할 경우 아이콘을 그리려면
//  아래 코드가 필요합니다. 문서/뷰 모델을 사용하는 MFC 응용 프로그램의 경우에는
//  프레임워크에서 이 작업을 자동으로 수행합니다.

CString CLET_AlignClientDlg::GetNumberBox(CString text, int nLength, double minValue, double maxValue)
{
	CKeyPadDlg dlg;
	BOOL bValue = FALSE;
	dlg.SetValueString(FALSE, text);
	dlg.DoModal();
	bValue = dlg.GetNumber(minValue, maxValue, text);

	if (bValue == TRUE) return text;

	return _T("");
}
void CLET_AlignClientDlg::convertIP(CString strIP, int *nIP)
{
	int nLength = 0;
	int nADDR[4] = { 0, };
	int nFlag = 0;
	int nIndex = 0;

	while (strIP.Find('.') > 0)
	{
		nLength = strIP.GetLength();
		nFlag = strIP.Find('.');
		nADDR[nIndex] = atoi(strIP.Mid(0, nFlag));
		strIP = strIP.Mid(nFlag + 1, nLength + (nFlag + 1));
		nIndex++;
	}

	if (nIndex == 3)
	{
		nADDR[nIndex] = atoi(strIP);
		*nIP = nADDR[0] << 24 | nADDR[1] << 16 | nADDR[2] << 8 | nADDR[3];
	}
}
void CLET_AlignClientDlg::AnalysisCommand(pToPacketData packet)
{
	CString str;
	int index = 0;
	char tmp[50] = { 0, };
	CString strLog;

	switch (packet->ud_cmd) {
	case TCP_RECV_CREATE_MODEL:
	{
		int nLen = 0;
		char cModelName[MAX_PATH] = { 0, };
		memcpy(&nLen, &packet->ud_Fdata[index], sizeof(int));				index = sizeof(int);
		memcpy(cModelName, &packet->ud_Fdata[index], nLen);					index += nLen;

		CString src_model_name;
		CString dst_model_name;

		src_model_name.Format("%s", m_strCurrentModelName);
		dst_model_name.Format("%s", cModelName);

		str.Format("TCP_RECV_CREATE_MODEL - src : %s", src_model_name);
		::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);

		str.Format("TCP_RECV_CREATE_MODEL - dst : %s", dst_model_name);
		::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);

		if (process_model_copy(src_model_name, dst_model_name) != TRUE)
		{
			str.Format("create model failed!!");
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}

	}
	break;
	case TCP_RECV_RENAME_MODEL:
	{
		int nLen = 0;
		char cSourceModel[MAX_PATH] = { 0, };
		char cTargetModel[MAX_PATH] = { 0, };

		memcpy(&nLen, &packet->ud_Fdata[index], sizeof(int));					index = sizeof(int);
		memcpy(cSourceModel, &packet->ud_Fdata[index], nLen);					index += nLen;
		memcpy(&nLen, &packet->ud_Fdata[index], sizeof(int));					index += sizeof(int);
		memcpy(cTargetModel, &packet->ud_Fdata[index], nLen);					index += nLen;


		CString strSourceModel, strTargetModel;
		strSourceModel.Format("%s", cSourceModel);
		strTargetModel.Format("%s", cTargetModel);

		str.Format("Rename Model - %s → %s", strSourceModel, strTargetModel);
		::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);

		CString strModelPath;
		CString strModelPath2;
		strModelPath.Format("%s%s", m_strModelDir, strSourceModel);
		strModelPath2.Format("%s%s", m_strModelDir, strTargetModel);

		if (_access(strModelPath, 0) != 0)
		{
			str.Format("Not Exist Dir - %s", strModelPath);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else
		{
			rename(strModelPath, strModelPath2);
		}
	}
	break;
	case TCP_RECV_MODIFY_MODEL:
	{
		int nLen = 0;
		memcpy(&nLen, &packet->ud_Fdata[index], sizeof(int));	index = sizeof(int);

		if (nLen != sizeof(struct _ST_PLC_MODEL_DATA_))
		{
			CString strTemp;
			strTemp.Format("PLC MODEL DATA Struct Size is Diff.", m_strCurrModel);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
			return;
		}

		struct _ST_PLC_MODEL_DATA_ modelData;
		memcpy(&modelData, &packet->ud_Fdata[index], nLen);	index += nLen;

		modifySpecData(&modelData);
	}
	break;
	case TCP_RECV_CLOSE_PROGRAM:
	{
		/*
		m_bProgramEnd = TRUE;
		AfxBeginThread(Thread_ReleaseObject, this);
		*/
	}
	break;
	case TCP_RECV_DELETE_MODEL:
	{
		int nLen;
		char cData[MAX_PATH] = { 0, };
		CString strDeleteModel;
		strDeleteModel.Empty();
		memcpy(&nLen, &packet->ud_Fdata[index], sizeof(int));	index = sizeof(int);
		memcpy(cData, &packet->ud_Fdata[index], nLen);	index += nLen;
		strDeleteModel.Format("%s", cData);
		::SendMessage(m_pForm[FORM_MODEL]->m_hWnd, WM_VIEW_CONTROL, MSG_MV_DELETE_MODEL, (LPARAM)&strDeleteModel);
	}
	break;
	case TCP_RECV_MODEL_CHANGE:
	{
		int nModelLength = 0;
		char cModelName[MAX_PATH];
		memset(cModelName, 0, MAX_PATH);
		memcpy(&nModelLength, &packet->ud_Fdata[index], sizeof(int));	index = sizeof(int);
		memcpy(cModelName, &packet->ud_Fdata[index], nModelLength);	index += nModelLength;

		m_strCurrModel.Format("%s", cModelName);
		m_strCurrentModelName = m_strCurrModel;

		str.Format("%s - Recv Model Change Request", m_strCurrModel);
		::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);

		// Model Change 관련 함수 추가!!
		if (allModelChange(m_strCurrentModelName) != TRUE)
		{
			str.Format("Model Change Failed");
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
			SendServer(TCP_SEND_MODEL_CHANGE_NG, TRUE);
		}
		else
		{
			str.Format("Model Change Complete");
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SET_MODELNAME, 0);
		}

		::SendMessage(m_pForm[FORM_MODEL]->m_hWnd, WM_VIEW_CONTROL, MSG_MV_DISP_MODEL_INFO, (LPARAM)&getDispModelName());
	}
	break;
	case TCP_RECV_AUTO_READY:
	{
		int nLen;
		char cData[MAX_PATH] = { 0, };

		memcpy(&nLen, &packet->ud_Fdata[index], sizeof(int));	index = sizeof(int);
		memcpy(cData, &packet->ud_Fdata[index], nLen);	index += nLen;

#ifndef JOB_INFO
		if (cData != getCurrModelName())
		{
			if (readAllModelData(cData) != TRUE)
				SendServer(TCP_SEND_AUTO_READY, TRUE);
		}
#else 
		//auto ready 할 일이 없어 일단 패스
		/*if (cData != getCurrModelName())
		{
			if (readAllModelData(cData) != TRUE)
				SendServer(TCP_SEND_AUTO_READY, TRUE);
		}*/
#endif
		((CPaneBottom*)m_pPaneBottom[B_PANE_BOTTOM])->OnBnClickedBtnAutoStart();
	}
	break;
	case TCP_RECV_AUTO_STOP:
	{
		((CPaneBottom*)m_pPaneBottom[B_PANE_BOTTOM])->OnBnClickedBtnAutoStop();
	}
	break;
	case TCP_RECV_PLC_TIME:
	{
		int nYear, nMonth, nDay, nHour, nMin, nSec;

		memcpy(&nYear, &packet->ud_Fdata[index], sizeof(int));	index += sizeof(int);
		memcpy(&nMonth, &packet->ud_Fdata[index], sizeof(int));	index += sizeof(int);
		memcpy(&nDay, &packet->ud_Fdata[index], sizeof(int));	index += sizeof(int);
		memcpy(&nHour, &packet->ud_Fdata[index], sizeof(int));	index += sizeof(int);
		memcpy(&nMin, &packet->ud_Fdata[index], sizeof(int));	index += sizeof(int);
		memcpy(&nSec, &packet->ud_Fdata[index], sizeof(int));	index += sizeof(int);

		CString strTemp;
		strTemp.Format("Time from PLC : %04d/%02d/%02d %02d:%02d:%02d", nYear, nMonth, nDay, nHour, nMin, nSec);
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

		SYSTEMTIME Time;
		::GetLocalTime(&Time);

		Time.wYear = nYear;		Time.wMonth = nMonth;		Time.wDay = nDay;
		Time.wHour = nHour;		Time.wMinute = nMin;		Time.wSecond = nSec;

		::SetLocalTime(&Time);
	}
	break;

	}
}
void CLET_AlignClientDlg::SendPacketToServer(ToPacketData packetData)
{
	if (m_bConnectServer != TRUE) return;

	EnterCriticalSection(&m_csSendPacket);

	try {
		DWORD u32_Len = packetData.ud_cmdCount + sizeof(DWORD);

		memcpy(m_nSendByte + 4, &packetData, packetData.ud_cmdCount);
		memcpy(m_nSendByte, &u32_Len, sizeof(DWORD));

		char *pData = (char*)&m_nSendByte;
		mi_Socket.SendTo(m_hServerSockID, pData, u32_Len);
	}
	catch (...)
	{
		theLog.logmsg(LOG_ERROR, "SendPacketToServer() - Failed");
	}

	LeaveCriticalSection(&m_csSendPacket);
}
void CLET_AlignClientDlg::initSocket()
{
	if (mi_Socket.GetSocketCount() > 0)
	{
		theLog.logmsg(LOG_ERROR, "Socket [%d] already in use!", mi_Socket.GetSocketCount());
		return;
	}

	int nServerIP = htonl(m_nServerIP);
	DWORD u32_Err = mi_Socket.ConnectTo(nServerIP, m_nServerPort, INFINITE, 0);

	if (u32_Err != 0)
	{
		CloseSockets();
		m_bConnectServer = FALSE;
		SetTimer(TIMER_SERVER_CHECK, 2000, NULL);
		theLog.logmsg(LOG_ERROR, "Server Socket Connection Retry!");
		return;
	}

	// runs until an error occurred or all sockets have closed
	DWORD u32_ID;
	mh_Thread = CreateThread(0, 0, ProcessEventThread, this, 0, &u32_ID);

	::SetThreadPriority(mh_Thread, THREAD_PRIORITY_ABOVE_NORMAL);

	/*#define THREAD_PRIORITY_LOWEST          THREAD_BASE_PRIORITY_MIN
	#define THREAD_PRIORITY_BELOW_NORMAL    (THREAD_PRIORITY_LOWEST+1)
	#define THREAD_PRIORITY_NORMAL          0
	#define THREAD_PRIORITY_HIGHEST         THREAD_BASE_PRIORITY_MAX
	#define THREAD_PRIORITY_ABOVE_NORMAL    (THREAD_PRIORITY_HIGHEST-1)
	#define THREAD_PRIORITY_TIME_CRITICAL   THREAD_BASE_PRIORITY_LOWRT
	#define THREAD_PRIORITY_IDLE           THREAD_BASE_PRIORITY_IDLE*/

	m_bConnectServer = TRUE;
	theLog.logmsg(LOG_ERROR, "Socket [%d] Connected!", mi_Socket.GetSocketCount());
}
void CLET_AlignClientDlg::CloseSockets()
{
	if (mi_Socket.GetSocketCount() > 0)
	{
		mi_Socket.Close();
	}
}
// static
ULONG WINAPI CLET_AlignClientDlg::ProcessEventThread(void* p_Param)
{
	CLET_AlignClientDlg* p_This = (CLET_AlignClientDlg*)p_Param;
	p_This->ProcessEvents();
	CloseHandle(p_This->mh_Thread);
	p_This->CloseSockets();
	return 0;
}
void CLET_AlignClientDlg::ProcessEvents()
{
	BOOL b_Server = (mi_Socket.GetState() & TCP::cSocket::E_Server);
	BOOL bReConnect = FALSE;

	while (TRUE) // Loop runs until the main window was closed or a severe error occurred
	{
		TCP::cSocket::cMemory* pi_RecvMem;
		SOCKET  h_Socket;
		DWORD u32_Event, u32_IP, u32_Read, u32_Sent;
		DWORD u32_Err = mi_Socket.ProcessEvents(&u32_Event, &u32_IP, &h_Socket, &pi_RecvMem, &u32_Read, &u32_Sent);

		if (u32_Err == ERROR_TIMEOUT) 		continue;

		CString s_Msg, s_Events;
		if (u32_Event) // ATTENTION: u32_Event may be == 0 -> do nothing.
		{
			char s8_Events[200];
			mi_Socket.FormatEvents(u32_Event, s8_Events);
			s_Events += s8_Events;

			if (u32_Event & FD_READ)  s_Msg.Format(_T(" %d Bytes received."), u32_Read);
			if (u32_Event & FD_WRITE) s_Msg.Format(_T(" %d Bytes sent"), u32_Sent);

			if (u32_Event & FD_CONNECT)
			{
				if (mi_Socket.GetState() & TCP::cSocket::E_Connected)
				{
					mi_Socket.GetAllConnectedSockets(&mi_SocketList);
					if (mi_SocketList.GetCount() > 0)
					{
						m_hServerSockID = mi_SocketList.GetKeyByIndex(0);

						m_bConnectServer = TRUE;
						::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_HB_CONNECT_SERVER, TRUE);
						SendServer(TCP_SEND_CONNECT, TRUE);
					}

					theLog.logmsg(LOG_CONFIG, "Socket Connect");
				}
			}

			if (u32_Event & FD_CLOSE)
			{
				m_bConnectServer = FALSE;
				theLog.logmsg(LOG_CONFIG, "Socket Disconnect");

				::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_HB_CONNECT_SERVER, FALSE);

				SetTimer(TIMER_SERVER_CHECK, 1000, 0);
			}

			if (u32_Event & FD_READ && pi_RecvMem) // pi_RecvMem may be NULL if an error occurred!!
			{
				// ProcessReceivedDataNormal(pi_RecvMem);
				ProcessReceivedDataPrefix(pi_RecvMem);
			}
		}

		if (u32_Err)
		{
			if (u32_Err == WSAENOTCONN)				break;

			// Print all the other error messages
			CString str;
			str.Format("ProcessEvent Error %s", GetErrMsg(u32_Err));
			theLog.logmsg(LOG_ERROR, str);

			if (u32_Err == WSAECONNREFUSED)				bReConnect = TRUE;
			if (u32_Err != WSAECONNABORTED &&	// e.g. after the other side was killed in TaskManager 
				u32_Err != WSAECONNRESET &&		// Connection reset by peer.
				u32_Err != WSAECONNREFUSED &&	// FD_ACCEPT with already 62 clients connected
				u32_Err != WSAESHUTDOWN)		// Sending data to a socket just in the short timespan 
				break;							//   between shutdown() and closesocket()
		}
	}; // end loop

	if (bReConnect && m_bProgramEnd != TRUE)
	{
		m_bConnectServer = FALSE;
		SetTimer(TIMER_SERVER_CHECK, 1000, 0);
	}
}
void CLET_AlignClientDlg::ProcessReceivedDataNormal(TCP::cSocket::cMemory* pi_RecvMem)
{
	//char*  s8_Buf = pi_RecvMem->GetBuffer();
	EnterCriticalSection(&m_cs);

	char * s8_Buf = pi_RecvMem->GetBuffer();
	DWORD u32_Len = pi_RecvMem->GetLength();

	MSG message;
	DWORD pReadPoint = 0;
	PBYTE packet = (PBYTE)&m_RecvPacket;

	memcpy(packet + m_dwCurrentReceiveSize, s8_Buf, u32_Len);
	m_dwCurrentReceiveSize += u32_Len;

	pi_RecvMem->DeleteLeft(u32_Len);

	while (m_dwCurrentReceiveSize >= m_RecvPacket.ud_cmdCount && m_dwCurrentReceiveSize >= PACKET_HEADER_SIZE)
	{
		SendMessage(WM_VIEW_CONTROL, MSG_MD_ANALYSIS_PACKET, (WPARAM)&m_RecvPacket);

		m_dwCurrentReceiveSize -= m_RecvPacket.ud_cmdCount;
		pReadPoint = m_RecvPacket.ud_cmdCount;
		if (m_dwCurrentReceiveSize > 0 && pReadPoint > 0)
			memmove(packet, packet + pReadPoint, m_dwCurrentReceiveSize);
		else
		{
			m_dwCurrentReceiveSize = 0;
			break;
		}

		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
	}

	LeaveCriticalSection(&m_cs);
}
void CLET_AlignClientDlg::ProcessReceivedDataPrefix(TCP::cSocket::cMemory* pi_RecvMem)
{
	BOOL b_Server = (mi_Socket.GetState() & TCP::cSocket::E_Server);

	while (TRUE && m_bProgramEnd != TRUE) // There may arrive multiple datablocks at once -> loop until FIFO is empty
	{
		char*  s8_Buf = pi_RecvMem->GetBuffer();
		DWORD u32_Len = pi_RecvMem->GetLength();
		if (u32_Len < 4)			return;

		DWORD u32_Blocksize = ((DWORD*)s8_Buf)[0];
		if (u32_Blocksize > u32_Len)
		{			
			return; // The block is not yet complete -> accumulate more data in pi_RecvMem
		}

		memcpy((void *)&m_RecvPacket, s8_Buf + 4, u32_Blocksize - 4);
		SendMessage(WM_VIEW_CONTROL, MSG_MD_ANALYSIS_PACKET, (WPARAM)&m_RecvPacket);

		pi_RecvMem->DeleteLeft(u32_Blocksize);
	}
}
CString CLET_AlignClientDlg::GetErrMsg(DWORD u32_Error)
{
	// Some translations of error codes are really stupid --> show the original error code.
	CString s_Code;
	switch (u32_Error)
	{
	case WSAEINTR:                s_Code = _T("WSAEINTR"); break;
	case WSAEBADF:                s_Code = _T("WSAEBADF"); break;
	case WSAEACCES:               s_Code = _T("WSAEACCES"); break;
	case WSAEFAULT:               s_Code = _T("WSAEFAULT"); break;
	case WSAEINVAL:               s_Code = _T("WSAEINVAL"); break;
	case WSAEMFILE:               s_Code = _T("WSAEMFILE"); break;
	case WSAEWOULDBLOCK:          s_Code = _T("WSAEWOULDBLOCK"); break;
	case WSAEINPROGRESS:          s_Code = _T("WSAEINPROGRESS"); break;
	case WSAEALREADY:             s_Code = _T("WSAEALREADY"); break;
	case WSAENOTSOCK:             s_Code = _T("WSAENOTSOCK"); break;
	case WSAEDESTADDRREQ:         s_Code = _T("WSAEDESTADDRREQ"); break;
	case WSAEMSGSIZE:             s_Code = _T("WSAEMSGSIZE"); break;
	case WSAEPROTOTYPE:           s_Code = _T("WSAEPROTOTYPE"); break;
	case WSAENOPROTOOPT:          s_Code = _T("WSAENOPROTOOPT"); break;
	case WSAEPROTONOSUPPORT:      s_Code = _T("WSAEPROTONOSUPPORT"); break;
	case WSAESOCKTNOSUPPORT:      s_Code = _T("WSAESOCKTNOSUPPORT"); break;
	case WSAEOPNOTSUPP:           s_Code = _T("WSAEOPNOTSUPP"); break;
	case WSAEPFNOSUPPORT:         s_Code = _T("WSAEPFNOSUPPORT"); break;
	case WSAEAFNOSUPPORT:         s_Code = _T("WSAEAFNOSUPPORT"); break;
	case WSAEADDRINUSE:           s_Code = _T("WSAEADDRINUSE"); break;
	case WSAEADDRNOTAVAIL:        s_Code = _T("WSAEADDRNOTAVAIL"); break;
	case WSAENETDOWN:             s_Code = _T("WSAENETDOWN"); break;
	case WSAENETUNREACH:          s_Code = _T("WSAENETUNREACH"); break;
	case WSAENETRESET:            s_Code = _T("WSAENETRESET"); break;
	case WSAECONNABORTED:         s_Code = _T("WSAECONNABORTED"); break;
	case WSAECONNRESET:           s_Code = _T("WSAECONNRESET"); break;
	case WSAENOBUFS:              s_Code = _T("WSAENOBUFS"); break;
	case WSAEISCONN:              s_Code = _T("WSAEISCONN"); break;
	case WSAENOTCONN:             s_Code = _T("WSAENOTCONN"); break;
	case WSAESHUTDOWN:            s_Code = _T("WSAESHUTDOWN"); break;
	case WSAETOOMANYREFS:         s_Code = _T("WSAETOOMANYREFS"); break;
	case WSAETIMEDOUT:            s_Code = _T("WSAETIMEDOUT"); break;
	case WSAECONNREFUSED:         s_Code = _T("WSAECONNREFUSED"); break;
	case WSAELOOP:                s_Code = _T("WSAELOOP"); break;
	case WSAENAMETOOLONG:         s_Code = _T("WSAENAMETOOLONG"); break;
	case WSAEHOSTDOWN:            s_Code = _T("WSAEHOSTDOWN"); break;
	case WSAEHOSTUNREACH:         s_Code = _T("WSAEHOSTUNREACH"); break;
	case WSAENOTEMPTY:            s_Code = _T("WSAENOTEMPTY"); break;
	case WSAEPROCLIM:             s_Code = _T("WSAEPROCLIM"); break;
	case WSAEUSERS:               s_Code = _T("WSAEUSERS"); break;
	case WSAEDQUOT:               s_Code = _T("WSAEDQUOT"); break;
	case WSAESTALE:               s_Code = _T("WSAESTALE"); break;
	case WSAEREMOTE:              s_Code = _T("WSAEREMOTE"); break;
	case WSASYSNOTREADY:          s_Code = _T("WSASYSNOTREADY"); break;
	case WSAVERNOTSUPPORTED:      s_Code = _T("WSAVERNOTSUPPORTED"); break;
	case WSANOTINITIALISED:       s_Code = _T("WSANOTINITIALISED"); break;
	case WSAEDISCON:              s_Code = _T("WSAEDISCON"); break;
	case WSAENOMORE:              s_Code = _T("WSAENOMORE"); break;
	case WSAECANCELLED:           s_Code = _T("WSAECANCELLED"); break;
	case WSAEINVALIDPROCTABLE:    s_Code = _T("WSAEINVALIDPROCTABLE"); break;
	case WSAEINVALIDPROVIDER:     s_Code = _T("WSAEINVALIDPROVIDER"); break;
	case WSAEPROVIDERFAILEDINIT:  s_Code = _T("WSAEPROVIDERFAILEDINIT"); break;
	case WSASYSCALLFAILURE:       s_Code = _T("WSASYSCALLFAILURE"); break;
	case WSASERVICE_NOT_FOUND:    s_Code = _T("WSASERVICE_NOT_FOUND"); break;
	case WSATYPE_NOT_FOUND:       s_Code = _T("WSATYPE_NOT_FOUND"); break;
	case WSA_E_NO_MORE:           s_Code = _T("WSA_E_NO_MORE"); break;
	case WSA_E_CANCELLED:         s_Code = _T("WSA_E_CANCELLED"); break;
	case WSAEREFUSED:             s_Code = _T("WSAEREFUSED"); break;
	case WSAHOST_NOT_FOUND:       s_Code = _T("WSAHOST_NOT_FOUND"); break;
	case WSATRY_AGAIN:            s_Code = _T("WSATRY_AGAIN"); break;
	case WSANO_RECOVERY:          s_Code = _T("WSANO_RECOVERY"); break;
	case WSANO_DATA:              s_Code = _T("WSANO_DATA"); break;
	case WSA_IO_PENDING:          s_Code = _T("WSA_IO_PENDING"); break;
	case WSA_IO_INCOMPLETE:       s_Code = _T("WSA_IO_INCOMPLETE"); break;
	case WSA_INVALID_HANDLE:      s_Code = _T("WSA_INVALID_HANDLE"); break;
	case WSA_INVALID_PARAMETER:   s_Code = _T("WSA_INVALID_PARAMETER"); break;
	case WSA_NOT_ENOUGH_MEMORY:   s_Code = _T("WSA_NOT_ENOUGH_MEMORY"); break;
	case WSA_OPERATION_ABORTED:   s_Code = _T("WSA_OPERATION_ABORTED"); break;

	default:
		s_Code.Format(_T("Code %u"), u32_Error);
		break;
	}

	return s_Code;
}
void CLET_AlignClientDlg::modifySpecData(struct _ST_PLC_MODEL_DATA_ *pData)
{

}
void CLET_AlignClientDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 그리기를 위한 디바이스 컨텍스트입니다.

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 클라이언트 사각형에서 아이콘을 가운데에 맞춥니다.
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 아이콘을 그립니다.
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}
// 사용자가 최소화된 창을 끄는 동안에 커서가 표시되도록 시스템에서
//  이 함수를 호출합니다.
HCURSOR CLET_AlignClientDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}
void CLET_AlignClientDlg::Loadini(void)
{
	if ((_access(m_strSystemDir, 0)) != -1)
	{
		CFileStatus fs;
		if (CFile::GetStatus(m_strSystemDir + _T("LET_AlignClient.ini"), fs))
		{
			CString strKey,strValue;
			TCHAR szValue[MAX_PATH];

			m_nClientID = m_iniFile.GetProfileIntA("SERVER_INFO", "CLIENT_ID", 1);
			m_nNumCamera = m_iniFile.GetProfileIntA("SERVER_INFO", "CAMERA_NUM", 2);
			/*m_nViewX_Num = m_iniFile.GetProfileIntA("SERVER_INFO", "VIEW_XDIR_NUM", 2);
			m_nViewY_Num = m_iniFile.GetProfileIntA("SERVER_INFO", "VIEW_YDIR_NUM", 2);*/
			m_nCamWidth = m_iniFile.GetProfileIntA("SERVER_INFO", "CAMERA_WIDTH", 3072);
			m_nCamHeight = m_iniFile.GetProfileIntA("SERVER_INFO", "CAMERA_HEIGHT", 2048);

			m_iniFile.GetProfileStringA("SERVER_INFO", "PLC_IP", "192.168.2.39", szValue, MAX_PATH);
			m_strPlcIP.Format("%s", szValue);

			m_nSockPlcPort = m_iniFile.GetProfileIntA("SERVER_INFO", "PLC_PORT", 12288);
			m_nServerPort = m_iniFile.GetProfileIntA("SERVER_INFO", "SERVER_PORT", 8234);

			m_iniFile.GetProfileStringA("SERVER_INFO", "SERVER_IP", "127.0.0.1", szValue, MAX_PATH);
			m_strServerIP.Format("%s", szValue);

			m_iniFile.GetProfileStringA("SERVER_INFO", "CLIENT_COM_FOLDER", "Z:\\", szValue, MAX_PATH);
			m_strComFolerName.Format("%s", szValue);

			m_iniFile.GetProfileStringA("SERVER_INFO", "EQUIP_NAME", "Equipment Name", szValue, MAX_PATH);
			m_strEquipName.Format("%s", szValue);

			m_iniFile.GetProfileStringA("SERVER_INFO", "CLIENT_NAME", "Dispensing Stage Align", szValue, MAX_PATH);
			m_strClientName.Format("%s", szValue);

			m_iniFile.GetProfileStringA("SERVER_INFO", "MARK_REGIST_RATIO", "1.0", szValue, MAX_PATH);
			m_dMarkRegistRatio = atof(szValue);

			m_iniFile.GetProfileStringA("SERVER_INFO", "MARK_CALBRATION_MIN_SCORE", "65.0", szValue, MAX_PATH);
			m_dCalibrationMarkMinScore = atof(szValue);

			m_iniFile.GetProfileStringA("SERVER_INFO", "TRACE_GOLD_DATA", "", szValue, MAX_PATH);
			m_strGoldenDataFile.Format("%s", szValue);

			m_dMarkInputTime = m_iniFile.GetProfileIntA("SERVER_INFO", "MANUAL_MARK_INPUTTIME", 120);

			m_bSaveReslutImage = m_iniFile.GetProfileIntA("SERVER_INFO", "SAVE_RESULT_IMG", 1);
			m_bSaveRawImage = m_iniFile.GetProfileIntA("SERVER_INFO", "SAVE_RAW_IMAGE", 1);
			m_nSaveTerm = m_iniFile.GetProfileIntA("SERVER_INFO", "SAVE_IMG_TERM", 30);
			m_nHDD_UsedRate = m_iniFile.GetProfileIntA("SERVER_INFO", "SAVE_HDD_USED_RATE", 90);

			m_bUseRAlignFlag = m_iniFile.GetProfileIntA("SERVER_INFO", "USE_RALIGN_FLAG", 0);
			m_bELB_LightControlMethod = m_iniFile.GetProfileIntA("SERVER_INFO", "USE_ELB_LIGHTCONTROL_METHOD", 1);

			m_iniFile.GetProfileStringA("SERVER_INFO", "NOTCH_LEFT_DISTANCE_FROM_CENTER", "12.7", szValue, MAX_PATH);
			notch_left_distance_from_center = atof(szValue);
			m_iniFile.GetProfileStringA("SERVER_INFO", "NOTCH_RIGHT_DISTANCE_FROM_CENTER", "1.2", szValue, MAX_PATH);
			notch_right_distance_from_center = atof(szValue);

			m_dDummyStart_posXY.x = m_iniFile.GetProfileIntA("SERVER_INFO", "DUMMY_START_POSX", 10);
			m_dDummyStart_posXY.y = m_iniFile.GetProfileIntA("SERVER_INFO", "DUMMY_START_POSY", 10);
			m_dDummyInspRangeHeight = m_iniFile.GetProfileIntA("SERVER_INFO", "DUMMY_INSP_HEIGHT", 200);

			m_iniFile.GetProfileStringA("SERVER_INFO", "CLIENT_RDP_LOG_FOLDER", "Z:\\", szValue, MAX_PATH);
			m_strRDP_LogDir.Format("%s", szValue);

			if(m_strRDP_LogDir == "Z:\\") m_iniFile.WriteProfileString("SERVER_INFO", "CLIENT_RDP_LOG_FOLDER", "G:\\");

			if (m_dDummyStart_posXY.x == 10 && m_dDummyStart_posXY.y == 10)
			{
				m_iniFile.WriteProfileString("SERVER_INFO", "DUMMY_START_POSX", std::to_string(m_dDummyStart_posXY.x).c_str());
				m_iniFile.WriteProfileString("SERVER_INFO", "DUMMY_START_POSY", std::to_string(m_dDummyStart_posXY.y).c_str());
				m_iniFile.WriteProfileString("SERVER_INFO", "DUMMY_INSP_HEIGHT", std::to_string(m_dDummyInspRangeHeight).c_str());
			}
			readLightCtrlInfo(&m_stLightCtrlInfo);
		}
		else
		{
			m_iniFile.WriteProfileString("SERVER_INFO", "CLIENT_ID", "1");
			m_iniFile.WriteProfileString("SERVER_INFO", "CAMERA_NUM", "2");
			m_iniFile.WriteProfileString("SERVER_INFO", "VIEW_XDIR_NUM", "2");
			m_iniFile.WriteProfileString("SERVER_INFO", "VIEW_YDIR_NUM", "2");
			m_iniFile.WriteProfileString("SERVER_INFO", "CAMERA_WIDTH", "3072");
			m_iniFile.WriteProfileString("SERVER_INFO", "CAMERA_HEIGHT", "2048");
			m_iniFile.WriteProfileString("SERVER_INFO", "SERVER_IP", "127.0.0.1");
			m_iniFile.WriteProfileString("SERVER_INFO", "SERVER_PORT", "8234");
			m_iniFile.WriteProfileString("SERVER_INFO", "SAVE_IMAGE_RAW", "1");
			m_iniFile.WriteProfileString("SERVER_INFO", "SAVE_IMAGE_RESLUT", "1");
			m_iniFile.WriteProfileString("SERVER_INFO", "SAVE_DATA_TERM", "30");
		}
	}
	else
	{
		fnSetMessage(1, "Fail to Load the ini file.");
	}
}
BOOL CLET_AlignClientDlg::saveIniFlag()
{
	return TRUE;
}
int CLET_AlignClientDlg::fnSetMessage(int nType, CString strText1, CString strText2)
{
	CDlgMessage dlg(this);
	dlg.setType(nType);
	dlg.setMessage(strText1, strText2);
	dlg.DoModal();
	return dlg.IsOK();
}
void CLET_AlignClientDlg::copyMemory(void *pDst, void *pSrc, int size)
{
	if (pDst == NULL || pSrc == NULL)	return;

	m_csShareMem.Lock();
	memcpy(pDst, pSrc, size);
	m_csShareMem.Unlock();
}
void CLET_AlignClientDlg::releaseBuffer()
{
	if (m_nBitData != NULL)			delete m_nBitData;
	if (m_nBitPreData != NULL)		delete m_nBitPreData;
	if (m_nBitWriteData != NULL)	delete m_nBitWriteData;
	if (m_nBitWritePreData != NULL) delete m_nBitWritePreData;
	if (m_nWordData != NULL)		delete m_nWordData;

	if (m_pSrcImage != NULL)
	{
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			if (m_pSrcImage[nCam] != NULL)
				delete[]m_pSrcImage[nCam];
		}

		delete[]m_pSrcImage;
		m_pSrcImage = NULL;
	}

	if (m_pProcImage != NULL)
	{
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			for (int nPos = 0; nPos < NUM_POS; nPos++)
			{
				if (m_pProcImage[nCam][nPos] != NULL)
					delete[]m_pProcImage[nCam][nPos];

			}
			delete[]m_pProcImage[nCam];
		}

		delete[]m_pProcImage;
		m_pProcImage = NULL;
	}

	if (m_pSaveImageBuf != NULL)
	{
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			for (int nIndex = 0; nIndex < MAX_SAVE_IMAGE_RING_BUF; nIndex++)
				if (m_pSaveImageBuf[nCam][nIndex] != NULL)
					delete[]m_pSaveImageBuf[nCam][nIndex];

			if (m_pSaveImageBuf[nCam] != NULL)
				delete[]m_pSaveImageBuf[nCam];
		}

		delete[]m_pSaveImageBuf;
		m_pSaveImageBuf = NULL;
	}

	cvReleaseImage(&m_pIplSrcImage);
	
	if (m_pCameraViewImage != NULL)
	{
		delete[]m_pCameraViewImage;
		m_pCameraViewImage = NULL;
	}
}
void CLET_AlignClientDlg::releaseObject()
{
	BOOL bEnd = FALSE;
	while (1) {
		bEnd = TRUE;
		if (m_bThreadPLCSignalCheckEnd != TRUE)
		{
			bEnd = FALSE;
			break;
		}
		Sleep(10);
		if (bEnd != TRUE) continue;
		else break;
	}
}

void CLET_AlignClientDlg::initBuffer()
{	
	m_nBitData = new long[getSizeReadBit()];
	m_nBitPreData = new long[getSizeReadBit()];
	m_nBitWriteData = new long[getSizeWriteBit()];
	m_nBitWritePreData = new long[getSizeWriteBit()];
	m_nWordData = new long[getSizeReadWord()];

	memset(m_nBitData, 0, sizeof(long) * getSizeReadBit());
	memset(m_nBitPreData, 0, sizeof(long) * getSizeReadBit());
	memset(m_nBitWriteData, 0, sizeof(long) * getSizeWriteBit());
	memset(m_nBitWritePreData, 0, sizeof(long) * getSizeWriteBit());
	memset(m_nWordData, 0, sizeof(long) * getSizeReadWord());

	m_pSrcImage = new BYTE*[MAX_CAMERA];

	if (m_pSrcImage != NULL)
	{
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			int W = m_stCamInfo[nCam].w;
			int H = m_stCamInfo[nCam].h;

			m_stCamInfo[nCam].size = W * H;
			m_pSrcImage[nCam] = new BYTE[m_stCamInfo[nCam].size];
			memset(m_pSrcImage[nCam], 0, m_stCamInfo[nCam].size);
		}
	}

	m_pProcImage = new BYTE**[MAX_CAMERA];

	if (m_pProcImage != NULL)
	{
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			m_pProcImage[nCam] = new BYTE *[NUM_POS];

			for (int nPos = 0; nPos < NUM_POS; nPos++)
			{
				m_pProcImage[nCam][nPos] = new BYTE[m_stCamInfo[nCam].size];
				memset(m_pProcImage[nCam][nPos], 0, m_stCamInfo[nCam].size);
			}
		}
	}

	m_pSaveImageBuf = new BYTE**[MAX_CAMERA];
	if (m_pSaveImageBuf != NULL)
	{
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			m_pSaveImageBuf[nCam] = new BYTE*[MAX_SAVE_IMAGE_RING_BUF];

			for (int nIndex = 0; nIndex < MAX_SAVE_IMAGE_RING_BUF; nIndex++)
			{
				m_pSaveImageBuf[nCam][nIndex] = new BYTE[m_stCamInfo[nCam].size];
				memset(m_pSaveImageBuf[nCam][nIndex], 0, m_stCamInfo[nCam].size);
			}
		}
	}

	//m_pIplSrcImage = cvCreateImage(cvSize(m_nCamWidth, m_nCamHeight), 8, 1);

	//m_pCameraViewImage = new BYTE[m_nCamWidth * m_nCamHeight];
	//memset(m_pCameraViewImage, 0, m_nCamWidth * m_nCamHeight);

}
void CLET_AlignClientDlg::initPLC_CommunationAddress()
{
	int address, address2, address3, address4,glassID;

	for (int nJob = 0; nJob < vt_job_info.size(); nJob++)
	{
		address = vt_job_info[nJob].plc_addr_info.read_bit_start;
		address2 = vt_job_info[nJob].plc_addr_info.read_word_start;
		address3 = vt_job_info[nJob].plc_addr_info.write_bit_start;
		address4 = vt_job_info[nJob].plc_addr_info.write_word_start;
		glassID = vt_job_info[0].plc_addr_info.read_main_object_id_start;

		m_nCurrentXMotorPos[nJob] = address2 + 0;
		m_nCurrentYMotorPos[nJob] = address2 + 2;
		m_nCurrentTMotorPos[nJob] = address2 + 4;
		m_nRevisionXMotorPos[nJob] = address4 + 0;
		m_nRevisionYMotorPos[nJob] = address4 + 2;
		m_nRevisionTMotorPos[nJob] = address4 + 4;

		switch (vt_job_info[nJob].algo_method)
		{
		case CLIENT_TYPE_ALIGN: {
			m_nAlignRequestRead[nJob] = address + 0;
			m_nAlignOkWrite[nJob] = address3 + 0;
			m_nAlignNgWrite[nJob] = address3 + 1;
			m_nAlignCompletWrite[nJob] = address3 + 2;
			m_nAlignManualMarkWrite[nJob] = address3 + 3;
			m_nAlignLcheckNgWrite[nJob] = address3 + 4;
		}
							  break;  //2CAM 2Align 각 카메라당 1개 Mark
		case CLIENT_TYPE_1CAM_1SHOT_ALIGN:
		case CLIENT_TYPE_1CAM_1SHOT_FILM:
		case CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP:
		{
			m_nAlignRequestRead[nJob] = address + 0;
			m_nAlignOkWrite[nJob] = address3 + 0;
			m_nAlignNgWrite[nJob] = address3 + 1;
			m_nAlignCompletWrite[nJob] = address3 + 2;
			m_nAlignManualMarkWrite[nJob] = address3 + 3;
			m_nAlignLcheckNgWrite[nJob] = address3 + 4;
		}
		break;  //1CAM 2Align  카메라당 2개 Mark
		case CLIENT_TYPE_1CAM_2SHOT_ALIGN: {
			m_nAlignRequestRead[nJob] = address + 0;
			m_nAlignOkWrite[nJob] = address3 + 0;
			m_nAlignNgWrite[nJob] = address3 + 1;
			m_nAlignCompletWrite[nJob] = address3 + 2;
			m_nAlignManualMarkWrite[nJob] = address3 + 3;
			m_nAlignLcheckNgWrite[nJob] = address3 + 4;
		}
										 break;  //1CAM 2Align  카메라당 1개 Mark
		case CLIENT_TYPE_4CAM_1SHOT_ALIGN: {
			m_nAlignRequestRead[nJob] = address + 0;
			m_nAlignOkWrite[nJob] = address3 + 0;
			m_nAlignNgWrite[nJob] = address3 + 1;
			m_nAlignCompletWrite[nJob] = address3 + 2;
			m_nAlignManualMarkWrite[nJob] = address3 + 3;
			m_nAlignLcheckNgWrite[nJob] = address3 + 4;
		}
										 break;  //4CAM 4Align 각 카메라당 1개 Mark
		case CLIENT_TYPE_PANEL_EXIST_INSP: {
			m_nInspRequestRead[nJob] = address + 0;
			m_nInspAckWrite[nJob] = address3 + 0;
			m_nInspOkWrite[nJob] = address3 + 0;
			m_nInspNgWrite[nJob] = address3 + 1;
			m_nInspResultWrite[nJob] = address3;
		}
										 break;
		case CLIENT_TYPE_PCB_DISTANCE_INSP: {
			m_nInspRequestRead[nJob] = address + 0;
			m_nInspWordDataRead[nJob] = address4 + 0;
			m_nInspAckWrite[nJob] = address3 + 2;
			m_nInspOkWrite[nJob] = address3 + 0;
			m_nInspNgWrite[nJob] = address3 + 1;
			m_nInspResultWrite[nJob] = address3 + 10;
		}
										  break;
		case CLIENT_TYPE_ASSEMBLE_INSP: {
			m_nInspRequestRead[nJob] = address + 0;
			m_nInspAckWrite[nJob] = address3 + 0;
			m_nInspOkWrite[nJob] = address3 + 0;
			m_nInspNgWrite[nJob] = address3 + 1;
			m_nInspResultWrite[nJob] = address3 + 10;
		}
									  break;
		case CLIENT_TYPE_SCAN_INSP: {
			m_nInspRequestRead[nJob] = address + 0;
			m_nInspAckWrite[nJob] = address3 + 2;
			m_nInspOkWrite[nJob] = address3 + 0;
			m_nInspNgWrite[nJob] = address3 + 1;
			m_nAlignOkWrite[nJob] = address3 + 0;
			m_nAlignNgWrite[nJob] = address3 + 1;
			m_nInspResultWrite[nJob] = address3 + 10;
			m_nAlignManualMarkWrite[nJob] = address3 + 3;
		}
		break;
		case CLIENT_TYPE_NOZZLE_SIDE_VIEW:  // Tkyuha 필름 검사와 같이 어드레스 공유 해서 break 삭제
		{
			//KJH 2022-01-03 현장에서 인터페이스 새로 맞춤(Nozzle Gap과 겹침)
			m_nInspRequestRead[nJob] = address + 0;
			m_nInspAckWrite[nJob] = address3 + 0;
			m_nInspOkWrite[nJob] = address3 + 0;
			m_nInspNgWrite[nJob] = address3 + 1;
		}
        break;
		case CLIENT_TYPE_FILM_INSP:
		{
			m_nInspRequestRead[nJob] = address + 0;
			m_nInspAckWrite[nJob] = address3 + 0;
			m_nInspOkWrite[nJob] = address3 + 0;
			m_nInspNgWrite[nJob] = address3 + 1;
			m_nInspResultWrite[nJob] = address3 + 10;
		}
		break;
		default:
		{
			m_nAlignRequestRead[nJob] = address + 0;
			m_nAlignOkWrite[nJob] = address3 + 0;
			m_nAlignNgWrite[nJob] = address3 + 1;
			m_nAlignCompletWrite[nJob] = address3 + 2;
			m_nAlignManualMarkWrite[nJob] = address3 + 3;
		}
		break;
		}
	}
}
void CLET_AlignClientDlg::initCaliper()
{
	// Caliper ///
	CRect rectCaliper;
	m_pDlgCaliper = new CDlgCaliper;

	// KBJ 2022-12-03 캘리퍼 선택 라인 이름 바뀌도록 수정
	for (int nJob = int(vt_job_info.size()-1); nJob > -1; nJob--)
	{
		int nMethod = vt_job_info[nJob].algo_method;

		for (int i = 0; i < vt_job_info[nJob].num_of_camera; i++)
		{
			int real_cam = vt_job_info[nJob].camera_index[i];

			for (int nPos = 0; nPos < vt_job_info[nJob].num_of_position; nPos++)
			{
				for (int nLine = 0; nLine < MAX_CALIPER_LINES; nLine++)
				{
					sprintf(m_pDlgCaliper->m_cCaliperName[real_cam][nPos][nLine], "%s", vt_job_info[nJob].caliper_name[i][nPos][nLine].c_str());
				}
			}
		}
	}

	m_pDlgCaliper->Create(IDD_DLG_CALIPER, this);
	m_pDlgCaliper->m_pMain = this;
	m_pDlgCaliper->GetWindowRect(&rectCaliper);

	rectCaliper.left += 700;
	rectCaliper.right += 700;
	rectCaliper.top -= 250;
	rectCaliper.bottom -= 250;
	m_pDlgCaliper->MoveWindow(&rectCaliper);
	m_pDlgCaliper->ShowWindow(SW_HIDE);
	m_pDlgCaliper->m_pViewer = &((CFormCameraView*)m_pForm[FORM_CAMERA])->m_ViewerCamera;
	m_pDlgCaliper->m_pCaliperResult->InitList(m_pDlgCaliper->m_pCaliperResult->m_listCaliper);
	//((CFormCameraView*)m_pForm[FORM_CAMERA])->m_ViewerCamera.m_pDlgCaliper = m_pDlgCaliper;

	INIReader _ini(fmt_("%s/CaliperInfo.ini", m_strCurrentModelPath.GetString()));  // Tkyuha 20221227 속도 올리기 위함

	std::vector<std::thread*> ths;
	for (int nObject = 0; nObject < MAX_CALIPER_OBJECT; nObject++)
	{
		if (m_stCamInfo[nObject].buse == 0) continue; //Tkyuha 20221125 속도 올리기 위해 사용 하지 않는 카메라는 무시

		for (int nPos = 0; nPos < NUM_POS; nPos++)
		{
			for (int nLine = 0; nLine < MAX_CALIPER_LINES; nLine++)
			{
				ths.push_back(
					new std::thread([=]() {
						m_pDlgCaliper->readCaliperInfo(&_ini, &m_pDlgCaliper->m_Caliper[nObject][nPos][nLine], nObject, nPos, nLine); // Tkyuha 20221227 속도 올리기 위함
						m_pDlgCaliper->m_Caliper[nObject][nPos][nLine].init_caliper_info();
						if (m_pDlgCaliper->m_Caliper[nObject][nPos][nLine].getCircleCaliper())		m_pDlgCaliper->m_Caliper[nObject][nPos][nLine].calcCaliperCircle();
						else																		m_pDlgCaliper->m_Caliper[nObject][nPos][nLine].calcCaliperRect();
						m_pDlgCaliper->m_Caliper[nObject][nPos][nLine].setCaliperDC(((CFormCameraView*)m_pForm[FORM_CAMERA])->m_ViewerCamera.getOverlayDC());
						}));
			}
		}
	}

	for (auto& th : ths) { th->join(); delete th; }
	ths.clear();

	//if(m_pDlgCaliper->m_Caliper[0][0][0].getCircleCaliper() )	m_pDlgCaliper->m_Caliper[0][0][0].DrawCaliper_Circle(m_pDlgCaliper->m_pDC);
	//else														m_pDlgCaliper->m_Caliper[0][0][0].DrawCaliper(m_pDlgCaliper->m_pDC);
	m_pDlgCaliper->m_pCaliperParam->updateUIFromData();
	m_pDlgCaliper->m_pCaliperParam->updateCoordinates();

	init_copy_caliper_info();
}

void CLET_AlignClientDlg::connectLightCtrl_NewType()
{
	int nNumOfLight = m_stLightCtrlInfo.nNumOfLightCtrl;
	int nLightPort = 0;
	int nLightBaudrate = 0;
	int nLightType = 0;
	int nSockPort = 0;
	CString strIP;
	BOOL bConnect = FALSE;

	for (int i = 0; i < nNumOfLight; i++)
	{
		nLightPort = m_stLightCtrlInfo.nPort[i];
		nLightBaudrate = m_stLightCtrlInfo.nBaudrate[i];
		nLightType = m_stLightCtrlInfo.nType[i];
		nSockPort = m_stLightCtrlInfo.nSockPort[i];
		strIP.Format("%s", m_stLightCtrlInfo.cSockIP[i]);

		if (nLightType == LTYPE_LLIGHT_LPC_COT_SOCK || nLightType == LTYPE_LLIGHT_LPW_SOCK)
		{
			m_LightSock[i].m_nID = i;
			m_LightSock[i].m_WM_VIEW_CONTROL = WM_VIEW_CONTROL;
			m_LightSock[i].m_MSG_DISCONNECT = MSG_HB_CONNECT_LIGHT;
			m_LightSock[i].m_MSG_CONNECT = MSG_HB_CONNECT_LIGHT;
			m_LightSock[i].m_hMsgHandle = m_pPaneHeader->m_hWnd;

			bConnect = m_LightSock[i].Connect(strIP, nSockPort);
		}
		else
		{
			bConnect = m_Light[i].OpenPort(nLightPort, nLightBaudrate);

			m_Light[i].m_nID = i;
			m_Light[i].GetComm().m_bConnected = bConnect;
			m_Light[i].m_WM_VIEW_CONTROL = WM_VIEW_CONTROL;
			m_Light[i].m_MSG_LIGHT_RECV_ACK = MSG_HB_CONNECT_LIGHT;		//210105 Ack 신호 받을시 연결표시. 
			m_Light[i].setCommWnd(m_pPaneHeader->m_hWnd);
			//m_Light[i].setCommWnd(this->m_hWnd);
			m_Light[i].setLightType(nLightType);

			if (!bConnect) ::SendMessage(m_pPaneHeader->m_hWnd, WM_VIEW_CONTROL, MSG_HB_CONNECT_LIGHT, MAKELPARAM(m_Light[i].m_nID, FALSE));
			//if(bConnect) ::SendMessage(m_pPaneHeader->m_hWnd, WM_VIEW_CONTROL, MSG_HB_CONNECT_LIGHT, MAKELPARAM(i, TRUE));
			//else ::SendMessage(m_pPaneHeader->m_hWnd, WM_VIEW_CONTROL, MSG_HB_CONNECT_LIGHT, MAKELPARAM(i, FALSE));
			// TSM  조명은 초기에 ON 시키는 명령을 한다.
			if (nLightType == 1)
			{
				CString strTemp;
				for (int nCh = 0; nCh < 4; nCh++)
				{
					strTemp.Format(_T("\x002%02dON%d\x003\r\n"), nCh + 1, 1);  // [STX:0x02] + channel(2글자) + WR + value(3글자) + [ETX0x03]
					m_Light[i].sendSerialData(strTemp);
					Sleep(50);
				}
			}
			else if (nLightType == LTYPE_LLIGHT_LPW_232)
			{
				//strTemp.Format(_T("\x002%02dON%d\x003\r\n"), nCh + 1, 1);  // [STX:0x02] + channel(2글자) + WR + value(3글자) + [ETX0x03]
				//m_Light[i].sendSerialData(strTemp);

			/*	m_Light[i].set_light_value(0, 10);
				m_Light[i].set_light_value(1, 11);
				m_Light[i].set_light_value(2, 12);
				m_Light[i].set_light_value(3, 13);*/
			}
		}
	}
}
void CLET_AlignClientDlg::LoadCameraini(void)
{
	if ((_access(m_strConfigDir, 0)) != -1)
	{
		CFileStatus fs;
		if (CFile::GetStatus(m_strConfigDir + _T("Camera.ini"), fs))
		{
			TCHAR szValue[MAX_PATH];
			CString  strValue, strV, strSection;

			for (int i = 0; i < MAX_CAMERA; i++)
			{
				strSection.Format("CAMERA%d_INFO", i+1);

				strValue.Format("SERIAL");					m_iniCameraFile.GetProfileStringA(strSection, strValue, "123456789", szValue, MAX_PATH);
				strValue.Format("%s", szValue);				sprintf_s(m_stCamInfo[i].cSerial, strValue);
				strValue.Format("WIDTH", i + 1);			m_stCamInfo[i].w = m_iniCameraFile.GetProfileIntA(strSection, strValue, 3088);
				strValue.Format("HEIGHT", i + 1);			m_stCamInfo[i].h = m_iniCameraFile.GetProfileIntA(strSection, strValue, 2064);
				strValue.Format("DEPTH", i + 1);			m_stCamInfo[i].depth = m_iniCameraFile.GetProfileIntA(strSection, strValue, 8);
				strValue.Format("FLIP_DIR", i + 1);			m_stCamInfo[i].flip_dir = m_iniCameraFile.GetProfileIntA(strSection, strValue, 0);
				strValue.Format("SIZE", i + 1);				m_stCamInfo[i].size = m_iniCameraFile.GetProfileIntA(strSection, strValue, 6373632);
				strValue.Format("USE", i + 1);				m_stCamInfo[i].buse = m_iniCameraFile.GetProfileIntA(strSection, strValue, 1);
	
				strValue.Format("USE_CMD_REVERSE_X", i + 1);	m_stCamInfo[i].use_cmd_reverse_x = m_iniCameraFile.GetProfileIntA(strSection, strValue, 0);
				strValue.Format("REVERSE_X", i + 1);			m_stCamInfo[i].reverse_x = m_iniCameraFile.GetProfileIntA(strSection, strValue, 0);
				strValue.Format("USE_CMD_REVERSE_Y", i + 1);	m_stCamInfo[i].use_cmd_reverse_y = m_iniCameraFile.GetProfileIntA(strSection, strValue, 0);
				strValue.Format("REVERSE_Y", i + 1);			m_stCamInfo[i].reverse_y = m_iniCameraFile.GetProfileIntA(strSection, strValue, 0);
				strValue.Format("USE_CMD_FIX_FRAME", i + 1);	m_stCamInfo[i].use_cmd_fix_frame = m_iniCameraFile.GetProfileIntA(strSection, strValue, 0);
				strValue.Format("FRAME_RATE", i + 1);			m_stCamInfo[i].frame_rate = m_iniCameraFile.GetProfileIntA(strSection, strValue, 3);
				strValue.Format("USE_CMD_PACKET_SIZE", i + 1);	m_stCamInfo[i].use_cmd_packet_size = m_iniCameraFile.GetProfileIntA(strSection, strValue, 0);
				strValue.Format("PACKET_SIZE", i + 1);			m_stCamInfo[i].packet_size = m_iniCameraFile.GetProfileIntA(strSection, strValue, 1500);
				
				strValue.Format("NAME", i + 1);
				strV.Format("Cam %d", i + 1);
				m_iniCameraFile.GetProfileStringA(strSection, strValue, strV, szValue, MAX_PATH);
				strValue.Format("%s", szValue);				sprintf_s(m_stCamInfo[i].cName, strValue);

				if (m_stCamInfo[i].flip_dir == 1 || m_stCamInfo[i].flip_dir == 2)
					std::swap(m_stCamInfo[i].w, m_stCamInfo[i].h);
			}
		}
		else
		{
			CString  strValue;
			for (int i = 0; i < MAX_CAMERA; i++)
			{
				strValue.Format("CAM%d_ID", i + 1);			m_iniCameraFile.WriteProfileString("CAMERA_INFO", strValue, "123456789");
				strValue.Format("CAM%d_W", i + 1);			m_iniCameraFile.WriteProfileString("CAMERA_INFO", strValue, "3088");
				strValue.Format("CAM%d_H", i + 1);			m_iniCameraFile.WriteProfileString("CAMERA_INFO", strValue, "2064");
				strValue.Format("CAM%d_D", i + 1);			m_iniCameraFile.WriteProfileString("CAMERA_INFO", strValue, "8");
				strValue.Format("CAM%d_S", i + 1);			m_iniCameraFile.WriteProfileString("CAMERA_INFO", strValue, "6373632");
			}
		}
	}
	else
	{
		fnSetMessage(1, "Fail to Load the Camera ini file.");
	}
}
void CLET_AlignClientDlg::LoadViewerini(void)
{
	CViewerInfo temp_viewer_info;

#ifndef JOB_INFO
	if ((_access(m_strConfigDir, 0)) != -1)
	{
		CFileStatus fs;
		if (CFile::GetStatus(m_strConfigDir + _T("Viewer.ini"), fs))
		{
			TCHAR szValue[MAX_PATH];
			CString  strValue, strKey, strSection;
			int nValue = 0;

			for (int i = 0; i < MAX_CAMERA; i++)
			{
				strSection.Format("VIEWER%d_INFO", i+1);

				strKey.Format("NAME");							m_iniViewerFile.GetProfileStringA(strSection, strKey, "Align_Cam", szValue, MAX_PATH);		strValue.Format("%s", szValue);
				m_pViewDisplayInfo[i].setViewerName(strValue);
				strKey.Format("WIDTH");							m_pViewDisplayInfo[i].setViewImageWidth(m_iniViewerFile.GetProfileIntA(strSection, strKey, 3088));
				strKey.Format("HEIGHT");						m_pViewDisplayInfo[i].setViewImageHeight(m_iniViewerFile.GetProfileIntA(strSection, strKey, 2064));
				strKey.Format("CAMID");							m_pViewDisplayInfo[i].setCameraID(m_iniViewerFile.GetProfileIntA(strSection, strKey, 0));
				strKey.Format("NUM_OF_USING_LIGHT");			m_pViewDisplayInfo[i].set_num_of_using_light(m_iniViewerFile.GetProfileIntA(strSection, strKey, 0));

				strKey.Format("VIEWER_POS");					m_pViewDisplayInfo[i].set_viewer_pos(m_iniViewerFile.GetProfileIntA(strSection, strKey, i));


				for (int light = 0; light < MAX_LIGHT_PER_CAMERA; light++)
				{
					strKey.Format("LIGHTCONTROL_%d", light + 1);
					nValue = m_iniViewerFile.GetProfileIntA(strSection, strKey, 1);
					m_pViewDisplayInfo[i].setLightController(light, nValue);

					strKey.Format("LIGHTCHANNEL_%d", light + 1);
					nValue = m_iniViewerFile.GetProfileIntA(strSection, strKey, light);
					m_pViewDisplayInfo[i].setLightChannel(light, nValue);

					strKey.Format("LIGHTCHANNELNAME_%d", light + 1);
					m_iniViewerFile.GetProfileStringA(strSection, strKey, "reserved", szValue, MAX_PATH);
					m_pViewDisplayInfo[i].setLightChannelName(light, szValue);
				}

				for (int index = 0; index < 4; index++)
				{
					strKey.Format("LIGHTINDEXNAME_%d", index + 1);
					strValue.Format("%d", index + 1);
					m_iniViewerFile.GetProfileStringA(strSection, strKey, strValue, szValue, MAX_PATH);
					m_pViewDisplayInfo[i].setLightIndexName(index, szValue);
				}

				strKey.Format("POPUP");						m_pViewDisplayInfo[i].seUseViewerPopup(m_iniViewerFile.GetProfileIntA(strSection, strKey, 0));
				strKey.Format("RESOLUTION_X");				m_iniViewerFile.GetProfileStringA(strSection, strKey, "0.0096", szValue, MAX_PATH);	strValue.Format("%s", szValue);
															m_pViewDisplayInfo[i].setResolutionX(atof(strValue));

				strKey.Format("RESOLUTION_Y");				m_iniViewerFile.GetProfileStringA(strSection, strKey, "0.0096", szValue, MAX_PATH);	strValue.Format("%s", szValue);
															m_pViewDisplayInfo[i].setResolutionY(atof(strValue));
				strKey.Format("FLIPDIR");					m_pViewDisplayInfo[i].setFlipDir(m_iniViewerFile.GetProfileIntA(strSection, strKey, 0));
				strKey.Format("METHOD");					m_pViewDisplayInfo[i].setMethod(m_iniViewerFile.GetProfileIntA(strSection, strKey, 0)); //Mark 0, Caliper 1,Mark & Caliper 2,Exist Insp 3
				strKey.Format("MARK_COUNT");				m_pViewDisplayInfo[i].setMarkCount(m_iniViewerFile.GetProfileIntA(strSection, strKey, 1));
				strKey.Format("CALIPER_COUNT");				m_pViewDisplayInfo[i].setCaliperCount(m_iniViewerFile.GetProfileIntA(strSection, strKey, 2));
			}
			strSection.Format("MACHINE_VIEWER_INFO");
			for (int i = 0; i < MAX_CAMERA; i++)
			{
				strKey.Format("USE_CHANGE_MCVIEWER_ALGO%d", i + 1);			GetMachine().setMcViewerChange(i,m_iniViewerFile.GetProfileIntA(strSection, strKey, 0));
			}
		}
	}
	else
	{
		fnSetMessage(1, "Fail to Load the Viewer ini file.");
	}
#else
	if ((_access(m_strConfigDir, 0)) != -1)
	{
		CFileStatus fs;
		if (CFile::GetStatus(m_strConfigDir + _T("Viewer.ini"), fs))
		{
			TCHAR szValue[MAX_PATH];
			CString  strValue, strKey, strSection, strData;
			int nValue = 0;

			strSection = "VIEWER_INFO";
			nValue = m_iniViewerFile.GetProfileIntA(strSection, "NUM_OF_VIEWER", 1);
			vt_viewer_info.assign(nValue, temp_viewer_info);

			m_nViewX_Num = m_iniViewerFile.GetProfileIntA(strSection, "VIEWER_COUNT_X", 2);
			m_nViewY_Num = m_iniViewerFile.GetProfileIntA(strSection, "VIEWER_COUNT_Y", 2);

			for (int i = 0; i < vt_viewer_info.size(); i++)
			{
				strSection.Format("VIEWER%d_INFO", i + 1);

				strKey.Format("NAME");
				strData.Format("Viewer%d", i + 1);
				m_iniViewerFile.GetProfileStringA(strSection, strKey, strData, szValue, MAX_PATH);		
				strValue.Format("%s", szValue);
				vt_viewer_info[i].viewer_name = strValue;

				strKey.Format("WIDTH");
				vt_viewer_info[i].image_width = m_iniViewerFile.GetProfileIntA(strSection, strKey, 3088);

				strKey.Format("HEIGHT");
				vt_viewer_info[i].image_height = m_iniViewerFile.GetProfileIntA(strSection, strKey, 2064);

				strKey.Format("VIEWER_POS");
				vt_viewer_info[i].viewer_position = m_iniViewerFile.GetProfileIntA(strSection, strKey, i);

				strKey.Format("USE_POPUP");
				vt_viewer_info[i].use_viewer_popup = m_iniViewerFile.GetProfileIntA(strSection, strKey, 0);

				strKey.Format("RESOLUTION_X");
				m_iniViewerFile.GetProfileStringA(strSection, strKey, "0.0096", szValue, MAX_PATH);
				vt_viewer_info[i].resolution_x = atof(szValue);

				strKey.Format("RESOLUTION_Y");
				m_iniViewerFile.GetProfileStringA(strSection, strKey, "0.0096", szValue, MAX_PATH);
				vt_viewer_info[i].resolution_y = atof(szValue);

				strKey.Format("CAMERA_INDEX");
				vt_viewer_info[i].camera_index = m_iniViewerFile.GetProfileIntA(strSection, strKey, 0);

				strKey.Format("IMAGE_VIEW_INDEX");
				vt_viewer_info[i].image_index = m_iniViewerFile.GetProfileIntA(strSection, strKey, 0);

				strKey.Format("CAMERA_GRAB_STATUS");
				vt_viewer_info[i].camera_status = m_iniViewerFile.GetProfileIntA(strSection, strKey, 0);
			}
		}
	}
	else
	{
		fnSetMessage(1, "Fail to Load the Viewer ini file.");
	}

	
#endif
}
void CLET_AlignClientDlg::LoadAlgoini()
{
	int value = 0;
	CJobInfo temp_job_info;

#ifndef JOB_INFO
	if ((_access(m_strConfigDir, 0)) != -1)
	{
		CFileStatus fs;
		if (CFile::GetStatus(m_strConfigDir + _T("Algorithm.ini"), fs))
		{
			TCHAR szValue[MAX_PATH];
			CString  strValue, strKey, strData, strSection;

			std::vector<std::vector<int>> m_vAlgoCameraIndex;

			m_pAlgorithmInfo.algorithmBufferInit();
			m_pAlgorithmInfo.setAlgorithmCount(m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", "ALGO_COUNT", 1));

			value = m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", "ALGO_COUNT", 1);


			m_pAlgorithmInfo.setAlgorithmReadIDWordStart(m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", "ALGO_PLC_READ_GLASSID_ADD", 25500));

			for (int i = 0; i < m_pAlgorithmInfo.getAlgorithmCount(); i++)
			{
				strValue.Format("ALGO%d_CAMNUM", i + 1);
				m_pAlgorithmInfo.setAlgorithmCameraNum(i, m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", strValue, 2));
			}

			for (int i = 0; i < m_pAlgorithmInfo.getAlgorithmCount(); i++)
			{
				strValue.Format("ALGO%d_METHOD", i + 1);
				m_pAlgorithmInfo.setAlgorithmMethod(i, m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", strValue, 0));

				strValue.Format("ALGO%d_NUMPOS", i + 1);
				m_pAlgorithmInfo.setAlgorithmNumPos(i, m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", strValue, 1));
			}

			for (int i = 0; i < m_pAlgorithmInfo.getAlgorithmCount(); i++)
			{
				strValue.Format("ALGO%d_NAME", i + 1);
				m_iniAlgoFile.GetProfileStringA("ALGORITHM_INFO", strValue, "2PointAlign", szValue, MAX_PATH);
				strValue.Format("%s", szValue);
				m_pAlgorithmInfo.setAlgorithmName(i, (LPCTSTR)strValue);
			}

			for (int i = 0; i < m_pAlgorithmInfo.getAlgorithmCount(); i++)
			{
				strValue.Format("ALGO%d_PLC_READ_STARTBIT_ADD", i + 1);
				m_pAlgorithmInfo.setAlgorithmReadBitStart(i, m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", strValue, 15000));
				strValue.Format("ALGO%d_PLC_WRITE_STARTBIT_ADD", i + 1);
				m_pAlgorithmInfo.setAlgorithmWriteBitStart(i, m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", strValue, 15000));
				strValue.Format("ALGO%d_PLC_READ_STARTWORD_ADD", i + 1);
				m_pAlgorithmInfo.setAlgorithmReadWordStart(i, m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", strValue, 15000));
				strValue.Format("ALGO%d_PLC_WRITE_STARTWORD_ADD", i + 1);
				m_pAlgorithmInfo.setAlgorithmWriteWordStart(i, m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", strValue, 15000));
			}

			std::vector<int> v;

			for (int i = 0; i < m_pAlgorithmInfo.getAlgorithmCount(); i++)
			{
				v.clear();
				for (int j = 0; j < m_pAlgorithmInfo.getAlgorithmCameraNum(i); j++)
				{
					strValue.Format("ALGO%d_%d_CAMINDEX", i + 1,j+1);
					v.push_back(m_iniAlgoFile.GetProfileIntA("ALGORITHM_INFO", strValue, j));
				}	

				m_pAlgorithmInfo.setAlgorithmCameraIndex(i, v);
			}
		}
	}
	else
	{
		fnSetMessage(1, "Fail to Load the Viewer ini file.");
	}
#endif
}
void CLET_AlignClientDlg::LoadJobInfo()
{
	int value = 0;
	CJobInfo temp_job_info;
	CJobLightInfo temp_light_info;

	CJobResult temp_job_result;

	CString str_file_path;

	int num_of_job = m_iniFile.GetProfileIntA("SERVER_INFO", "NUM_OF_JOB_COUNT", 0);
	if (num_of_job == 0)
	{
		AfxMessageBox("Num Of Job Count : 0");
	}

	if ((_access(m_strConfigDir, 0)) != -1)
	{
		TCHAR szValue[MAX_PATH];
		CString  strValue, strKey, strData, strSection;

		/////////////////////////
		vt_job_info.assign(num_of_job, temp_job_info);
		vt_result_info.assign(num_of_job, temp_job_result);
		
		for (int i = 0; i < vt_job_info.size(); i++)
		{
			vt_result_info[i].clear();
		}

		for (int i = 0; i < vt_job_info.size(); i++)
		{
			str_file_path.Format("%sJob%d_Info.ini", m_strConfigDir, i + 1);

			////// Job Info
			strSection.Format("JOB_INFO");
			strKey.Format("ALGO_METHOD");
			vt_job_info[i].algo_method = ::GetPrivateProfileInt(strSection, strKey, 0, str_file_path);

			strKey.Format("JOB_NAME");
			strData.Format("No Name Job");
			::GetPrivateProfileString(strSection, strKey, strData, szValue, MAX_PATH, str_file_path);
			strValue.Format("%s", szValue);
			vt_job_info[i].job_name = (LPCTSTR)strValue;

			////// Camera Info
			strSection.Format("CAMERA_INFO");

			strKey.Format("NUM_OF_CAMERA");
			vt_job_info[i].num_of_camera = ::GetPrivateProfileInt(strSection, strKey, 1, str_file_path);

			for (int n = 0; n < vt_job_info[i].num_of_camera; n++)
			{
				strKey.Format("CAMERA_INDEX%d", n + 1);
				//value = m_iniJobFile.GetProfileIntA(strSection, strKey, n);
				value = ::GetPrivateProfileInt(strSection, strKey, n, str_file_path);
				vt_job_info[i].camera_index.push_back(value);

				CPoint pt;
				pt.x = m_stCamInfo[value].w;
				pt.y = m_stCamInfo[value].h;
				vt_job_info[i].camera_size.push_back(pt);
			}

			////// Position Info
			strSection.Format("POSITION_INFO");

			strKey.Format("NUM_OF_POSITION");
			vt_job_info[i].num_of_position = ::GetPrivateProfileInt(strSection, strKey, 1, str_file_path);

			vector<std::string> temp_name;
			vt_job_info[i].position_name.assign(vt_job_info[i].num_of_camera, temp_name);

			for (int k = 0; k < vt_job_info[i].num_of_camera; k++)
			{
				std::string temp_pos_name;
				vt_job_info[i].position_name[k].assign(vt_job_info[i].num_of_position, temp_pos_name);

				for (int m = 0; m < vt_job_info[i].num_of_position; m++)
				{
					strKey.Format("POSITION_NAME%d_%d", k + 1, m + 1);
					strData.Format("Pos %d", m + 1);
					::GetPrivateProfileString(strSection, strKey, strData, szValue, MAX_PATH, str_file_path);
					vt_job_info[i].position_name[k][m] = szValue;
				}
			}


			////// Viewer Info
			strSection.Format("VIEWER_INFO");
			strKey.Format("NUM_OF_VIEWER");
			vt_job_info[i].num_of_viewer = ::GetPrivateProfileInt(strSection, strKey, 1, str_file_path);

			for (int n = 0; n < vt_job_info[i].num_of_viewer; n++)
			{
				strKey.Format("VIEWER_INDEX%d", n + 1);
				value = ::GetPrivateProfileInt(strSection, strKey, n, str_file_path);
				vt_job_info[i].viewer_index.push_back(value);
			}


			strKey.Format("MAIN_VIEW_COUNT_X");
			vt_job_info[i].main_view_count_x = ::GetPrivateProfileInt(strSection, strKey, 1, str_file_path);
			strKey.Format("MAIN_VIEW_COUNT_Y");
			vt_job_info[i].main_view_count_y = ::GetPrivateProfileInt(strSection, strKey, 1, str_file_path);

			vt_job_info[i].main_viewer_index.assign(vt_job_info[i].viewer_index.size(), 0);
			for (int n = 0; n < vt_job_info[i].viewer_index.size(); n++)
			{
				strKey.Format("MAIN_VIEW_INDEX%d", n + 1);
				vt_job_info[i].main_viewer_index[n] = ::GetPrivateProfileInt(strSection, strKey, vt_job_info[i].viewer_index[n], str_file_path);
			}


			strKey.Format("MACHINE_VIEW_COUNT_X");
			vt_job_info[i].machine_view_count_x = ::GetPrivateProfileInt(strSection, strKey, 1, str_file_path);
			strKey.Format("MACHINE_VIEW_COUNT_Y");
			vt_job_info[i].machine_view_count_y = ::GetPrivateProfileInt(strSection, strKey, 1, str_file_path);

			vt_job_info[i].machine_viewer_index.assign(vt_job_info[i].num_of_camera, 0);
			for (int n = 0; n < vt_job_info[i].num_of_camera; n++)
			{
				strKey.Format("MACHINE_VIEW_INDEX%d", n + 1);
				vt_job_info[i].machine_viewer_index[n] = ::GetPrivateProfileInt(strSection, strKey, vt_job_info[i].viewer_index[n], str_file_path);
			}


			////// PLC Info
			strSection.Format("PLC_ADDR_INFO");
			strKey.Format("ADDR_READ_BIT_START");
			vt_job_info[i].plc_addr_info.read_bit_start = ::GetPrivateProfileInt(strSection, strKey, 15100, str_file_path);

			strKey.Format("ADDR_WRITE_BIT_START");
			vt_job_info[i].plc_addr_info.write_bit_start = ::GetPrivateProfileInt(strSection, strKey, 15100, str_file_path);

			strKey.Format("ADDR_READ_WORD_START");
			vt_job_info[i].plc_addr_info.read_word_start = ::GetPrivateProfileInt(strSection, strKey, 15100, str_file_path);

			strKey.Format("ADDR_WRITE_WORD_START");
			vt_job_info[i].plc_addr_info.write_word_start = ::GetPrivateProfileInt(strSection, strKey, 15100, str_file_path);

			strKey.Format("ADDR_WRITE_WORD_SUB_START");
			vt_job_info[i].plc_addr_info.write_word_sub_start = ::GetPrivateProfileInt(strSection, strKey, 80000, str_file_path);			

			strKey.Format("USE_MAIN_OBJECT_ID");
			vt_job_info[i].plc_addr_info.use_main_object_id = ::GetPrivateProfileInt(strSection, strKey, 0, str_file_path);

			strKey.Format("ADDR_MAIN_OBJECT_ID_START");
			vt_job_info[i].plc_addr_info.read_main_object_id_start = ::GetPrivateProfileInt(strSection, strKey, 15100, str_file_path);

			strKey.Format("USE_SUB_OBJECT_ID");
			vt_job_info[i].plc_addr_info.use_sub_object_id = ::GetPrivateProfileInt(strSection, strKey, 0, str_file_path);

			strKey.Format("ADDR_SUB_OBJECT_ID_START");
			vt_job_info[i].plc_addr_info.read_sub_object_id_start = ::GetPrivateProfileInt(strSection, strKey, 15100, str_file_path);

			////// Light Info
			strSection.Format("LIGHT_INFO");
			value = vt_job_info[i].num_of_camera;
			vt_job_info[i].light_info.assign(value, temp_light_info);

			for (int n = 0; n < vt_job_info[i].light_info.size(); n++)
			{
				strKey.Format("NUM_OF_USING_LIGHT%d", n + 1);
				vt_job_info[i].light_info[n].num_of_using_light = ::GetPrivateProfileInt(strSection, strKey, 0, str_file_path);

				for (int j = 0; j < vt_job_info[i].light_info[n].num_of_using_light; j++)
				{
					strKey.Format("LIGHT_CTRL_ID%d_%d", n + 1, j + 1);
					value = ::GetPrivateProfileInt(strSection, strKey, n, str_file_path);
					vt_job_info[i].light_info[n].controller_id.push_back(value);

					strKey.Format("LIGHT_CHANNEL_ID%d_%d", n + 1, j + 1);
					value = ::GetPrivateProfileInt(strSection, strKey, n, str_file_path);
					vt_job_info[i].light_info[n].channel_id.push_back(value);

					strKey.Format("LIGHT_CHANNEL_NAME%d_%d", n + 1, j + 1);
					strData.Format("Reserved");
					::GetPrivateProfileString(strSection, strKey, strData, szValue, MAX_PATH, str_file_path);
					vt_job_info[i].light_info[n].channel_name.push_back((LPCTSTR)szValue);
				}

				for (int j = 0; j < 4; j++)
				{
					strKey.Format("LIGHT_INDEX_NAME%d_%d", n + 1, j + 1);
					strData.Format("Reserved");
					::GetPrivateProfileString(strSection, strKey, strData, szValue, MAX_PATH, str_file_path);
					vt_job_info[i].light_info[n].index_name.push_back((LPCTSTR)szValue);
				}
			}

			////// Caliper Info
			strSection.Format("CALIPER_INFO");

			vector<vector<std::string>> temp_cal_name;

			value = vt_job_info[i].num_of_camera;
			vt_job_info[i].caliper_name.assign(value, temp_cal_name);

			for (int k = 0; k < vt_job_info[i].num_of_camera; k++)
			{
				vector<std::string> temp_pos_name;
				vt_job_info[i].caliper_name[k].assign(vt_job_info[i].num_of_position, temp_pos_name);

				for (int m = 0; m < vt_job_info[i].num_of_position; m++)
				{
					std::string temp_caliper_name;
					vt_job_info[i].caliper_name[k][m].assign(MAX_CALIPER_LINES, temp_caliper_name);

					for (int n = 0; n < MAX_CALIPER_LINES; n++)
					{
						strKey.Format("CALIPER_NAME%d_%d_%d", k + 1, m + 1, n + 1);
						strData.Format("Line %d", n + 1);
						::GetPrivateProfileString(strSection, strKey, strData, szValue, MAX_PATH, str_file_path);
						vt_job_info[i].caliper_name[k][m][n] = szValue;
					}
				}
			}
		}
	}
	else
	{
		fnSetMessage(1, "Fail to Load the Viewer ini file.");
	}
}
void CLET_AlignClientDlg::LoadPlcIni()
{
	int nRet, nRemainAddr, nRemainSize;
	CString strIniFilePath = m_strSystemDir + "PLCAddress.ini";

	nRet = ::GetPrivateProfileIntA("SET_PARAM", "START_READ_BIT_ADDRESS", 27000, strIniFilePath);
	m_nStartReadBitAddr_Org = nRet;
	m_nStartReadBitAddr = nRet - (nRet % SIZE_PLC_WORD);
	nRemainAddr = nRet % SIZE_PLC_WORD;

	nRet = ::GetPrivateProfileIntA("SET_PARAM", "SIZE_READ_BIT_ADDRESS", 500, strIniFilePath);
	nRemainSize = nRet % SIZE_PLC_WORD;
	m_nSizeReadBit = nRet / SIZE_PLC_WORD + 1 + (nRemainAddr + nRemainSize) / SIZE_PLC_WORD;
	m_nSizeReadBit_Org = nRet;

	nRet = ::GetPrivateProfileIntA("SET_PARAM", "START_WRITE_BIT_ADDRESS", 27500, strIniFilePath);
	m_nStartWriteBitAddr = nRet - (nRet % SIZE_PLC_WORD);
	m_nStartWriteBitAddr_Org = nRet;
	nRemainAddr = nRet % SIZE_PLC_WORD;

	nRet = ::GetPrivateProfileIntA("SET_PARAM", "SIZE_WRITE_BIT_ADDRESS", 500, strIniFilePath);
	nRemainSize = nRet % SIZE_PLC_WORD;
	m_nSizeWriteBit = nRet / SIZE_PLC_WORD + 1 + (nRemainAddr + nRemainSize) / SIZE_PLC_WORD;
	m_nSizeWriteBit_Org = nRet;

	m_nStartReadWordAddr = ::GetPrivateProfileIntA("SET_PARAM", "START_READ_WORD_ADDRESS", 27000, strIniFilePath);
	m_nStartWriteWordAddr = ::GetPrivateProfileIntA("SET_PARAM", "START_WRITE_WORD_ADDRESS", 27500, strIniFilePath);
	
	m_nSizeReadWord = ::GetPrivateProfileIntA("SET_PARAM", "SIZE_READ_WORD_ADDRESS", 500, strIniFilePath);
	m_nSizeWriteWord = ::GetPrivateProfileIntA("SET_PARAM", "SIZE_WRITE_WORD_ADDRESS", 500, strIniFilePath);
}
void CLET_AlignClientDlg::load_system_option()
{
	int value = 0;
	CSystemOption temp_system_option;
	TCHAR szValue[MAX_PATH] = { 0, };
	CString str_file_path, str_section, str_key;
	str_file_path.Format("%sSystemOption.ini", m_strConfigDir);

	vt_system_option.assign(vt_job_info.size(), temp_system_option);

	//ini 파일 없을시 생성.
	if (access(str_file_path, 0) != 0)
	{
		CFormSystemOptionView* pForm = (CFormSystemOptionView*)m_pForm[FORM_SYSTEM_OPTION];

		pForm->save_system_option_common_ini();
		for (int nJob = 0; nJob < vt_job_info.size(); nJob++)	pForm->save_system_option_job_ini(nJob);
	}

	// 프로그램 공통으로 쓰이는 시스템 옵션 읽기
	str_section.Format("COMMON");
	m_system_option_common.use_plc_check = GetPrivateProfileInt(str_section, "USE_PLC_CHECK", 0, str_file_path);
	m_system_option_common.use_plc_model_process = GetPrivateProfileInt(str_section, "USE_PLC_MODEL_PROCESS", 0, str_file_path);
	m_system_option_common.save_term_file_history = GetPrivateProfileInt(str_section, "SAVE_TERM_FILE_HISTORY", 30, str_file_path);
	m_system_option_common.save_term_file_excel = GetPrivateProfileInt(str_section, "SAVE_TERM_FILE_EXCEL", 30, str_file_path);
	m_system_option_common.save_term_file_image = GetPrivateProfileInt(str_section, "SAVE_TERM_FILE_IMAGE", 20, str_file_path);
	m_system_option_common.save_term_file_video = GetPrivateProfileInt(str_section, "SAVE_TERM_FILE_VIDEO", 20, str_file_path);
	m_system_option_common.cycle_time_to_delete_file_auto_mode = GetPrivateProfileInt(str_section, "CYCLE_TIME_DELETE_FILE", 600, str_file_path);

	// 잡별로 시스템 옵션 읽기
	for (int i = 0; i < vt_job_info.size(); i++)
	{
		str_section.Format("JOB%d_INFO", i + 1);

		//KMB 220924 결과이미지, 원본이미지 압축율 파라미터 분리
		//vt_system_option[i].jpg_compress_rate = ::GetPrivateProfileInt(str_section, "JPG_COMPRESS_RATE", 100, str_file_path);
		//if (vt_system_option[i].jpg_compress_rate < 10)	vt_system_option[i].jpg_compress_rate = 10;
		//if (vt_system_option[i].jpg_compress_rate > 90)	vt_system_option[i].jpg_compress_rate = 90;

		vt_system_option[i].jpg_compress_rate_Raw = ::GetPrivateProfileInt(str_section, "JPG_COMPRESS_RATE_RAW", 100, str_file_path);
		if (vt_system_option[i].jpg_compress_rate_Raw < 10)	vt_system_option[i].jpg_compress_rate_Raw = 10;
		if (vt_system_option[i].jpg_compress_rate_Raw > 90)	vt_system_option[i].jpg_compress_rate_Raw = 90;

		vt_system_option[i].jpg_compress_rate_Result = ::GetPrivateProfileInt(str_section, "JPG_COMPRESS_RATE_RESULT", 100, str_file_path);
		if (vt_system_option[i].jpg_compress_rate_Result < 10)	vt_system_option[i].jpg_compress_rate_Result = 10;
		if (vt_system_option[i].jpg_compress_rate_Result > 90)	vt_system_option[i].jpg_compress_rate_Result = 90;

		vt_system_option[i].ng_image_save = ::GetPrivateProfileInt(str_section, "NG_IMAGE_SAVE", 1, str_file_path);
		vt_system_option[i].ok_image_save = ::GetPrivateProfileInt(str_section, "OK_IMAGE_SAVE", 1, str_file_path);
		vt_system_option[i].raw_image_save = ::GetPrivateProfileInt(str_section, "RAW_IMAGE_SAVE", 1, str_file_path);
		vt_system_option[i].result_image_save = ::GetPrivateProfileInt(str_section, "RESULT_IMAGE_SAVE", 1, str_file_path);
		vt_system_option[i].use_result_image_capture = ::GetPrivateProfileInt(str_section, "USE_RESULT_IMAGE_CAPTURE", 0, str_file_path);
		vt_system_option[i].save_image_type = ::GetPrivateProfileInt(str_section, "SAVE_IMAGE_TYPE", 0, str_file_path);
		if (vt_system_option[i].save_image_type < 0)	vt_system_option[i].save_image_type = 0;
		if (vt_system_option[i].save_image_type > 1)	vt_system_option[i].save_image_type = 1;

		vt_system_option[i].use_rdp_report = ::GetPrivateProfileInt(str_section, "USE_RDP_REPORT", 0, str_file_path);
		vt_system_option[i].rdp_image_type = ::GetPrivateProfileInt(str_section, "RDP_IMAGE_TYPE", 0, str_file_path);

		::GetPrivateProfileStringA(str_section, "REPLACEMENT_DATA", "-9999", szValue, MAX_PATH, str_file_path);
		vt_system_option[i].replacement_data = float(atof(szValue));

		vt_system_option[i].use_light_on_off_system = ::GetPrivateProfileInt(str_section, "USE_LIGHT_ON_OFF_SYSTEM", 0, str_file_path);
		vt_system_option[i].show_calib_direction = ::GetPrivateProfileInt(str_section, "SHOW_CALIB_DIRECTION", 0, str_file_path);

		if (vt_job_info[i].algo_method == CLIENT_TYPE_ELB_CENTER_ALIGN)
		{
			vt_system_option[i].stELB.Align_DebuggingImage_Save = ::GetPrivateProfileInt(str_section, "USE_ALIGN_DEBUGGING_SAVE", 0, str_file_path);
			vt_system_option[i].stELB.Trace_DebuggingImage_Save = ::GetPrivateProfileInt(str_section, "USE_TRACE_DEBUGGING_SAVE", 0, str_file_path);
			vt_system_option[i].stELB.Inspection_DebuggingImage_Save = ::GetPrivateProfileInt(str_section, "USE_INSPECTION_DEBUGGING_SAVE", 0, str_file_path);
			
			TCHAR cData[MAX_PATH];
			CString strKey;
			strKey.Format("AUTO_VIDEO_SAVE_TIME");
			::GetPrivateProfileStringA(str_section, strKey, "4.5", cData, MAX_PATH, str_file_path);
			vt_system_option[i].stELB.Auto_Save_Video_Time = atof(cData); // s(second)
		}
	}
}

void CLET_AlignClientDlg::hideForm()
{
	for (int i = 0; i < MAX_FORM; i++)	m_pForm[i]->ShowWindow(SW_HIDE);
}
void CLET_AlignClientDlg::hidePane()
{
	for (int i = 0; i < MAX_PANE; i++)	m_pPane[i]->ShowWindow(SW_HIDE);
}

int CLET_AlignClientDlg::changeForm(int nID)
{
	if (m_nCurForm == nID) return m_nCurForm;

	hideForm();
	m_pForm[nID]->ShowWindow(SW_SHOW);

	m_nOldForm = nID;
	m_nCurForm = nID;

	// KBJ 2022-03-16 SetInspPara VIew into the Model View
	CFormModelView* pModelView = (CFormModelView*)m_pForm[FORM_MODEL];
	pModelView->c_TabModelPage[pModelView->m_nJobID]->m_pInspectionDlg->ShowWindow(SW_HIDE);

	switch (nID) {
	case FORM_MAIN:
	{
		CFormMainView* pView = (CFormMainView*)m_pForm[nID];
	}
	break;
	case FORM_MODEL:
	{
		CFormModelView * pView = (CFormModelView *)m_pForm[nID];
		pView->enableEditControls(FALSE);
		pView->updateAlignInfoData();

		// KBJ 2022-09-16
		int index = pView->m_hSelectAlgoTab.GetCurSel();
		pView->c_TabModelPage[index]->m_pInspectionDlg->EnableWindow(false);

		// KBJ 2022-03-16 SetInspPara VIew into the Model View
		if( pView->c_TabModelPage[pView->m_nJobID]->m_pInspectionDlg->bUse ==TRUE)
			pView->c_TabModelPage[pView->m_nJobID]->m_pInspectionDlg->ShowWindow(SW_SHOW);
	}
	break;
	case FORM_CAMERA:
	{
		CFormCameraView *pView = (CFormCameraView *)m_pForm[nID];
		pView->updateFrame();
	}
	break;
	case FORM_MACHINE:
	{
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
#ifdef _DAHUHA
			if (m_pDahuhaCam[nCam].isconnected() && !m_pDahuhaCam[nCam].isgrabbing())		m_pDahuhaCam[nCam].grabStart();
#else
			if (m_pBaslerCam[nCam] && m_pBaslerCam[nCam]->IsGrabContinuous() != TRUE)
				m_pBaslerCam[nCam]->GrabContinuous(TRUE);
#endif
		}

		((CFormMachineView *)m_pForm[nID])->updateFrameDialog();
		::SendMessageA(m_pForm[FORM_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_CALIBRATION_AREA_VIEW, 0);
		//KJH 2022-06-30 Machine창 Origin Box Display 삭제
		//::SendMessageA(m_pForm[FORM_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_TRAGER_VIEW, NULL);
		CFormMachineView* pMachineView = (CFormMachineView*)m_pForm[FORM_MACHINE];
		draw_calib_direction(pMachineView->m_nSelectAlgorithm, FORM_MACHINE);
	}
	break;
	case FORM_TREND:
	{
		CFormTrendView* pView = (CFormTrendView*)m_pForm[nID];
		pView->updateFrame(true);
		pView->updateDataBase();
	}
	break;
	}

	return m_nCurForm;
}
int CLET_AlignClientDlg::changePane(int nID)
{
	if (m_nCurPane == nID) return m_nCurPane;

	switch (m_nOldPane) {
	case PANE_CAMERA:
	{
		if (m_pDlgCaliper->IsWindowVisible())
		{
			m_pDlgCaliper->ShowWindow(SW_HIDE);
		}
	}
	break;
	}

	hidePane();
	m_pPane[nID]->ShowWindow(SW_SHOW);

	m_nCurPane = nID;
	m_nOldPane = nID;

	switch (nID) {
	case PANE_CAMERA:
	{
		((CPaneCamera*)m_pPane[nID])->UpdateFrameDlg();
	}
	break;
	case PANE_MACHINE:
	{
		CPaneMachine* pMachine = ((CPaneMachine*)m_pPane[nID]);
		int nAlgo = pMachine->m_hSelectAlgoTab.GetCurSel();
		pMachine->c_TabMachinePage[nAlgo]->updateResultDialog();
	}
	break;
	}
	return m_nCurPane;
}
int CLET_AlignClientDlg::changeBottomPane(int nID)
{
	if (m_nCur_B_Pane == nID) return m_nCur_B_Pane;

	for (int i = 0; i < MAX_B_PANE; i++)	m_pPaneBottom[i]->ShowWindow(SW_HIDE);

	m_pPaneBottom[nID]->ShowWindow(SW_SHOW);

	m_nCur_B_Pane = nID;
	m_nOld_B_Pane = nID;

	return m_nCur_B_Pane;
}

void CLET_AlignClientDlg::OnTimer(UINT_PTR nIDEvent)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	switch (nIDEvent)
	{
	case TIMER_MOVE_CALIB_POS:
	{
		KillTimer(TIMER_MOVE_CALIB_POS);

		if (seqSendCalibData() == 0)			SetTimer(TIMER_MOVE_CALIB_POS, 1, NULL);
		else
		{
			//g_CommPLC.SetBit(addr_wb_curr_calib_start + 6, FALSE);
			g_CommPLC.SetBit(addr_wb_curr_calib_start + 7, FALSE);
		}
	}
	break;  
	case TIMER_MOVE_CALIB_ACK_POS:
	{
		KillTimer(TIMER_MOVE_CALIB_ACK_POS);

		if (seqSendCalibAckData() == 0)			SetTimer(TIMER_MOVE_CALIB_ACK_POS, 1, NULL);
	}
	break;
	case TIMER_SERVER_CHECK:
	{
		if (m_bProgramEnd != TRUE)
		{
			KillTimer(TIMER_SERVER_CHECK);
			if (m_bConnectServer != TRUE)
				initSocket();
		}
	}
	break;
	case TIMER_PLC_CONNECT:		// PLC 통신 연결 체크
	{
		KillTimer(TIMER_PLC_CONNECT);

		if (getPLCConnect() != TRUE)
		{
#ifndef _USE_MC_PROTOCOL_
			if (g_CommPLC.Init(0, 1))
			{
				setPLCConnect();
				::SendMessage(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_THREAD_CREATE, TRUE);
				::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_HB_CONNECT_PLC, MAKELPARAM(0, TRUE));
				KillTimer(TIMER_PLC_ALIVE_PING_PONG);
				SetTimer(TIMER_PLC_ALIVE_PING_PONG, 1000, NULL);
			}
			else
			{
				char cData[MAX_PATH] = "PLC Disconnect!!";
				::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_HB_CONNECT_PLC, MAKELPARAM(0, FALSE));
				SetTimer(TIMER_PLC_CONNECT, 5000, NULL);

				m_bThreadPLCSignalCheckEnd = TRUE;
			}
#else
			g_CommPLC_MC.setMsgHwnd(this->m_hWnd);
			g_CommPLC_MC.m_pMain = this;
			CString strSocket;
			strSocket.Format("%d", m_nSockPlcPort);
			BOOL bret = g_CommPLC_MC.Connect(m_strPlcIP, strSocket);
			KillTimer(TIMER_PLC_ALIVE_PING_PONG);
			SetTimer(TIMER_PLC_ALIVE_PING_PONG, 1000, NULL);
#endif
		}
	}
	break;
	case TIMER_PLC_ALIVE_PING_PONG:
	{
		//HTK 2022-07-11 Alive Ping Pong 관련 인터페이스 수정
		if (getPLCConnect())
		{
			g_CommPLC.SetBit(m_nStartWriteBitAddr_Org, m_bPlcAlive);
			m_bPlcAlive = !m_bPlcAlive;
		}
	}
	break;
	case TIMER_PLC_ALIVE_CHECK:
	{
		KillTimer(TIMER_PLC_ALIVE_CHECK);
		BOOL bAlive = g_CommPLC.GetBit(m_nStartReadBitAddr_Org);

		if (bAlive != m_nPLCAlive)		m_nPLCAliveCount = 0;
		else							m_nPLCAliveCount++;

		m_nPLCAlive = bAlive;

		if (m_nPLCAliveCount > 500)
		{
			resetPLCConnect();
			BOOL bAlive = TRUE;
			Delay(1000);
			if (m_bThreadPLCSignalCheckEnd != TRUE)			bAlive = FALSE;
			
			if (bAlive)
			{
				m_nPLCAliveCount = 0;
				g_CommPLC.m_bOpened = FALSE;
				g_CommPLC.Close();
				g_CommPLC_MC.CloseSockets();
				//theLog.logmsg(LOG_ERROR, "PLC Disconnect!!!!");
				CString str_temp = "PLC Disconnect!!!!";
				::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str_temp);

				::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_HB_CONNECT_PLC, MAKELPARAM(0, FALSE));
				SetTimer(TIMER_PLC_CONNECT, 1000, NULL);
			}
		}

		if (m_bProgramEnd != TRUE) SetTimer(TIMER_PLC_ALIVE_CHECK, 400, NULL);
	}
	break;
	case TIMER_IMAGE_SAVE:
	{
		KillTimer(TIMER_IMAGE_SAVE);

		for (int nJob = 0; nJob < vt_job_info.size(); nJob++)
		{
			for (int nCam = 0; nCam < vt_job_info[nJob].num_of_camera; nCam++)
			{
				if (m_nSaveImageRingBufIndex[nJob][nCam] != m_nSaveImageRingBufIndex_Curr[nJob][nCam])
				{
					saveImageFiles(nJob, nCam);
					m_nSaveImageRingBufIndex_Curr[nJob][nCam]++;
					m_nSaveImageRingBufIndex_Curr[nJob][nCam] = m_nSaveImageRingBufIndex_Curr[nJob][nCam] % MAX_SAVE_IMAGE_RING_BUF;
				}
			}
		}

		BOOL bFind = FALSE;
		for (int nJob = 0; nJob < vt_job_info.size(); nJob++)
		{
			for (int nCam = 0; nCam < vt_job_info[nJob].num_of_camera; nCam++)
			{
				if (m_nSaveImageRingBufIndex[nJob][nCam] != m_nSaveImageRingBufIndex_Curr[nJob][nCam])
				{
					bFind = TRUE;
				}
			}
		}

		if (bFind)	SetTimer(TIMER_IMAGE_SAVE, 1, NULL);
		else        SetTimer(TIMER_IMAGE_SAVE, 500, NULL);
	}
	break;
	case TIMER_CLEANING_LIVE_MODE : //hsj 2022-09-20 cleaning live bit 추가
	{
		KillTimer(TIMER_CLEANING_LIVE_MODE);
		CFormMainView* pView = (CFormMainView*)m_pForm[FORM_MAIN];
		int viewer = vt_job_info[3].viewer_index[0];

		int PLC_RB_CLEANING_LIVE_REQ = vt_job_info[0].plc_addr_info.read_bit_start + 18; //hsj 2022-09-20 cleanning camera live로

		if (g_CommPLC.GetBit(PLC_RB_CLEANING_LIVE_REQ) && m_bCleaningLive == FALSE)
		{
			pView->m_pDlgViewerMain[viewer]->m_bLiveCheck = FALSE;
			m_bCleaningLive = TRUE;
			pView->m_pDlgViewerMain[viewer]->OnCommandLive();
		}
		else if (!g_CommPLC.GetBit(PLC_RB_CLEANING_LIVE_REQ) && m_bCleaningLive == TRUE)
		{
			pView->m_pDlgViewerMain[viewer]->m_bLiveCheck = TRUE;
			m_bCleaningLive = FALSE;
			pView->m_pDlgViewerMain[viewer]->OnCommandStop();
		}

		SetTimer(TIMER_CLEANING_LIVE_MODE, 1000, NULL);
	}
	break;
	
	}

	CDialogEx::OnTimer(nIDEvent);
}
BOOL CLET_AlignClientDlg::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->wParam == VK_RETURN || pMsg->wParam == VK_ESCAPE || pMsg->message == WM_SYSKEYDOWN)		return TRUE; //

	return CDialogEx::PreTranslateMessage(pMsg);
}
LRESULT CLET_AlignClientDlg::OnViewControl(WPARAM wParam, LPARAM lParam)
{
	LRESULT lRet = 0;
	CString str;

	switch ((int)wParam) {
	case MSG_MD_CAMERA_LIVE:
	{
		int nCam = (int)lParam;
#ifdef _DAHUHA
		if (m_pDahuhaCam[nCam].isconnected() && !m_pDahuhaCam[nCam].isgrabbing())		m_pDahuhaCam[nCam].grabStart();
#else
		if (m_pBaslerCam[nCam] && m_pBaslerCam[nCam]->IsGrabbing() != TRUE)	m_pBaslerCam[nCam]->GrabContinuous(TRUE);
#endif
		else if (m_pSaperaCam[nCam].IsOpend()) m_pSaperaCam[nCam].grab(-1);
	}
	break;
	case MSG_MD_CAMERA_STOP:
	{
		int nCam = (int)lParam;
#ifdef _DAHUHA
		if (m_pDahuhaCam[nCam].isconnected() && m_pDahuhaCam[nCam].isgrabbing())		m_pDahuhaCam[nCam].grabStop();
#else
		if (m_pBaslerCam[nCam] && m_pBaslerCam[nCam]->IsGrabbing())	m_pBaslerCam[nCam]->GrabContinuous(FALSE);
#endif
		else if (m_pSaperaCam[nCam].IsOpend()) m_pSaperaCam[nCam].stop();
	}
	break;
	case MSG_MD_CAMERA_SINGLE_FRAME:
	{
		int nCam = (int)lParam;
#ifdef _DAHUHA
		if (m_pDahuhaCam[nCam].isconnected())	m_pDahuhaCam[nCam].grabSingle();
#else
		if (m_pBaslerCam[nCam])	m_pBaslerCam[nCam]->SingleGrab();
#endif
		else if (m_pSaperaCam[nCam].IsOpend()) m_pSaperaCam[nCam].grab(1);
	}
	break;
	case MSG_MD_ANALYSIS_PACKET:
	{
		AnalysisCommand((pToPacketData)lParam);
	}
	break;
	case MSG_MD_INC_COUNT:
	{
		BOOL bJudge = (BOOL)lParam;
		m_InspCounter.Inc1stTodayTotalCount(bJudge);
	}
	break;
	case MSG_MD_GRAB_THREAD:
		if(m_pSaperaCam[int(lParam)].IsOpend())
			AfxBeginThread(Thread_ImageGrabSapera, &m_pSaperaCam[int(lParam)], THREAD_PRIORITY_NORMAL);
		else
		{
#ifdef _DAHUHA
			if (m_pDahuhaCam[int(lParam)].isconnected())
				AfxBeginThread(Thread_ImageGrab, &m_pDahuhaCam[int(lParam)], THREAD_PRIORITY_NORMAL);
#else			
			AfxBeginThread(Thread_ImageGrab, m_pBaslerCam[int(lParam)], THREAD_PRIORITY_NORMAL);
#endif
		}
		break;
	case MSG_PLC_CONNECT_STATUS:
		::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_PLC_CONNECT_STATUS, MAKELPARAM(0, FALSE));
		resetPLCConnect();
		break;
	case MSG_PLC_CONNECT_STATUS_CONNECT:
		theLog.logmsg(LOG_ERROR, "PLC Reconnect!!!!");
		::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_PLC_CONNECT_STATUS, MAKELPARAM(0, TRUE));
		setPLCConnect();
		::SendMessage(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_THREAD_CREATE, TRUE);
		break;
	case MSG_MD_CAMERA_MULTI_FRAME:
	{
		int nCam = LOWORD(lParam);
		int nFrame = HIWORD(lParam);
		CString str;
		if (m_pSaperaCam[nCam].IsOpend())
		{
			str.Format("[Cam %d] Frame Count : %d", nCam, nFrame);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			m_pSaperaCam[nCam].grab(nFrame);
		}
		else
		{
			str.Format("MULTI GRAB NG");
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	break;
	case MSG_MD_DIFF_RESULT_WRITE:
	{
		int nJob = LOWORD(lParam);
		int bJudge = HIWORD(lParam);

		m_pPattern[0].pDlg = this;
		m_pPattern[0].nJob = nJob;
		m_pPattern[0].nSearchCount = bJudge;
		AfxBeginThread(Thread_DiffResultWrite, &m_pPattern[0]);
	}
	break;
	default:
		break;
	}

	return lRet;
}
void CLET_AlignClientDlg::CompareMemoryAddr()
{
	if (m_bProgramEnd) return;

	CFormPlcShareMemoryView* pView = (CFormPlcShareMemoryView *)m_pForm[FORM_INTERFACE];

	if (m_nCurForm != FORM_INTERFACE)	return;

	//g_CommPLC.GetTotalBitData(getStartWriteBitAddr(), getSizeWriteBit(), m_nBitWriteData);
	g_CommPLC.GetTotalWriteBitData(getStartWriteBitAddr(), getSizeWriteBit(), m_nBitWriteData);	// 19.10.26 Write Bit 영역 L->M

	long bitarray;
	int f = 0, s = 0;

	int r_offset = m_nStartReadBitAddr_Org - getStartReadBitAddr();
	int w_offset = m_nStartWriteBitAddr_Org - getStartWriteBitAddr();

		if (m_bInitCheck)
		{
			// nSize == 440;
			// nRange = 27; -> 28

			int nRange = (MAX_ADDR_UNIT * PLC_UNIT_ADDRESS_SIZE + (PLC_UNIT_ADDRESS_SIZE - 1)) / SIZE_PLC_WORD;
			for (int i = 0; i < nRange; i++)
			{
				// 16 * 22
				// 352
				// 20
				// 22
				// 440

				bitarray = m_nBitData[i];	// 500
				for (int j = 0; j < SIZE_PLC_WORD; j++)
				{
					if (i == 0 && r_offset > j) continue;
					pView->m_nPcFromPlcBitStatus[f][s] = bitarray >> j & 0x1;
					s++;

					//if(s >= 10) {s = 0; f++;}
					if (s >= PLC_UNIT_ADDRESS_SIZE) { s = 0; f++; }
					if (f >= MAX_ADDR_UNIT) break;
				}
				if (f >= MAX_ADDR_UNIT) break;
			}


			f = 0, s = 0;

			// 14992	m_nBitWriteData[i] 
			// 15000 보여줘야 됨.
			memset(pView->m_nPlcFromPcBitStatus, 0, sizeof(pView->m_nPlcFromPcBitStatus));
			for (int i = 0; i < nRange; i++)
			{
				bitarray = m_nBitWriteData[i];

				// 149992

				for (int j = 0; j < SIZE_PLC_WORD; j++)
				{
					if (i == 0 && w_offset > j) continue;
					pView->m_nPlcFromPcBitStatus[f][s] = bitarray >> j & 0x1;
					s++;

					if (s >= PLC_UNIT_ADDRESS_SIZE)
					{
						s = 0;	f++;
						if (f == 12)
							int a = 5;
					}
					if (f >= MAX_ADDR_UNIT) break;
				}
				if (f >= MAX_ADDR_UNIT) break;
			}
		}

		memcpy(m_nBitPreData, m_nBitData, sizeof(long) * getSizeReadBit());
		memcpy(m_nBitWritePreData, m_nBitWriteData, sizeof(long) * getSizeWriteBit());
		m_bInitCheck = TRUE;
}

int CLET_AlignClientDlg::seqSendCalibData()
{
	int nRet = 0;
	int algo = ((CPaneMachine*)m_pPane[PANE_MACHINE])->getCurrentMachineAlgorithm();

	switch (m_nSeqSecCalibData) {
	case 0:
		break;
	case 100:			// 보정량 전송		// m_dbRevisionData와 PLC_WD_PRS1_REVISIONX를 클라이언트 별로 분리 시켜야 함
	{
		long lRevisionData[6] = { 0, };
		lRevisionData[0] = LOWORD(m_dbRevisionData[algo][0] * MOTOR_SCALE);
		lRevisionData[1] = HIWORD(m_dbRevisionData[algo][0] * MOTOR_SCALE);
		lRevisionData[2] = LOWORD(m_dbRevisionData[algo][1] * MOTOR_SCALE);
		lRevisionData[3] = HIWORD(m_dbRevisionData[algo][1] * MOTOR_SCALE);
		lRevisionData[4] = LOWORD(m_dbRevisionData[algo][2] * MOTOR_SCALE);
		lRevisionData[5] = HIWORD(m_dbRevisionData[algo][2] * MOTOR_SCALE);

		g_CommPLC.SetWord(addr_wd_curr_calib_data, 6, lRevisionData);
		g_CommPLC.SetBit(addr_wb_curr_calib_start + 6, TRUE);
		m_nSeqSecCalibData = 150;
	}
	break;
	case 150:
	{
		BOOL bCalibrationModeOnAck = FALSE;
		bCalibrationModeOnAck = g_CommPLC.GetBit(addr_rb_curr_calib_start + 6);

		if (bCalibrationModeOnAck)	m_nSeqSecCalibData = 200;
		else						m_nSeqSecCalibData = 150;
	}
	break;
	case 200:		// 보정 요청

		g_CommPLC.SetBit(addr_wb_curr_calib_start + 7, TRUE);

		m_nSeqSecCalibData = 300;
		break;
	case 300:		// 이동 완료 체크
		BOOL bRet;

		bRet = g_CommPLC.GetBit(addr_rb_curr_calib_start + 7);

		if (++count_calib_time_out > 300000)
		{
			if (m_nCurForm == FORM_MACHINE)
			{
				CString strTemp;
				strTemp = "MOVE NG";
				::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
			}
			g_CommPLC.SetBit(addr_wb_curr_calib_start + 7, FALSE);
			nRet = 2;
			break;
		}

		if (bRet == 0)	break;

		m_nCalibRevisionAck = 1;

		if (m_nCurForm == FORM_MACHINE)
		{
			CString strTemp;
			strTemp = "MOVE OK";
			::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
		}

		nRet = 1;
		m_nSeqSecCalibData = 0;
		break;
	}

	return nRet;
}
int CLET_AlignClientDlg::seqSendCalibAckData()
{
	int nRet = 0;

	switch (m_nSeqSecCalibData) {
		case 0:		break;
		case 100:
		{
			BOOL bRet;
			bRet = g_CommPLC.GetBit(addr_rb_curr_calib_start + 6);

			if (++count_calib_time_out > 30000)
			{
				if (m_nCurForm == FORM_MACHINE)
				{
					CString strTemp;
					strTemp = "MOVE NG";
					::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
				}
				nRet = 2;
				break;
			}

			if (bRet == 0)	break;

			m_nCalibrationModeOnAck = 1;

			if (m_nCurForm == FORM_MACHINE)
			{
				CString strTemp;
				strTemp = "MOVE ACK OK";
				::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
			}

			nRet = 1;
			m_nSeqSecCalibData = 0;
			break;
		}
	}
	return nRet;
}

void CLET_AlignClientDlg::SendServer(int cmd, int nParam1, int nParam2, void *pData)
{
	BOOL bEnable;

	switch (cmd) {
	case TCP_SEND_ALIGN_L_CHECK_NG:
	{
		g_CommPLC.SetBit(m_nAlignLcheckNgWrite[nParam1], TRUE);
	}
	break;
	case TCP_SEND_CALIBRATION_REQUEST: //20001
	{
		bEnable = g_CommPLC.GetBit(nParam1);
		if(bEnable) m_nCalibrationAck = 1;
		else		m_nCalibrationAck = 2;
	}
	break;
	case TCP_SEND_CSCAM_REVISION_DATA:
	{
		count_calib_time_out = 0;
		m_nSeqSecCalibData = 100;
		addr_wb_curr_calib_start = nParam1;
		addr_wd_curr_calib_data = nParam2;
		memcpy(&addr_rb_curr_calib_start, pData, sizeof(int));
		SetTimer(TIMER_MOVE_CALIB_POS, 1, NULL);
	}
	break;
	case TCP_SEND_CSCAM_CALIB_DATA:
		count_calib_time_out = 0;
		m_nSeqSecCalibData = 100;
		addr_wb_curr_calib_start = nParam1;
		addr_wd_curr_calib_data = nParam2;
		memcpy(&addr_rb_curr_calib_start, pData, sizeof(int));
		SetTimer(TIMER_MOVE_CALIB_POS, 1, NULL);
		break;
	case TCP_SEND_CALIB_END:
	{
		g_CommPLC.SetBit(nParam1, nParam2); 
	}
	break;
	case TCP_SEND_CSCAM_CALIB_ON:
	{
		g_CommPLC.SetBit(nParam1, nParam2);
	}
	break;
	case TCP_SEND_ROTATE_CENTER:
	{
		long sendRotateCenter[4] = { 0, };
		memcpy(sendRotateCenter, pData, sizeof(long) * 4);
		g_CommPLC.SetWord(nParam1, 4, sendRotateCenter);
	}
	break;	
	case TCP_SEND_CALIBRATION_MODE_ON_ACK:
	{
		count_calib_time_out = 0;
		m_nSeqSecCalibData = 100;
		memcpy(&addr_rb_curr_calib_start, pData, sizeof(int));
		SetTimer(TIMER_MOVE_CALIB_ACK_POS, 1, NULL);
	}
	break;
	}
}

void CLET_AlignClientDlg::readLightCtrlInfo(struct stLIGHTCTRLINFO *pInfo)
{
	TCHAR szValue[MAX_PATH] = { 0, };
	CString  strValue, strKey, strSection, strData;

	strSection = "LIGHT_CTRL_INFO";
	strKey.Format("NUM_OF_LIGHT_CTRL");
	pInfo->nNumOfLightCtrl = m_iniFile.GetProfileIntA(strSection, strKey, 0);

	for (int i = 0; i < MAX_LIGHT_CTRL; i++)
	{
		strKey.Format("TYPE%d", i + 1);
		pInfo->nType[i] = m_iniFile.GetProfileIntA(strSection, strKey, 0);

		strKey.Format("PORT%d", i + 1);
		pInfo->nPort[i] = m_iniFile.GetProfileIntA(strSection, strKey, 0);

		strKey.Format("BAUDRATE%d", i + 1);
		pInfo->nBaudrate[i] = m_iniFile.GetProfileIntA(strSection, strKey, 9600);

		strKey.Format("SOCK_PORT%d", i + 1);
		pInfo->nSockPort[i] = m_iniFile.GetProfileIntA(strSection, strKey, 0);

		strKey.Format("SOCK_IP%d", i + 1);
		strData.Format("192.168.0.%d", 50 + i);
		m_iniFile.GetProfileStringA(strSection, strKey, strData, szValue, MAX_PATH);
		sprintf(pInfo->cSockIP[i], "%s", szValue);

		strKey.Format("NAME%d", i + 1);
		strData.Format("LIGHT%d", i + 1);
		m_iniFile.GetProfileStringA(strSection, strKey, strData, szValue, MAX_PATH);
		sprintf(pInfo->cName[i], "%s", szValue);
	}
}
BOOL CLET_AlignClientDlg::readGlassInfoData(CGlassInfo *glassInfo, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		CString strData;
		CString strModelFilePath = strModelPath + "\\GlassInfo.ini";
		TCHAR cData[MAX_PATH];

		CFileFind findFile;
		if (findFile.FindFile(strModelFilePath) != TRUE)	return bSuccess;

		::GetPrivateProfileStringA("GLASS_INFO", "GLASS_WIDTH", "60.0", cData, MAX_PATH, strModelFilePath);
		glassInfo->setGlassWidth(atof(cData));

		::GetPrivateProfileStringA("GLASS_INFO", "GLASS_HEIGHT", "100.0", cData, MAX_PATH, strModelFilePath);
		glassInfo->setGlassHeight(atof(cData));

		::GetPrivateProfileStringA("GLASS_INFO", "FRAME_WIDTH", "1438.0", cData, MAX_PATH, strModelFilePath);
		glassInfo->setFrameWidth(atof(cData));
        if(glassInfo->getFrameWidth()<0 || glassInfo->getFrameWidth()>10000) glassInfo->setFrameWidth(100.);
		::GetPrivateProfileStringA("GLASS_INFO", "FRAME_HEIGHT", "813.0", cData, MAX_PATH, strModelFilePath);
		glassInfo->setFrameHeight(atof(cData));
		if (glassInfo->getFrameHeight() < 0 || glassInfo->getFrameHeight() > 10000) glassInfo->setFrameHeight(100.);

		::GetPrivateProfileStringA("GLASS_INFO", "PANEL_TYPE", "0", cData, MAX_PATH, strModelFilePath);
		glassInfo->setModelPanelType(atoi(cData));		

		::GetPrivateProfileStringA("GLASS_INFO", "GLASS_INCH", "5.5", cData, MAX_PATH, strModelFilePath);
		glassInfo->setInch(atof(cData));

		::GetPrivateProfileStringA("GLASS_INFO", "TAB_WIDTH", "50.0", cData, MAX_PATH, strModelFilePath);
		glassInfo->setTabWidth(atof(cData));

		::GetPrivateProfileStringA("GLASS_INFO", "TAB_HEIGHT", "20.0", cData, MAX_PATH, strModelFilePath);
		glassInfo->setTabHeight(atof(cData));

		::GetPrivateProfileStringA("GLASS_INFO", "PANEL_ROW_COUNT", "3", cData, MAX_PATH, strModelFilePath);
		glassInfo->setPanelRowCount(atoi(cData));

		::GetPrivateProfileStringA("GLASS_INFO", "PANEL_COLUMN_COUNT", "2", cData, MAX_PATH, strModelFilePath);
		glassInfo->setPanelColumnCount(atoi(cData));

		::GetPrivateProfileStringA("GLASS_INFO", "PANEL_TRAYIN_COUNT", "1", cData, MAX_PATH, strModelFilePath);
		glassInfo->setPanelCountInTray(atoi(cData));
	}
	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}
BOOL CLET_AlignClientDlg::saveGlassInfoData(CGlassInfo *glassInfo, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		CString strData;
		CString strModelFilePath = strModelPath + "\\GlassInfo.ini";

		strData.Format("%.3f", glassInfo->getGlassWidth());
		::WritePrivateProfileStringA("GLASS_INFO", "GLASS_WIDTH", strData, strModelFilePath);

		strData.Format("%.3f", glassInfo->getGlassHeight());
		::WritePrivateProfileStringA("GLASS_INFO", "GLASS_HEIGHT", strData, strModelFilePath);

		strData.Format("%.3f", glassInfo->getFrameWidth());
		::WritePrivateProfileStringA("GLASS_INFO", "FRAME_WIDTH", strData, strModelFilePath);

		strData.Format("%.3f", glassInfo->getFrameHeight());
		::WritePrivateProfileStringA("GLASS_INFO", "FRAME_HEIGHT", strData, strModelFilePath);

		strData.Format("%d", glassInfo->getModelPanelType());
		::WritePrivateProfileStringA("GLASS_INFO", "PANEL_TYPE", strData, strModelFilePath);		

		strData.Format("%.3f", glassInfo->getInch());
		::WritePrivateProfileStringA("GLASS_INFO", "GLASS_INCH", strData, strModelFilePath);

		strData.Format("%.3f", glassInfo->getTabWidth());
		::WritePrivateProfileStringA("GLASS_INFO", "TAB_WIDTH", strData, strModelFilePath);

		strData.Format("%.3f", glassInfo->getTabHeight());
		::WritePrivateProfileStringA("GLASS_INFO", "TAB_HEIGHT", strData, strModelFilePath);

		strData.Format("%d", glassInfo->getPanelRowCount());
		::WritePrivateProfileStringA("GLASS_INFO", "PANEL_ROW_COUNT", strData, strModelFilePath);

		strData.Format("%d", glassInfo->getPanelColumnCount());
		::WritePrivateProfileStringA("GLASS_INFO", "PANEL_COLUMN_COUNT", strData, strModelFilePath);

		strData.Format("%d", glassInfo->getPanelCountInTray());
		::WritePrivateProfileStringA("GLASS_INFO", "PANEL_TRAYIN_COUNT", strData, strModelFilePath);

	}
	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}
BOOL CLET_AlignClientDlg::readLightInfoData(int algo, CLightInfo *lightInfo, CString strModelPath)
{
	TCHAR cData[MAX_PATH];
	CRect rect;
	CString strData, strKey;
	CString strModelFilePath = strModelPath + "\\LightInfo.ini";

	CFileFind findFile;

	for (int nCam = 0; nCam < vt_job_info[algo].num_of_camera; nCam++)
	{
		for (int light = 0; light < MAX_LIGHT_PER_CAMERA; light++)
		{
			for (int nIndex = 0; nIndex < 4; nIndex++)
			{
				strKey.Format("LIGHT_BRIGHT_%d_%d_%d", nCam + 1, light + 1, nIndex + 1);
				::GetPrivateProfileStringA("LIGHT_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				lightInfo->setLightBright(nCam, light, nIndex, atoi(cData));
				lightInfo->setLightBrightRestore(nCam, light, nIndex, atoi(cData));		// dh.jung 2021-05-26 add restore light bright
			}
		}
	}

	return TRUE;
}
BOOL CLET_AlignClientDlg::readMachineInfoData(int algo, CMachineInfo *machineInfo, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		TCHAR cData[MAX_PATH];
		CRect rect;
		CString strData, strKey;
		CString strModelFilePath = strModelPath + "\\MachineInfo.ini";

		CFileFind findFile;
		if (findFile.FindFile(strModelFilePath) != TRUE)	return bSuccess;

		//for (int nCam = 0; nCam < m_nNumCamera; nCam++)
		for(int nCam = 0; nCam < vt_job_info[algo].num_of_camera; nCam++)
		{
			int real_cam = vt_job_info[algo].camera_index[nCam];

			for (int nPos = 0; nPos < vt_job_info[algo].num_of_position; nPos++)
			{
				strKey.Format("ROTATE_X%d_%d", nCam + 1, nPos + 1);
				//strKey.Format("ROTATE_X%d", nPos + 1);
				::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				machineInfo->setRotateCenterX(nCam, nPos, atof(cData));

				strKey.Format("ROTATE_Y%d_%d", nCam + 1, nPos + 1);
				//strKey.Format("ROTATE_Y%d", nPos + 1);
				::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				machineInfo->setRotateCenterY(nCam, nPos, atof(cData));


				for (int nIndex = 0; nIndex < 2; nIndex++)
				{
					strKey.Format("INSP_OFFSET%d%d%d", nCam + 1, nPos + 1, nIndex + 1);
					::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
					machineInfo->set_insp_offset(nCam, nPos, nIndex, atof(cData));
				}
			}
			

			strKey.Format("GAIN%d", nCam + 1);
			::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
			machineInfo->setGain(nCam, atoi(cData));

			strKey.Format("ALIGN_ORGIN_POS%d", nCam + 1);
			::GetPrivateProfileStringA("MACHINE_INFO", strKey, "4", cData, MAX_PATH, strModelFilePath);
			machineInfo->setAlignOrginPos(nCam, atoi(cData));

			strKey.Format("EXPOSURE_TIME%d", nCam + 1);
			::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
			machineInfo->setExposureTime(real_cam, atoi(cData));
		}

		for (int nPos = 0; nPos < NUM_POS; nPos++)
		{
			strKey.Format("LCHECK_OFFSET%d", nPos + 1);
			::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
			machineInfo->set_lcheck_offset(nPos, atof(cData));
		}

		strKey.Format("ALIGNMENT_TYPE");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setAlignmentType(atoi(cData));

		strKey.Format("PREALIGN_OFFSET_X");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setPrealignOffSet(AXIS_X, atof(cData));

		strKey.Format("PREALIGN_OFFSET_Y");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setPrealignOffSet(AXIS_Y, atof(cData));

		strKey.Format("REVISION_LIMIT_X");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "3.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setRevisionLimit(AXIS_X, atof(cData));

		strKey.Format("REVISION_LIMIT_Y");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "3.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setRevisionLimit(AXIS_Y, atof(cData));

		strKey.Format("REVISION_LIMIT_T");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "1.5", cData, MAX_PATH, strModelFilePath);
		machineInfo->setRevisionLimit(AXIS_T, atof(cData));

		strKey.Format("REVISION_OFFSET_X");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setRevisionOffset(0, atof(cData));

		strKey.Format("REVISION_OFFSET_Y");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setRevisionOffset(1, atof(cData));

		strKey.Format("REVISION_OFFSET_T");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setRevisionOffset(2, atof(cData));



		strKey.Format("CALIBRATION_TYPE");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setCalibrationType(atoi(cData));		

		strKey.Format("DISPENSER_OFFSET_T");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setDispenserOffsetT(atof(cData));

		strKey.Format("SAMPLING_ALIGN_OFFSET_X");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setSamplingAlignOffsetX(atof(cData));

		strKey.Format("SAMPLING_ALIGN_OFFSET_Y");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setSamplingAlignOffsetY(atof(cData));

		strKey.Format("CALIB_COUNT_X");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "10", cData, MAX_PATH, strModelFilePath);
		machineInfo->setCalibrationCountX(atoi(cData));

		strKey.Format("CALIB_COUNT_Y");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "10", cData, MAX_PATH, strModelFilePath);
		machineInfo->setCalibrationCountY(atoi(cData));

		strKey.Format("CALIB_RANGE_X");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "12.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setCalibrationRangeX(atof(cData));

		strKey.Format("CALIB_RANGE_Y");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "10.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setCalibrationRangeY(atof(cData));

		strKey.Format("ROTATE_RANGE");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "2.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setRotateRange(atof(cData));

		strKey.Format("ROTATE_COUNT");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "2", cData, MAX_PATH, strModelFilePath);
		machineInfo->setRotateCount(atoi(cData));

		strKey.Format("ROTATE_START_POS");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setRotateStartPos(atof(cData));
		strKey.Format("ROTATE_END_POS");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setRotateEndPos(atof(cData));

		strKey.Format("THETA_REFERENCE");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setThetaReference(atoi(cData));

		strKey.Format("L_CHECK_REF_DIST");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0.0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setLCheckRefDist(atof(cData));

		strKey.Format("THETA_CALIB_COUNT");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "10", cData, MAX_PATH, strModelFilePath);
		machineInfo->setThetaCalibCount(atoi(cData));

		strKey.Format("THETA_CALIB_PLUS_SLOPE");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "1", cData, MAX_PATH, strModelFilePath);
		machineInfo->setThetaSlope(0, atof(cData));

		strKey.Format("THETA_CALIB_PLUS_OFFSET");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setThetaOffset(0, atof(cData));

		strKey.Format("THETA_CALIB_MINUS_SLOPE");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "1", cData, MAX_PATH, strModelFilePath);
		machineInfo->setThetaSlope(1, atof(cData));

		strKey.Format("THETA_CALIB_MINUS_OFFSET");
		::GetPrivateProfileStringA("MACHINE_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		machineInfo->setThetaOffset(1, atof(cData));

		strKey.Format("USE_IMAGE_THETA");
		int nRet = ::GetPrivateProfileInt("MACHINE_INFO", "USE_IMAGE_THETA", 0, strModelFilePath);
		machineInfo->setUseImageTheta(nRet);


		GetMachine(algo).setNumCalPointsX(machineInfo->getCalibrationCountX());
		GetMachine(algo).setNumCalPointsY(machineInfo->getCalibrationCountY());
	}
	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}
BOOL CLET_AlignClientDlg::saveLightInfoData(int algo, CLightInfo *lightInfo, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		CString strData, strKey;
		CString strModelFilePath = strModelPath + "\\LightInfo.ini";

		for (int nCam = 0; nCam < vt_job_info[algo].num_of_camera; nCam++)
		{
			for (int light = 0; light < MAX_LIGHT_PER_CAMERA; light++)
			{
				for (int nIndex = 0; nIndex < MAX_LIGHT_INDEX; nIndex++)
				{
					strKey.Format("LIGHT_BRIGHT_%d_%d_%d", nCam + 1, light + 1, nIndex + 1);
					strData.Format("%d", lightInfo->getLightBright(nCam, light, nIndex));
					::WritePrivateProfileStringA("LIGHT_INFO", strKey, strData, strModelFilePath);

					strData.Format("%d", lightInfo->getLightBrightRestore(nCam, light, nIndex));	// dh.jung 2021-05-26 add restore light bright

				}
			}
		}
	}
	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}
BOOL CLET_AlignClientDlg::saveMachineInfoData(int algo, CMachineInfo* machineInfo, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		CString strData, strKey;
		CString strModelFilePath = strModelPath + "\\MachineInfo.ini";
 		int real_cam = 0;
#ifndef JOB_INFO
		for (int nCam = 0; nCam < m_nNumCamera; nCam++)
#else
		for (int nCam = 0; nCam < vt_job_info[algo].num_of_camera; nCam++)
#endif
		{
			real_cam = vt_job_info[algo].camera_index[nCam];

			for (int nPos = 0; nPos < vt_job_info[algo].num_of_position; nPos++)
			{
				strKey.Format("ROTATE_X%d%d", nCam + 1, nPos + 1);
				strData.Format("%.6f", machineInfo->getRotateCenterX(nCam, nPos));
				::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

				strKey.Format("ROTATE_Y%d%d", nCam + 1, nPos + 1);
				strData.Format("%.6f", machineInfo->getRotateCenterY(nCam, nPos));
				::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);
			}

			strKey.Format("EXPOSURE_TIME%d", nCam + 1);
			strData.Format("%d", machineInfo->getExposureTime(real_cam));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

			strKey.Format("GAIN%d", nCam + 1);
			strData.Format("%d", machineInfo->getGain(nCam));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

			strKey.Format("ALIGN_ORGIN_POS%d", nCam + 1);
			strData.Format("%d", machineInfo->getAlignOrginPos(nCam));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

#ifndef JOB_INFO
			strKey.Format("PREALIGN_OFFSET_X%d", nCam + 1);
			strData.Format("%.2f", machineInfo->getPrealignOffSet(nCam, AXIS_X));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

			strKey.Format("PREALIGN_OFFSET_Y%d", nCam + 1);
			strData.Format("%.2f", machineInfo->getPrealignOffSet(nCam, AXIS_Y));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

			strKey.Format("REVISION_LIMIT_X_%d", nCam + 1);
			strData.Format("%.3f", machineInfo->getRevisionLimit(nCam,AXIS_X));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

			strKey.Format("REVISION_LIMIT_Y_%d", nCam + 1);
			strData.Format("%.3f", machineInfo->getRevisionLimit(nCam, AXIS_Y));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

			strKey.Format("REVISION_LIMIT_T_%d", nCam + 1);
			strData.Format("%.3f", machineInfo->getRevisionLimit(nCam, AXIS_T));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

			strKey.Format("REVISION_OFFSET_X_%d", nCam + 1);
			strData.Format("%f", machineInfo->getRevisionOffset(nCam, 0));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

			strKey.Format("REVISION_OFFSET_Y_%d", nCam + 1);
			strData.Format("%f", machineInfo->getRevisionOffset(nCam, 1));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

			strKey.Format("REVISION_OFFSET_T_%d", nCam + 1);
			strData.Format("%f", machineInfo->getRevisionOffset(nCam, 2));
			::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);
#endif
		}		

#ifndef JOB_INFO
#else
		strKey.Format("ALIGNMENT_TYPE");
		strData.Format("%d", machineInfo->getAlignmentType());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey.Format("PREALIGN_OFFSET_X");
		strData.Format("%.2f", machineInfo->getPrealignOffSet(AXIS_X));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey.Format("PREALIGN_OFFSET_Y");
		strData.Format("%.2f", machineInfo->getPrealignOffSet(AXIS_Y));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey.Format("REVISION_LIMIT_X");
		strData.Format("%.3f", machineInfo->getRevisionLimit(AXIS_X));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey.Format("REVISION_LIMIT_Y");
		strData.Format("%.3f", machineInfo->getRevisionLimit(AXIS_Y));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey.Format("REVISION_LIMIT_T");
		strData.Format("%.3f", machineInfo->getRevisionLimit(AXIS_T));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey.Format("REVISION_OFFSET_X");
		strData.Format("%f", machineInfo->getRevisionOffset(AXIS_X));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey.Format("REVISION_OFFSET_Y");
		strData.Format("%f", machineInfo->getRevisionOffset(AXIS_Y));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey.Format("REVISION_OFFSET_T");
		strData.Format("%f", machineInfo->getRevisionOffset(AXIS_T));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);
#endif

		strKey = "CALIBRATION_TYPE";
		strData.Format("%d", machineInfo->getCalibrationType());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "DISPENSER_OFFSET_T";
		strData.Format("%.4f", machineInfo->getDispenserOffsetT());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "SAMPLING_ALIGN_OFFSET_X";
		strData.Format("%.4f", machineInfo->getSamplingAlignOffsetX());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "SAMPLING_ALIGN_OFFSET_Y";
		strData.Format("%.4f", machineInfo->getSamplingAlignOffsetY());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "CALIB_COUNT_X";
		strData.Format("%d", machineInfo->getCalibrationCountX());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "CALIB_COUNT_Y";
		strData.Format("%d", machineInfo->getCalibrationCountY());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "CALIB_RANGE_X";
		strData.Format("%.1f", machineInfo->getCalibrationRangeX());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "CALIB_RANGE_Y";
		strData.Format("%.1f", machineInfo->getCalibrationRangeY());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "ROTATE_RANGE";
		strData.Format("%.1f", machineInfo->getRotateRange());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "ROTATE_COUNT";
		strData.Format("%d", machineInfo->getRotateCount());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "ROTATE_START_POS";
		strData.Format("%.1f", machineInfo->getRotateStartPos());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);
		strKey = "ROTATE_END_POS";
		strData.Format("%.1f", machineInfo->getRotateEndPos());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "THETA_REFERENCE";
		strData.Format("%d", machineInfo->getThetaReference());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "L_CHECK_REF_DIST";
		strData.Format("%.3f", machineInfo->getLCheckRefDist());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "THETA_CALIB_COUNT";
		strData.Format("%d", machineInfo->getThetaCalibCount());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "THETA_CALIB_PLUS_SLOPE";
		strData.Format("%f", machineInfo->getThetaSlope(0));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);
		strKey = "THETA_CALIB_PLUS_OFFSET";
		strData.Format("%f", machineInfo->getThetaOffset(0));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);
		strKey = "THETA_CALIB_MINUS_SLOPE";
		strData.Format("%f", machineInfo->getThetaSlope(1));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		strKey = "THETA_CALIB_MINUS_OFFSET";
		strData.Format("%f", machineInfo->getThetaOffset(1));
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);


		strKey = "USE_IMAGE_THETA";
		strData.Format("%d", machineInfo->getUseImageTheta());
		::WritePrivateProfileStringA("MACHINE_INFO", strKey, strData, strModelFilePath);

		}
	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}

//lhj add 220503
BOOL CLET_AlignClientDlg::readAlignInfoDataSameCenterItem(int nJob, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		TCHAR cData[MAX_PATH];
		CString strData, strKey;
		CString strModelFilePath = strModelPath + "\\AlignInfo.ini";

		CFileFind findFile;
		if (findFile.FindFile(strModelFilePath) != TRUE)	return bSuccess;

		strKey.Format("INSP_RANGE_LENGTH");
		::GetPrivateProfileStringA("ALIGN_INFO", strKey, "10.0", cData, MAX_PATH, strModelFilePath);
		sFileData.dCircleLength = atof(cData);

		strKey.Format("DISTANCE_INSP_HOLE_METAL");
		::GetPrivateProfileStringA("ALIGN_INFO", strKey, "0.05", cData, MAX_PATH, strModelFilePath);
		sFileData.dCenterMetalDistanceSpec = atof(cData);
	}
	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}

BOOL CLET_AlignClientDlg::readAlignInfoData(int nJob, CAlignInfo *alignInfo, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {

		int iVal;
		double dVal;
		CString strModelFilePath = strModelPath + "\\AlignInfo.ini";

		std::string strSection = "ALIGN_INFO", strValue;
		INIReader ini(fmt_("%s/AlignInfo.ini", strModelPath.GetString()));

		CFileFind findFile;
		if (findFile.FindFile(strModelFilePath) != TRUE)	goto loopEnd;		

		for (int nPoint = 0; nPoint < NUM_ALIGN_POINTS; nPoint++)
		{
			dVal = ini.GetReal(strSection, fmt_("ALIGN_OFFSET%d", nPoint + 1), 0.0);		alignInfo->setAlignOffset(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("ALIGN_SPEC%d", nPoint + 1), 6.15);			alignInfo->setAlignSpec(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("ALIGN_SPEC_MAX%d", nPoint + 1), 0.0);		alignInfo->setAlignSpecMax(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("ALIGN_SPEC_MIN%d", nPoint + 1), 0.0);		alignInfo->setAlignSpecMin(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("ALIGN_SPEC_MINMAX%d", nPoint + 1), 0.1);	alignInfo->setAlignSpecMinMax(nPoint, dVal);
			iVal = ini.GetInteger(strSection, fmt_("USE_ALIGN_MEASURE%d", nPoint + 1), 0);	alignInfo->setUseAlignMeasure(nPoint, iVal);
		}

		iVal = ini.GetInteger(strSection, "ANGLE_CALC_METHOD", 0);	alignInfo->setAngleCalcMethod(iVal);
		iVal = ini.GetInteger(strSection, "ALIGNMENT_TARGET", 0);	alignInfo->setAlignmentTarget(iVal);
		iVal = ini.GetInteger(strSection, "ALIGNMENT_TARGET_DIR", 0);	alignInfo->setAlignmentTargetDir(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_ALIGN_BLACKWHITE_SELECT", 0);	alignInfo->setEnableAlignBlackWhiteSelect(iVal);
		iVal = ini.GetInteger(strSection, "MARK_FIND_METHOD", 0);	alignInfo->setMarkFindMethod(iVal);
		iVal = ini.GetInteger(strSection, "USE_REVISION_REVERSE_X", 0);	alignInfo->setRevisionReverseX(iVal);
		iVal = ini.GetInteger(strSection, "USE_REVISION_REVERSE_Y", 0);	alignInfo->setRevisionReverseY(iVal);
		iVal = ini.GetInteger(strSection, "USE_REVISION_REVERSE_T", 0);	alignInfo->setRevisionReverseT(iVal);
		iVal = ini.GetInteger(strSection, "USE_REVISION_REVERSE_XY", 0);	alignInfo->setRevisionReverseXY(iVal);
		iVal = ini.GetInteger(strSection, "USE_REVISION_RESET", 0);	alignInfo->setUseRevisionReset(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_ALIGN_MEASURE_SPEC_OUT_JUDGE", 0);	alignInfo->setEnableAlignMeasureSpecOutJudge(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_ALIGN_MEASURE_SPEC_OUT_JUDGE_COUNT", 3);	alignInfo->setEnableAlignMeasureSpecOutJudgeCount(iVal);
		iVal = ini.GetInteger(strSection, "USE_FIXTURE_MARK_INSPECTION", 0);	alignInfo->setUseFixtureMark(iVal);		
		iVal = ini.GetInteger(strSection, "USE_REFERENCE_MARK_INSPECTION", 0);	alignInfo->setUseReferenceMark(iVal);// hsj 2022-01-31 reference 사용 유무

		for (int i = 0; i < NUM_POS; i++)
		{
			strValue = ini.GetString(strSection, fmt_("REFERENCE_X_MARK_DATE_%d", i), "Reference Pos X [0/0]");    m_strRefDate_X[nJob][i].Format("%s", strValue.c_str());
			strValue = ini.GetString(strSection, fmt_("REFERENCE_Y_MARK_DATE_%d", i), "Reference Pos Y [0/0]");    m_strRefDate_Y[nJob][i].Format("%s", strValue.c_str());
			strValue = ini.GetString(strSection, fmt_("REFERENCE_T_MARK_DATE_%d", i), "Reference Pos T [0/0]");    m_strRefDate_T[nJob][i].Format("%s", strValue.c_str());
			strValue = ini.GetString(strSection, fmt_("FIXTURE_X_MARK_DATE_%d", i), "Fixture Pos X [0/0]");    m_strFixtureDate_X[nJob][i].Format("%s", strValue.c_str());
			strValue = ini.GetString(strSection, fmt_("FIXTURE_Y_MARK_DATE_%d", i), "Fixture Pos Y [0/0]");    m_strFixtureDate_Y[nJob][i].Format("%s", strValue.c_str());
			strValue = ini.GetString(strSection, fmt_("FIXTURE_T_MARK_DATE_%d", i), "Fixture Pos T [0/0]");    m_strFixtureDate_T[nJob][i].Format("%s", strValue.c_str());
		}

		dVal = ini.GetReal(strSection, "INSPECTION_METHOD_TYPE", 0.0);		alignInfo->setInspectionMethod(dVal);
		dVal = ini.GetReal(strSection, "INSPECTION_SUB_METHOD_TYPE", 0.0);		alignInfo->setInspectionSubMethod(dVal);
		dVal = ini.GetReal(strSection, "INSPECTION_SUB_DIRECTION_TYPE", 0.0);		alignInfo->setInspectionSubDir(dVal);
		dVal = ini.GetReal(strSection, "INSP_RANGE_X", 200);		alignInfo->setInspRangeX(dVal);
		dVal = ini.GetReal(strSection, "INSP_RANGE_Y", 200);		alignInfo->setInspRangeY(dVal);
		dVal = ini.GetReal(strSection, "INSP_RANGE_LENGTH", 10.0);		alignInfo->setInspRangeLength(dVal);
		iVal = ini.GetInteger(strSection, "INSP_SEARCH_EDGEPOLARITY", 0);	alignInfo->setSearchEdgePolarity(iVal);
		iVal = ini.GetInteger(strSection, "INSP_SEARCH_DIR", 0);	alignInfo->setSearchSearchDir(iVal);
		dVal = ini.GetReal(strSection, "INSP_TRACE_INTERVAL", 0.156);		alignInfo->setInspTraceInterval(dVal);
		dVal = ini.GetReal(strSection, "INSP_IN_HOLE_SIZE", 1.5);		alignInfo->setInspInHoleSize(dVal);
		dVal = ini.GetReal(strSection, "INSP_CAM_HOLE_SIZE", 2.75);		alignInfo->setInspCamHoleSize(dVal);
		dVal = ini.GetReal(strSection, "INSP_STEEL_HOLE_SIZE", 2.9);		alignInfo->setInspSteelHoleSize(dVal);
		iVal = ini.GetInteger(strSection, "INSP_INSP_RESULTCOUNT", 5);	alignInfo->setInspResultCount(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_REALTIME_TRACE", 1);	alignInfo->setUseRealTimeTrace(iVal);
		iVal = ini.GetInteger(strSection, "USE_FIX_TRACE_DATA", 0);	alignInfo->setUseUseFixTrace(iVal);
		iVal = ini.GetInteger(strSection, "USE_METAL_TRACE", 0);	alignInfo->setUseMetalTrace(iVal);
		iVal = ini.GetInteger(strSection, "USE_METAL_TRACE_FIRST", 0);	alignInfo->setUseMetalTraceFirst(iVal);
		iVal = ini.GetInteger(strSection, "USE_CYCLE_TRACE", 0);	alignInfo->setUseCycleTrace(iVal);
		iVal = ini.GetInteger(strSection, "USE_REVERSE_ORDER", 0);	alignInfo->setUseReverseOrder(iVal);
		iVal = ini.GetInteger(strSection, "USE_SUB_INSP_ALGORITHM", 0);	alignInfo->setUseSubInspAlgorithm(iVal);
		iVal = ini.GetInteger(strSection, "USE_AUTOSAVE_AVI", 0);	alignInfo->setUseAutoSaveAVI(iVal);
		iVal = ini.GetInteger(strSection, "USE_PN_BASE", 0);	alignInfo->setUsePNBase(iVal);
		dVal = ini.GetReal(strSection, "DISTANCE_INSP_HOLE_METAL", 0.5);		alignInfo->setDistanceInspHoleMetal(dVal);

		for (int pos = 0; pos < NUM_ALIGN_POINTS; pos++)
		{
			dVal = ini.GetReal(strSection, fmt_("DISTANCE_INSP_SPEC%d", pos + 1), 0.0);		alignInfo->setDistanceInspSpecLSL(pos, dVal);
			dVal = ini.GetReal(strSection, fmt_("DISTANCE_INSP_SPEC_X%d", pos + 1), 0.0);		alignInfo->setDistanceInspSubSpec(pos, dVal);
			dVal = ini.GetReal(strSection, fmt_("DISTANCE_INSP_SPEC_Y%d", pos + 1), 0.0);		alignInfo->setDistanceInspSpecY(pos, dVal);
			dVal = ini.GetReal(strSection, fmt_("DISTANCE_INSP_SPEC_MINMAX%d", pos + 1), 0.0);		alignInfo->setDistanceInspSpecUSL(pos, dVal);
			dVal = ini.GetReal(strSection, fmt_("DISTANCE_INSP_SPEC_X_MINMAX%d", pos + 1), 0.0);		alignInfo->setDistanceInspSubSpecXTolerance(pos, dVal);
			dVal = ini.GetReal(strSection, fmt_("DISTANCE_INSP_SPEC_Y_MINMAX%d", pos + 1), 0.0);		alignInfo->setDistanceInspSpecYMinMax(pos, dVal);
		}

		dVal = ini.GetReal(strSection, "INSPECTION_SUB_INTERVAL", 0.0);		alignInfo->setInspectionSubInterval(dVal);
		dVal = ini.GetReal(strSection, "INSPECTION_SUB_INTERVAL_TOL", 0.0);		alignInfo->setInspectionSubIntervalTolerance(dVal);
		iVal = ini.GetInteger(strSection, "ENABLE_CRACK_INSP", 0);	alignInfo->setUseCrackInsp(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INCLUDED_ANGLE", 0);	alignInfo->setUseIncludedAngle(iVal);
		dVal = ini.GetReal(strSection, "INCLUDED_ANGLE", 90.0);		alignInfo->setIncludedAngle(dVal);
		dVal = ini.GetReal(strSection, "INCLUDED_ANGLE_LIMIT", 1.0);		alignInfo->setIncludedAngleLimit(dVal);
		iVal = ini.GetInteger(strSection, "USE_BOX_INSPECTION", 0);	alignInfo->setUseBoxInsp(iVal);
		iVal = ini.GetInteger(strSection, "USE_DUMMY_SEPAR_INSPECTION", 0);	alignInfo->setUseDummySeparInsp(iVal);
		iVal = ini.GetInteger(strSection, "USE_DUMMY_CORNER_INSPECTION", 0);	alignInfo->setUseDummyCornerInsp(iVal);
		iVal = ini.GetInteger(strSection, "USE_LINE_DOUBLE_MODE", 0);	alignInfo->setUseDoubleDispensingMode(iVal);
		iVal = ini.GetInteger(strSection, "USE_LINE_OVERFLOW_DISPMODE", 0);	alignInfo->setLineOverflowDispMode(iVal);
		iVal = ini.GetInteger(strSection, "USE_CIRCLE_CINK1_CINK2MERGE_MODE", 0);	alignInfo->setCircle_Cink1_Cink2MergeMode(iVal);
		iVal = ini.GetInteger(strSection, "USE_LINE_WITHTRACE_RESULT_MODE", 0);	alignInfo->setLine_InspWithTraceResultMode(iVal);
		iVal = ini.GetInteger(strSection, "DUMMY_CORNER_INSPECTION_CAM", 0);	alignInfo->setDummyCornerInspCam(iVal);
		iVal = ini.GetInteger(strSection, "DUMMY_CORNER_FILTER", 0);	alignInfo->setDummyCornerFilter(iVal);
		dVal = ini.GetReal(strSection, "DUMMY_CORNER_INCLUDED_ANGLE", 45.0);		alignInfo->setDummyCornerIncludedAngle(dVal);
		dVal = ini.GetReal(strSection, "DUMMY_CORNER_INCLUDED_ANGLE_LIMIT", 1.0);		alignInfo->setDummyCornerIncludedAngleLimit(dVal);
		iVal = ini.GetInteger(strSection, "INSP_METHOD", 0);	alignInfo->setInspMethod(iVal);
		iVal = ini.GetInteger(strSection, "POL_EDGE_FIND_METHOD", 0);	alignInfo->setPolEdgeFindMethod(iVal);
		iVal = ini.GetInteger(strSection, "CHIP_RANSAC_TYPE", 0);	alignInfo->setChipRansacType(iVal);
		iVal = ini.GetInteger(strSection, "CHIP_RANSAC_DIRECTION", 0);	alignInfo->setChipRansacDirection(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_ALIGN_MEASURE", 0);	alignInfo->setEnableAlignMeasure(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_ALIGN_LEFT_RIGHT_DIFF_JUDGE", 0);	alignInfo->setEnableAlignLeftRightDiffJudge(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_ALIGN_REVERSE_GLASS_SELECT", 0);	alignInfo->setEnableAlignReverseSelect(iVal);
		alignInfo->setMarkReverseFind(alignInfo->getEnableAlignReverseSelect());
		dVal = ini.GetReal(strSection, "ALIGN_LEFT_RIGHT_DIFF_SPEC", 0.1);		alignInfo->setAlignLeftRightDiffSpec(dVal);
		iVal = ini.GetInteger(strSection, "USE_DUMMY_PORT_ALIGN", 0);	alignInfo->setUseDummyPortAlign(iVal);

		/*
		// 현재 사용하지 않는 부분이라 일단 주석	21.02.15
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			for (int nPos = 0; nPos < NUM_POS; nPos++)
			{
				for (int nIndex = 0; nIndex < MAX_INDEX; nIndex++)
				{
					strKey.Format("REMOVE_NOISE_SIZE_%d_%d_%d", nCam + 1, nPos + 1, nIndex + 1);
					::GetPrivateProfileStringA("ALIGN_INFO", strKey, "10", cData, MAX_PATH, strModelFilePath);
					alignInfo->setRemoveNoiseSize(nCam, nPos, nIndex, atoi(cData));

					strKey.Format("SOBEL_THRESHOLD_%d_%d_%d", nCam + 1, nPos + 1, nIndex + 1);
					::GetPrivateProfileStringA("ALIGN_INFO", strKey, "10", cData, MAX_PATH, strModelFilePath);
					alignInfo->setSobelTheshold(nCam, nPos, nIndex, atoi(cData));

					strKey.Format("SEARCH_AREA_%d_%d_%d", nCam + 1, nPos + 1, nIndex + 1);
					::GetPrivateProfileStringA("ALIGN_INFO", strKey, "200", cData, MAX_PATH, strModelFilePath);
					alignInfo->setSearchArea(nCam, nPos, nIndex, atoi(cData));

					strKey.Format("PROJECTION_AREA_%d_%d_%d", nCam + 1, nPos + 1, nIndex + 1);
					::GetPrivateProfileStringA("ALIGN_INFO", strKey, "500", cData, MAX_PATH, strModelFilePath);
					alignInfo->setProjectionArea(nCam, nPos, nIndex, atoi(cData));
				}
			}
		}
		*/
		iVal = ini.GetInteger(strSection, "ENABLE_L_CHECK", 0);	alignInfo->setEnableLCheck(iVal);
		dVal = ini.GetReal(strSection, "L_CHECK_LIMIT", 0.0);		alignInfo->setLCheckTor(dVal);
		dVal = ini.GetReal(strSection, "L_CHECK_SPEC_X", 0.0);		alignInfo->setLCheckSpecX(dVal);
		dVal = ini.GetReal(strSection, "L_CHECK_SPEC_Y", 0.0);		alignInfo->setLCheckSpecY(dVal);
		iVal = ini.GetInteger(strSection, "L_CHECK_REFENRENCE", 0);	alignInfo->setLCheckReference(iVal);
		dVal = ini.GetReal(strSection, "L_CHECK_SCALE", 1.0);		alignInfo->setLCheckScale(dVal);
		iVal = ini.GetInteger(strSection, "GRAB_DELAY", 0);	alignInfo->setGrabDelay(iVal);
		iVal = ini.GetInteger(strSection, "USE_MULTIPLEX_ROI", 0);	alignInfo->setUseMultiplexRoi(iVal);
		dVal = ini.GetReal(strSection, "FIDUCIAL_MARK_PITCH_X", 10.0);		alignInfo->setFiducialMarkPitchX(dVal);
		dVal = ini.GetReal(strSection, "SECONDMARK_PITCH_Y", 10.0);		alignInfo->setFiducialSecondMarkPitchY(dVal);
		iVal = ini.GetInteger(strSection, "USE_REVIEW_MODE", 0);	alignInfo->setEnableReView(iVal);
		iVal = ini.GetInteger(strSection, "USE_4POINT_ALIGN", 0);	alignInfo->setUse4PointAlign(iVal);
		iVal = ini.GetInteger(strSection, "USING_1CAM", 0);	alignInfo->setUsing1Cam(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_2SHOT_ALIGN", 0);	alignInfo->setEnable2ShotAlign(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_USE_ALIGN_IMAGE", 0);	alignInfo->setEnableUseAlignImage(iVal);

		// L_LAMI
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			/*
			// 현재 사용하지 않는 부분이라 일단 주석	21.02.15
			for (int nPos = 0; nPos < NUM_POS; nPos++)
			{
				strKey.Format("CORNER_TYPE_%d_%d", nCam, nPos);
				::GetPrivateProfileStringA("ALIGN_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				alignInfo->setCornerType(nCam, nPos, atoi(cData));

				strKey.Format("EDGE_POLARITY_%d_%d", nCam, nPos);
				::GetPrivateProfileStringA("ALIGN_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				alignInfo->setEdgePolarity(nCam, nPos, atoi(cData));

				strKey.Format("EDGE_DIRECTION_%d_%d", nCam, nPos);
				::GetPrivateProfileStringA("ALIGN_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				alignInfo->setEdgeDirection(nCam, nPos, atoi(cData));

				strKey.Format("PRE_PROCESS_%d_%d", nCam, nPos);
				::GetPrivateProfileStringA("ALIGN_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				alignInfo->setPreProcess(nCam, nPos, atoi(cData));

				strKey.Format("EDGE_PROCESS_%d_%d", nCam, nPos);
				::GetPrivateProfileStringA("ALIGN_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				alignInfo->setEdgeProcess(nCam, nPos, atoi(cData));
			}
			*/
			dVal = ini.GetReal(strSection, fmt_("HALCON_MIN_CONSTRAST_%d", nCam), -1);		alignInfo->setHalconMinContrast(nCam, dVal);
			dVal = ini.GetReal(strSection, fmt_("HALCON_MAX_CONSTRAST_%d", nCam), -1);		alignInfo->setHalconHighContrast(nCam, dVal);

		}

		/*
		// 현재 사용하지 않는 부분이라 일단 주석	21.02.15
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			for (int nPos = 0; nPos < NUM_POS; nPos++)
			{
				for (int nIndex = 0; nIndex < MAX_INDEX; nIndex++)
				{
					GetMatching(nJob).setRemoveNoiseSize(nCam, nPos, nIndex, alignInfo->getRemoveNoiseSize(nCam, nPos, nIndex));
					GetMatching(nJob).setSobelThreshold(nCam, nPos, nIndex, alignInfo->getSobelThreshold(nCam, nPos, nIndex));
					GetMatching(nJob).setSearchArea(nCam, nPos, nIndex, alignInfo->getSearchArea(nCam, nPos, nIndex));
					GetMatching(nJob).setProjectionArea(nCam, nPos, nIndex, alignInfo->getProjectionArea(nCam, nPos, nIndex));
				}

				GetMatching(nJob).setCornerType(nCam, nPos, alignInfo->getCornerType(nCam, nPos));	//19.10.28
				GetMatching(nJob).setEdgePolarity(nCam, nPos, alignInfo->getEdgePolarity(nCam, nPos));
				GetMatching(nJob).setEdgeDirection(nCam, nPos, alignInfo->getEdgeDirection(nCam, nPos));
				GetMatching(nJob).setPreProcess(nCam, nPos, alignInfo->getPreProcess(nCam, nPos));
				GetMatching(nJob).setEdgeProcess(nCam, nPos, alignInfo->getEdgeProcess(nCam, nPos));
			}
		}
		*/
	loopEnd:
		int num_of_camera = vt_job_info[nJob].num_of_camera;
		int num_of_position = vt_job_info[nJob].num_of_position;

		GetMatching(nJob).readPatternData(true, strModelPath, num_of_camera, num_of_position);

		setViewerReferencePos();
	}
	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}
BOOL CLET_AlignClientDlg::saveAlignInfoData(int nJob, CAlignInfo *alignInfo, CString strModelPath, BOOL bSave)
{
	BOOL bSuccess = TRUE;

	try {
		CString strModelFilePath = strModelPath + "\\AlignInfo.ini";
		CString strKey, strData;

		for (int nPoint = 0; nPoint < NUM_ALIGN_POINTS; nPoint++)
		{
			strKey.Format("ALIGN_OFFSET%d", nPoint + 1);
			strData.Format("%.3f", alignInfo->getAlignOffset(nPoint));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("ALIGN_SPEC%d", nPoint + 1);
			strData.Format("%.3f", alignInfo->getAlignSpec(nPoint));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("ALIGN_SPEC_MAX%d", nPoint + 1);
			strData.Format("%.3f", alignInfo->getAlignSpecMax(nPoint));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("ALIGN_SPEC_MIN%d", nPoint + 1);
			strData.Format("%.3f", alignInfo->getAlignSpecMin(nPoint));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("ALIGN_SPEC_MINMAX%d", nPoint + 1);
			strData.Format("%.3f", alignInfo->getAlignSpecMinMax(nPoint));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("USE_ALIGN_MEASURE%d", nPoint + 1);
			strData.Format("%d", alignInfo->getUseAlignMeasure(nPoint));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		}

		strKey.Format("ANGLE_CALC_METHOD");
		strData.Format("%d", alignInfo->getAngleCalcMethod());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("ALIGNMENT_TARGET");
		strData.Format("%d", alignInfo->getAlignmentTarget());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("ALIGNMENT_TARGET_DIR");
		strData.Format("%d", alignInfo->getAlignmentTargetDir());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("ENABLE_ALIGN_BLACKWHITE_SELECT");
		strData.Format("%d", alignInfo->getEnableAlignBlackWhiteSelect());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("MARK_FIND_METHOD");
		strData.Format("%d", alignInfo->getMarkFindMethod());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_REVISION_REVERSE_X");
		strData.Format("%d", alignInfo->getRevisionReverseX());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_REVISION_REVERSE_Y");
		strData.Format("%d", alignInfo->getRevisionReverseY());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_REVISION_REVERSE_T");
		strData.Format("%d", alignInfo->getRevisionReverseT());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_REVISION_REVERSE_XY");
		strData.Format("%d", alignInfo->getRevisionReverseXY());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_REVISION_RESET");
		strData.Format("%d", alignInfo->getUseRevisionReset());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("ENABLE_ALIGN_MEASURE_SPEC_OUT_JUDGE");
		strData.Format("%d", alignInfo->getEnableAlignMeasureSpecOutJudge());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("ENABLE_ALIGN_MEASURE_SPEC_OUT_JUDGE_COUNT");
		strData.Format("%d", alignInfo->getEnableAlignMeasureSpecOutJudgeCount());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_FIXTURE_MARK_INSPECTION");
		strData.Format("%d", alignInfo->getUseFixtureMark());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		// hsj 2022-01-31 reference 사용 유무
		strKey.Format("USE_REFERENCE_MARK_INSPECTION");
		strData.Format("%d", alignInfo->getUseReferenceMark());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		// hsj 2022-03-14 reference 날짜 표시
		for (int i = 0; i < NUM_POS; i++)
		{
			strKey.Format("REFERENCE_X_MARK_DATE_%d", i);
			strData.Format("%s", m_strRefDate_X[nJob][i]);
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
			strKey.Format("REFERENCE_Y_MARK_DATE_%d", i);
			strData.Format("%s", m_strRefDate_Y[nJob][i]);
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
			strKey.Format("REFERENCE_T_MARK_DATE_%d", i);
			strData.Format("%s", m_strRefDate_T[nJob][i]);
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
			strKey.Format("FIXTURE_X_MARK_DATE_%d", i);
			strData.Format("%s", m_strFixtureDate_X[nJob][i]);
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
			strKey.Format("FIXTURE_Y_MARK_DATE_%d", i);
			strData.Format("%s", m_strFixtureDate_Y[nJob][i]);
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
			strKey.Format("FIXTURE_T_MARK_DATE_%d", i);
			strData.Format("%s", m_strFixtureDate_T[nJob][i]);
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		}

		strKey.Format("INSP_RANGE_X");
		strData.Format("%4.4f", alignInfo->getInspRangeX());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		strKey.Format("INSP_RANGE_Y");
		strData.Format("%4.4f", alignInfo->getInspRangeY());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		strKey.Format("INSP_RANGE_LENGTH");
		strData.Format("%4.4f", alignInfo->getInspRangeLength());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INSP_SEARCH_EDGEPOLARITY");
		strData.Format("%d", alignInfo->getSearchEdgePolarity());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		
		strKey.Format("INSP_SEARCH_DIR");
		strData.Format("%d", alignInfo->getSearchSearchDir());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INSP_TRACE_INTERVAL");
		strData.Format("%4.4f", alignInfo->getInspTraceInterval());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INSP_IN_HOLE_SIZE");
		strData.Format("%4.4f", alignInfo->getInspInHoleSize());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		strKey.Format("INSP_CAM_HOLE_SIZE");
		strData.Format("%4.4f", alignInfo->getInspCamHoleSize());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		strKey.Format("INSP_STEEL_HOLE_SIZE");
		strData.Format("%4.4f", alignInfo->getInspSteelHoleSize());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INSP_INSP_RESULTCOUNT");
		strData.Format("%d", alignInfo->getInspResultCount());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("ENABLE_REALTIME_TRACE");
		strData.Format("%d", alignInfo->getUseRealTimeTrace());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);		
		strKey.Format("USE_FIX_TRACE_DATA");
		strData.Format("%d", alignInfo->getUseUseFixTrace());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_METAL_TRACE");
		strData.Format("%d", alignInfo->getUseMetalTrace());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_METAL_TRACE_FIRST");
		strData.Format("%d", alignInfo->getUseMetalTraceFirst());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_CYCLE_TRACE");
		strData.Format("%d", alignInfo->getUseCycleTrace());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		
		strKey.Format("USE_REVERSE_ORDER");
		strData.Format("%d", alignInfo->getUseReverseOrder());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		
		strKey.Format("USE_SUB_INSP_ALGORITHM");
		strData.Format("%d", alignInfo->getUseSubInspAlgorithm());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_AUTOSAVE_AVI");
		strData.Format("%d", alignInfo->getUseAutoSaveAVI());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_PN_BASE");
		strData.Format("%d", alignInfo->getUsePNBase());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("DISTANCE_INSP_HOLE_METAL");
		strData.Format("%.3f", alignInfo->getDistanceInspHoleMetal());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		for (int pos = 0; pos < NUM_ALIGN_POINTS; pos++)
		{
			strKey.Format("DISTANCE_INSP_SPEC%d", pos + 1);
			strData.Format("%f", alignInfo->getDistanceInspSpecLSL(pos));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("DISTANCE_INSP_SPEC_X%d", pos + 1);
			strData.Format("%f", alignInfo->getDistanceInspSubSpec(pos));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("DISTANCE_INSP_SPEC_Y%d", pos + 1);
			strData.Format("%f", alignInfo->getDistanceInspSpecY(pos));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("DISTANCE_INSP_SPEC_MINMAX%d", pos + 1);
			strData.Format("%f", alignInfo->getDistanceInspSpecUSL(pos));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("DISTANCE_INSP_SPEC_X_MINMAX%d", pos + 1);
			strData.Format("%f", alignInfo->getDistanceInspSubSpecTolerance(pos));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("DISTANCE_INSP_SPEC_Y_MINMAX%d", pos + 1);
			strData.Format("%f", alignInfo->getDistanceInspSpecYMinMax(pos));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		}

		strKey.Format("INSPECTION_SUB_INTERVAL");
		strData.Format("%d", alignInfo->getInspectionSubInterval());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INSPECTION_SUB_INTERVAL_TOL");
		strData.Format("%d", alignInfo->getInspectionSubIntervalTolerance());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INSPECTION_METHOD_TYPE");
		strData.Format("%d", alignInfo->getInspectionMethod());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INSPECTION_SUB_METHOD_TYPE");
		strData.Format("%d", alignInfo->getInspectionSubMethod());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INSPECTION_SUB_DIRECTION_TYPE");
		strData.Format("%d", alignInfo->getInspectionSubDir());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("ENABLE_CRACK_INSP");
		strData.Format("%d", alignInfo->getUseCrackInsp());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("ENABLE_INCLUDED_ANGLE");
		strData.Format("%d", alignInfo->getUseIncludedAngle());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INCLUDED_ANGLE");
		strData.Format("%f", alignInfo->getIncludedAngle());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INCLUDED_ANGLE_LIMIT");
		strData.Format("%f", alignInfo->getIncludedAngleLimit());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_BOX_INSPECTION");
		strData.Format("%d", alignInfo->getUseBoxInsp());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_DUMMY_SEPAR_INSPECTION");
		strData.Format("%d", alignInfo->getUseDummySeparInsp());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_DUMMY_CORNER_INSPECTION");
		strData.Format("%d", alignInfo->getUseDummyCornerInsp());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_LINE_DOUBLE_MODE");
		strData.Format("%d", alignInfo->getUseDoubleDispensingMode());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_LINE_OVERFLOW_DISPMODE");
		strData.Format("%d", alignInfo->getLineOverflowDispMode());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_CIRCLE_CINK1_CINK2MERGE_MODE");
		strData.Format("%d", alignInfo->getCircle_Cink1_Cink2MergeMode());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("USE_LINE_WITHTRACE_RESULT_MODE");
		strData.Format("%d", alignInfo->getLine_InspWithTraceResultMode());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);		

		strKey.Format("DUMMY_CORNER_INSPECTION_CAM");
		strData.Format("%d", alignInfo->getDummyCornerInspCam());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("DUMMY_CORNER_FILTER");
		strData.Format("%d", alignInfo->getDummyCornerFilter());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("DUMMY_CORNER_INCLUDED_ANGLE");
		strData.Format("%f", alignInfo->getDummyCornerIncludedAngle());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("DUMMY_CORNER_INCLUDED_ANGLE_LIMIT");
		strData.Format("%f", alignInfo->getDummyCornerIncludedAngleLimit());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);


		strKey = "INSP_METHOD";
		strData.Format("%d", alignInfo->getInspFindMethod());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "POL_EDGE_FIND_METHOD";
		strData.Format("%d", alignInfo->getPolEdgeFindMethod());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "CHIP_RANSAC_TYPE";
		strData.Format("%d", alignInfo->getChipRansacType());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "CHIP_RANSAC_DIRECTION";
		strData.Format("%d", alignInfo->getChipRansacDirection());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "ENABLE_ALIGN_MEASURE";
		strData.Format("%d", alignInfo->getEnableAlignMeasure());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "ENABLE_ALIGN_LEFT_RIGHT_DIFF_JUDGE";
		strData.Format("%d", alignInfo->getEnableAlignLeftRightDiffJudge());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "ALIGN_LEFT_RIGHT_DIFF_SPEC";
		strData.Format("%.3f", alignInfo->getAlignLeftRightDiffSpec());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "ENABLE_ALIGN_REVERSE_GLASS_SELECT";
		strData.Format("%d", alignInfo->getEnableAlignReverseSelect());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		/*
		// 현재 사용하지 않는 부분이라 일단 주석	21.02.15
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			for (int nPos = 0; nPos < NUM_POS; nPos++)
			{
				for (int nIndex = 0; nIndex < MAX_INDEX; nIndex++)
				{
					strKey.Format("REMOVE_NOISE_SIZE_%d_%d_%d", nCam + 1, nPos + 1, nIndex + 1);
					strData.Format("%d", alignInfo->getRemoveNoiseSize(nCam, nPos, nIndex));
					::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

					strKey.Format("SOBEL_THRESHOLD_%d_%d_%d", nCam + 1, nPos + 1, nIndex + 1);
					strData.Format("%d", alignInfo->getSobelThreshold(nCam, nPos, nIndex));
					::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

					strKey.Format("SEARCH_AREA_%d_%d_%d", nCam + 1, nPos + 1, nIndex + 1);
					strData.Format("%d", alignInfo->getSearchArea(nCam, nPos, nIndex));
					::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

					strKey.Format("PROJECTION_AREA_%d_%d_%d", nCam + 1, nPos + 1, nIndex + 1);
					strData.Format("%d", alignInfo->getProjectionArea(nCam, nPos, nIndex));
					::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
				}
			}
		}
		*/

		strKey.Format("ENABLE_L_CHECK");
		strData.Format("%d", alignInfo->getEnableLCheck());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("L_CHECK_LIMIT");
		strData.Format("%f", alignInfo->getLCheckTor());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("L_CHECK_SPEC_X");
		strData.Format("%f", alignInfo->getLCheckSpecX());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("L_CHECK_SPEC_Y");
		strData.Format("%f", alignInfo->getLCheckSpecY());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("L_CHECK_REFENRECE");
		strData.Format("%d", alignInfo->getLCheckReference());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("L_CHECK_SCALE");
		strData.Format("%f", alignInfo->getLCheckScale());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("GRAB_DELAY");
		strData.Format("%d", alignInfo->getGrabDelay());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);


		strKey.Format("USE_MULTIPLEX_ROI");
		strData.Format("%d", alignInfo->getUseMultiplexRoi());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("FIDUCIAL_MARK_PITCH_X");
		strData.Format("%.3f", alignInfo->getFiducialMarkPitchX());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey.Format("SECONDMARK_PITCH_Y");
		strData.Format("%.3f", alignInfo->getFiducialSecondMarkPitchY());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "USE_REVIEW_MODE";
		strData.Format("%d", alignInfo->getEnableReView());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "USE_4POINT_ALIGN";
		strData.Format("%d", alignInfo->getUse4PointAlign());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "USING_1CAM";
		strData.Format("%d", alignInfo->getUsing1Cam());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		strKey = "ENABLE_2SHOT_ALIGN";
		strData.Format("%d", alignInfo->getEnable2ShotAlign());
		::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

		/*
		// 현재 사용하지 않는 부분이라 일단 주석	21.02.15
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			for (int nPos = 0; nPos < NUM_POS; nPos++)
			{
				strKey.Format("CORNER_TYPE_%d_%d", nCam, nPos);
				strData.Format("%d", alignInfo->getCornerType(nCam, nPos));
				::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

				strKey.Format("EDGE_POLARITY_%d_%d", nCam, nPos);
				strData.Format("%d", alignInfo->getEdgePolarity(nCam, nPos));
				::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

				strKey.Format("EDGE_DIRECTION_%d_%d", nCam, nPos);
				strData.Format("%d", alignInfo->getEdgeDirection(nCam, nPos));
				::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

				strKey.Format("PRE_PROCESS_%d_%d", nCam, nPos);
				strData.Format("%d", alignInfo->getPreProcess(nCam, nPos));
				::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

				strKey.Format("EDGE_PROCESS_%d_%d", nCam, nPos);
				strData.Format("%d", alignInfo->getEdgeProcess(nCam, nPos));
				::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
			}
			strKey.Format("HALCON_MIN_CONSTRAST_%d", nCam);
			strData.Format("%f", alignInfo->getHalconMinContrast(nCam));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("HALCON_MAX_CONSTRAST_%d", nCam);
			strData.Format("%f", alignInfo->getHalconHighContrast(nCam));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		}
		*/
		for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
		{
			strKey.Format("HALCON_MIN_CONSTRAST_%d", nCam);
			strData.Format("%f", alignInfo->getHalconMinContrast(nCam));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);

			strKey.Format("HALCON_MAX_CONSTRAST_%d", nCam);
			strData.Format("%f", alignInfo->getHalconHighContrast(nCam));
			::WritePrivateProfileStringA("ALIGN_INFO", strKey, strData, strModelFilePath);
		}

		if (bSave)
		{
			// Client Type 별로 분기 시킬 필요 있음. 속도 저하.
			GetMatching(nJob).setMarkReverseFind(alignInfo->getMarkReverseFind());
			GetMatching(nJob).savePatternData(strModelPath);
		}
	}
	catch (...)
	{
		bSuccess = FALSE;
	}
	return bSuccess;
}

// dh.jung 2021-08-02 add 검사 Spec, Parameter
BOOL CLET_AlignClientDlg::readInspSpecPara(int nJob, CInspSpecPara* inspSpecPara, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		int iVal;
		double dVal;

		CFileFind findFile;
		CString strModelFilePath = strModelPath + "\\InspSpecPara.ini";
		
		if (findFile.FindFile(strModelFilePath) != TRUE)	return bSuccess;

		std::string strSection = "INSP_SPEC_INFO";
		INIReader ini(fmt_("%s/InspSpecPara.ini", strModelPath.GetString()));		

		for (int nPoint = 0; nPoint < MAX_INSP_POS; nPoint++)
		{// 검사 SPEC
			dVal = ini.GetReal(strSection, fmt_("INSP_SPEC%d", nPoint + 1), 0.0);
			inspSpecPara->setInSpec(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("INSP_SPEC_TORR%d", nPoint + 1), 0.0);
			inspSpecPara->setInSpecTorr(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("OUT_SPEC%d", nPoint + 1), 0.0);
			inspSpecPara->setOutSpec(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("OUT_SPEC_TORR%d", nPoint + 1), 0.0);
			inspSpecPara->setOutSpecTorr(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("TOTAL_SPEC%d", nPoint + 1), 0.0);
			inspSpecPara->setTotalSpec(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("TOTAL_SPEC_TORR%d", nPoint + 1), 0.0);
			inspSpecPara->setTotalSpecTorr(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("DISTANCE_SPEC%d", nPoint + 1), 0.0);
			inspSpecPara->setDistanceSpec(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("DISTANCE_SPEC_TORR%d", nPoint + 1), 0.0);
			inspSpecPara->setDistanceSpecTorr(nPoint, dVal);
		}

		strSection = "INSP_PARAMETER_INFO";

		for (int nPoint = 0; nPoint < MAX_INSP_POS; nPoint++)
		{// 검사 PARA
			dVal = ini.GetReal(strSection, fmt_("START_SERCH_POINT%d", nPoint + 1), 0.0);
			inspSpecPara->setStartSerchPoint(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("END_SERCH_POINT%d", nPoint + 1), 0.0);
			inspSpecPara->setEndSerchPoint(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("SERCH_MIN_MAX_JUDGE_OFFSET_IN%d", nPoint + 1), 0.0);
			inspSpecPara->setSerchMinMaxJudgeOffsetIn(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("SERCH_MIN_MAX_JUDGE_OFFSET_OUT%d", nPoint + 1), 0.0);
			inspSpecPara->setSerchMinMaxJudgeOffsetOut(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("DUST_INSP_IN%d", nPoint + 1), 0.0);
			inspSpecPara->setDustInspIn(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("DUST_INSP_OUT%d", nPoint + 1), 0.0);
			inspSpecPara->setDustInspOut(nPoint, dVal);
			dVal = ini.GetReal(strSection, fmt_("LIMIT_LINE_INSP%d", nPoint + 1), 0.0);
			inspSpecPara->setLimitLineInspOffset(nPoint, dVal);
			iVal = ini.GetInteger(strSection, fmt_("INK_CHECK_THRESH%d", nPoint + 1), 60);
			inspSpecPara->setInkCheckThresh(nPoint, iVal);
			iVal = ini.GetInteger(strSection, fmt_("LAMI_CHECK_THRESH%d", nPoint + 1), 60);
			inspSpecPara->setLamiCheckThresh(nPoint, iVal);
		}

		iVal = ini.GetInteger(strSection, "ENABLE_INSP_DISP_STATUS_FLAG", 0);
		inspSpecPara->setDispensingStatusEnable(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INSP_LAMI_STATUS_FLAG", 0);
		inspSpecPara->setLamiStatusEnable(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INSP_CENTER_DIST_FLAG", 0);
		inspSpecPara->setCenterDistanceEnable(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INSP_CC_DIST_FLAG", 0);
		inspSpecPara->setCenterCCDistanceEnable(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INSP_NOZZLE_HOLE_DIST_FLAG", 0);
		inspSpecPara->setNozzleToHoleEdgeEnable(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INSP_METAL_RADIUS_CHECK_FLAG", 0);
		inspSpecPara->setCircleMetalRadiusCheck(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INSP_METAL_CENTER_CHECK_FLAG", 0);
		inspSpecPara->setCircleMetalCenterCheck(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INSP_NOZZLE_PANLE_CHECK_FLAG", 0);
		inspSpecPara->setNozzlePanelHoleCheck(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INSP_FINDCICLE_CENTER_CHECK_FLAG", 1);
		inspSpecPara->setCircleFindCenterCheck(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INSP_DEBUG_MODE_CHECK_FLAG", 0);
		inspSpecPara->setInspectionDebugCheck(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_INSP_NOZZLEANGLE_SEARCH_MODE", 0);
		inspSpecPara->setNozzleAngleSearchMode(iVal);
		iVal = ini.GetInteger(strSection, "GRAB_DELAY_DUST_INSP", 0);
		inspSpecPara->setDustInspGrabDelay(iVal);
		iVal = ini.GetInteger(strSection, "GRAB_DELAY_DROP_INSP", 0);
		inspSpecPara->setDropInspGrabDelay(iVal);
		iVal = ini.GetInteger(strSection, "GRAB_DELAY_CENTER_ALIGN", 0);
		inspSpecPara->setCenterAlignGrabDelay(iVal);
		iVal = ini.GetInteger(strSection, "GRAB_DELAY_NOZZLE_ALIGN", 0);
		inspSpecPara->setNozzleAlignGrabDelay(iVal);
		iVal = ini.GetInteger(strSection, "GRAB_DELAY_FILM_INSP", 0);
		inspSpecPara->setFilmInspGrabDelay(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_ADAPTIVE_DISPNSING_FLAG", 0);
		inspSpecPara->setAdaptiveDispensingFlag(iVal);
		dVal = ini.GetReal(strSection, "ADAPTIVE_DISPNSING_BASE_OFFSET", 0.0);
		inspSpecPara->setAdaptiveDispensingBaseOffset(dVal);
		dVal = ini.GetReal(strSection, "ADAPTIVE_DISPNSING_SCALE_OFFSET", 1.0);
		inspSpecPara->setAdaptiveDispensingScaleOffset(dVal);
		dVal = ini.GetReal(strSection, "ADAPTIVE_DISPNSING_DISPENSING_RANGE", 90.0);
		inspSpecPara->setAdaptiveDispensingRange(dVal);
		iVal = ini.GetInteger(strSection, "ENABLE_METRALSEARCH_PREPROC_FLAG", 1);
		inspSpecPara->setMetalSearchRemoveNoiseFlag(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_TRACE_USING_ALIGN_FLAG", 0);
		inspSpecPara->setTraceUsingAlignFlag(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_CINKINSP_ELBENDSEARCH_FLAG", 1);
		inspSpecPara->setSearchElbEndPosFlag(iVal);
		//hsj 2022-01-07 필름검사 Method 파라미터 추가
		iVal = ini.GetInteger(strSection, "FILM_INSP_METHOD", 0);
		inspSpecPara->setFilmInspMethod(iVal);
		//HSJ 2022-01-17 필름검사 마크 찾을 시 캘리퍼 사용 유무
		iVal = ini.GetInteger(strSection, "PANEL_USE_CALIPER", 0);
		inspSpecPara->setPanelCaliperEnable(iVal);
		iVal = ini.GetInteger(strSection, "FILM_USE_CALIPER", 0);
		inspSpecPara->setFilmCaliperEnable(iVal);
		//hsj 2022-01-27 필름검사 scale 파라미터 추가
		iVal = ini.GetInteger(strSection, "FILM_USE_SCALE", 0);
		inspSpecPara->setFilmScaleEnable(iVal);
		dVal = ini.GetReal(strSection, "FILM_LX_SCALE", 1.0);
		inspSpecPara->setFilmLXScale(dVal);
		dVal = ini.GetReal(strSection, "FILM_RX_SCALE", 1.0);
		inspSpecPara->setFilmRXScale(dVal);
		dVal = ini.GetReal(strSection, "FILM_LY_SCALE", 1.0);
		inspSpecPara->setFilmLYScale(dVal);
		dVal = ini.GetReal(strSection, "FILM_RY_SCALE", 1.0);
		inspSpecPara->setFilmRYScale(dVal);
		// hsj 2022-02-07 필름검사 L check 기능 추가
		iVal = ini.GetInteger(strSection, "PANEL_USE_LCHECK", 0);
		inspSpecPara->setPanelLcheckEnable(iVal);
		dVal = ini.GetReal(strSection, "PANEL_LCHECK_LENGTH", 12.5);
		inspSpecPara->setPanelLcheckLength(dVal);
		dVal = ini.GetReal(strSection, "PANEL_LCHECK_LENGTH_TORR", 0.5);
		inspSpecPara->setPanelLcheckTorr(dVal);
		iVal = ini.GetInteger(strSection, "FILM_USE_LCHECK", 0);
		inspSpecPara->setFilmLcheckEnable(iVal);
		dVal = ini.GetReal(strSection, "FILM_LCHECK_LENGTH", 12.5);
		inspSpecPara->setFilmLcheckLength(dVal);
		dVal = ini.GetReal(strSection, "FILM_LCHECK_LENGTH_TORR", 0.5);
		inspSpecPara->setFilmLcheckTorr(dVal);
		iVal = ini.GetInteger(strSection, "FILM_USE_REATTACH_CHECK", 0);
		inspSpecPara->setFilmReAttachCheckEnable(iVal);
		iVal = ini.GetInteger(strSection, "FILM_USE_REATTACH_CHECK_THRESH", 200);
		inspSpecPara->setFilmReAttachCheckThresh(iVal);
		iVal = ini.GetInteger(strSection, "FILM_USE_UV_CHECK", 0);
		inspSpecPara->setFilmUVCheckEnable(iVal);
		iVal = ini.GetInteger(strSection, "FILM_USE_UV_CHECK_THRESH", 200);
		inspSpecPara->setFilmUVCheckThresh(iVal);
		iVal = ini.GetInteger(strSection, "FILM_USE_UV_CHECK_SPEC", 200);
		inspSpecPara->setFilmUVCheckSpec(iVal);
		// hsj 2022-02-07 필름검사 threshold 기능 추가
		iVal = ini.GetInteger(strSection, "USE_PANEL_THRESH_ATUO", 1);
		inspSpecPara->setUsePanelThresh_Auto(iVal);
		iVal = ini.GetInteger(strSection, "PANEL_THRESH", 200);
		inspSpecPara->setPanelThresh(iVal);
		// PHB 2022-04-15 필름검사 파라미터 추가
		iVal = ini.GetInteger(strSection, "USE_FILM_REVERSE_POSITION", 0);
		inspSpecPara->setUseFilmReversePosition(iVal);
		//KJH 2021-11-12 Trace Parameter 작업 시작
		iVal = ini.GetInteger(strSection, "TRACE_IMAGE_THRESH", 0);
		inspSpecPara->setTraceImageThresh(iVal);
		iVal = ini.GetInteger(strSection, "FIND_EDGE_THRESH", 0);
		inspSpecPara->setFindEdgeThresh(iVal);
		//KJH 2021-12-01 Dust Insp Image Para 추가
		dVal = ini.GetReal(strSection, "DUST_INSP_ROI_SIZE", 3.5);
		inspSpecPara->setDiffInspROISize(dVal);
		iVal = ini.GetInteger(strSection, "DUST_INSP_ROI_SHAPE", 0);
		inspSpecPara->setDiffInspROIShape(iVal);
		dVal = ini.GetReal(strSection, "NOZZLE_TO_STAGE_GAP_OFFSET", 90.0);
		inspSpecPara->setNozzleToStageGapOffset(dVal);

		iVal = ini.GetInteger(strSection, "ENABLE_DUST_INSP", 0);
		inspSpecPara->setUseDustInsp(iVal);
		iVal = ini.GetInteger(strSection, "ENABLE_DIFF_INSP", 0);
		inspSpecPara->setUseDiffInsp(iVal);
		iVal = ini.GetInteger(strSection, "USE_INPUT_INSPECTION", 0);
		inspSpecPara->setUseInputInspection(iVal);
		iVal = ini.GetInteger(strSection, "ELB_INSP_HIGH_THRESH", 210);
		inspSpecPara->setInspectionHighThresh(iVal);
		iVal = ini.GetInteger(strSection, "ELB_INSP_LOW_THRESH", 80);
		inspSpecPara->setInspectionLowThresh(iVal);
		iVal = ini.GetInteger(strSection, "EXIST_PANEL_GRAY", 50);
		inspSpecPara->setExistPanelGray(iVal);
		iVal = ini.GetInteger(strSection, "EXIST_DUMMY_GRAY", 200);
		inspSpecPara->setExistDummyGray(iVal);
		iVal = ini.GetInteger(strSection, "INSP_DUST_INSP_THRESH", 150);
		inspSpecPara->setInspDustThresh(iVal);
		dVal = ini.GetReal(strSection, "INSP_SUB_INSP_MINSIZE", 1.0);
		inspSpecPara->setInspMinSize(dVal);
		
		//KJH 2022-01-12 WetoutInsp Para Insp Para로 분기
		iVal = ini.GetInteger(strSection, "WETOUT_INSP_CC_FILTER_THRESHOLD", 40);
		inspSpecPara->setCCFindFilter(iVal);
		iVal = ini.GetInteger(strSection, "WETOUT_INSP_TEST_IMAGE_SAVE", 0);
		inspSpecPara->setTestImageSave(iVal);
		//KJH 2022-01-25 ELB Cover CInk mode 
		iVal = ini.GetInteger(strSection, "ELB_COVER_CINK_MODE", 0);
		inspSpecPara->setELBCoverCInkMode(iVal);
		iVal = ini.GetInteger(strSection, "ELB_CGEDGE_CALC_MODE", 0);
		inspSpecPara->setELBCG_Edge_CalcModeEnable(iVal);
		dVal = ini.GetReal(strSection, "ELB_LINE_POCKET_SIZE", 4.4);
		inspSpecPara->setELB_Line_Pocket_Size(dVal);
		iVal = ini.GetInteger(strSection, "ELB_PATIAL_DISPENSING_MODE", 0);
		inspSpecPara->setELBPartial_DispensingModeEnable(iVal);
		iVal = ini.GetInteger(strSection, "ELB_INSP_SHIFT_SEARCH", 0);
		inspSpecPara->setELBInsp_ShiftSearchEnable(iVal);
		iVal = ini.GetInteger(strSection, "AVI_SAVEIMAGE_TYPE", 0);
		inspSpecPara->setAVI_Save_ImageTypeEnable(iVal);
		iVal = ini.GetInteger(strSection, "LINE_SHIFT_DISPENSING_MODE", 0);
		inspSpecPara->setLineShift_DispensingModeEnable(iVal);
		dVal = ini.GetReal(strSection, "ELB_CINK_MINWIDTH_SPEC", 0.07);
		inspSpecPara->setCInkMinWidthSpec(dVal);
		dVal = ini.GetReal(strSection, "ELB_LINE_LENGTH_MINTHICK", 0.0);
		inspSpecPara->setLineLengthMinThick(dVal);
		dVal = ini.GetReal(strSection, "ELB_LINE_LENGTH_SPEC", 2.5);
		inspSpecPara->setLineLengthSpec(dVal);
		dVal = ini.GetReal(strSection, "ELB_CAM_CENTERTO_CG", 33.565);
		inspSpecPara->setCamCenterToCG(dVal);
		dVal = ini.GetReal(strSection, "ELB_INK_UNDERFLOW_SPEC", 0.1);
		inspSpecPara->setInkUnderflowSpec(dVal);
		//HTK 2022-03-16 DummyInspSpec 추가
		dVal = ini.GetReal(strSection, "ELB_DUMMY_MINSIZE_SPEC", 0.1);
		inspSpecPara->setDummyMinSizeSpec(dVal);
		dVal = ini.GetReal(strSection, "ELB_FERI_ALIGN_FIND_THRESH", 80);
		inspSpecPara->setFeriAlignFindThresh(dVal);
		//KJH 2022-02-05 Metal Over flow Margin
		dVal = ini.GetReal(strSection, "METAL_OVERFLOW_MARGIN", 0.1);
		inspSpecPara->setMetalOverflowMargin(dVal);
		//KJH 2022-04-09 PN 반지름 비교 검사 추가
		iVal = ini.GetInteger(strSection, "PN_SIZE_INSP_ENABLE", 0);
		inspSpecPara->setPNSizeInspEnable(iVal);
		dVal = ini.GetReal(strSection, "PN_SIZE_SPEC", 2.35);
		inspSpecPara->setPNSizeSpec(dVal);
		dVal = ini.GetReal(strSection, "PN_SIZE_SPEC_TORR", 0.05);
		inspSpecPara->setPNSizeSpecTorr(dVal);

		// KBJ 2022-09-05 Rotate 파라미터 추가
		dVal = ini.GetReal(strSection, "ROTATE_CENTER_SPEC", 0.02);
		inspSpecPara->setRotateC_Spec(dVal);
		iVal = ini.GetInteger(strSection, "ROTATE_CENTER_BINARY", 80);
		inspSpecPara->setRotateC_binary_value(iVal);
		iVal = ini.GetInteger(strSection, "ROTATE_CENTER_LIGHT", 0);
		inspSpecPara->setRotateC_light_value(iVal);

		//KJH 2022-04-29 MincountCheckInsp 추가
		//KJH 2022-05-09 Mincount 상시 사용으로 변경
		// iVal = ini.GetInteger(strSection, "MIN_COUNT_CHECK_INSP_MODE", 0);
		//inspSpecPara->setMinCountCheckInspModeEnable(iVal);
		iVal = ini.GetInteger(strSection, "MIN_COUNT_CHECK_INSP_CONTINUE_COUNT", 45);
		inspSpecPara->setMinCountCheckInspContinueCount(iVal);
		iVal = ini.GetInteger(strSection, "MIN_COUNT_CHECK_INSP_TOTAL_COUNT", 120);
		inspSpecPara->setMinCountCheckInspTotalCount(iVal);
		//KJH 2022-05-09 R Judge 사용 유무 추가
		iVal = ini.GetInteger(strSection, "WETOUT_R_SPEC_JUDGE_MODE", 0);
		inspSpecPara->setWetoutRJudgeModeEnable(iVal);
		dVal = ini.GetReal(strSection, "WETOUT_R_MINSPEC", 4.08);
		inspSpecPara->setWetoutRMinSpec(dVal);
		dVal = ini.GetReal(strSection, "WETOUT_R_MAXSPEC", 4.7);
		inspSpecPara->setWetoutRMaxSpec(dVal);
		//KJH 2022-05-25 BM In <-> Cink In Insp 추가
		iVal = ini.GetInteger(strSection, "WETOUT_B_SPEC_JUDGE_MODE", 0);
		inspSpecPara->setWetoutBJudgeModeEnable(iVal);
		dVal = ini.GetReal(strSection, "WETOUT_B_MINSPEC", 0.3);
		inspSpecPara->setWetoutBMinSpec(dVal);
		dVal = ini.GetReal(strSection, "WETOUT_B_MAXSPEC", 0.5);
		inspSpecPara->setWetoutBMaxSpec(dVal);
		dVal = ini.GetReal(strSection, "LINE_FDC_DISTANCE", 0.1);
		inspSpecPara->setLineLengthFDC_Distance(dVal);

		//SJB 2022-11-11 Overflow Min 파라미터 추가
		dVal = ini.GetReal(strSection, "LINE_OVERFLOW_MINSPEC", 0.2);
		inspSpecPara->setLineOverflowMinSpec(dVal);

		//SJB 2022-11-19 CG Exposure Time 파라미터 추가
		iVal = ini.GetReal(strSection, "CG_GRAB_EXPOSURE", 0);
		inspSpecPara->setCGGrabExposure(iVal);


		//HTK 2022-06-29 Wetout Min,Max Judge 사용유무 추가
		iVal = ini.GetInteger(strSection, "WETOUT_MINMAX_SPEC_JUDGE_MODE", 0);
		inspSpecPara->setWetoutMinMaxJudgeModeEnable(iVal);

		//KJH 2022-04-29 ELB CENTER ALIGN LIVE VIEW 가이드 라인 그리기 추가
		dVal = ini.GetReal(strSection, "CENTER_LIVE_GUIDE_LINE_OFFSET", 0);
		inspSpecPara->setCenterLiveViewGuideLineOffset(dVal);

		//HTK 2022-06-29 Nozzle Align Y Recalc
		iVal = ini.GetInteger(strSection, "CENTER_NOZZLE_ALIGN_Y_RECALC", 0);
		inspSpecPara->setCenterNozzleYAlignRecalc(iVal);

		// KBJ 2022-12-06 Nozzle Align Z Recalc
		iVal = ini.GetInteger(strSection, "SIDE_NOZZLE_ALIGN_Z_RECALC", 0);
		inspSpecPara->setSideNozzleZAlignRecalc(iVal);

		iVal = ini.GetInteger(strSection, "CENTER_NOZZLE_ALIGN_METHOD", 0);
		inspSpecPara->setCenterNozzleAlignMethod(iVal);		
		iVal = ini.GetInteger(strSection, "CENTER_NOZZLE_O_DIST_LIGHT", 150);
		inspSpecPara->setCenterNozzleToPanelDistanceLight(iVal);

		//HTK 2022-07-12 Nozzel#45에 약액상태 검사 추가
		dVal = ini.GetReal(strSection, "CENTER_45_INK_INSP_THRESH", 150);
		inspSpecPara->set45DegreeInkInspThresh(dVal);
		iVal = ini.GetInteger(strSection, "CENTER_45_INK_INSP_ENABLE", 0);
		inspSpecPara->set45DegreeInkInspEnable(iVal);
		iVal = ini.GetInteger(strSection, "CENTER_45_INK_START_DELAY", 1000);
		inspSpecPara->set45DegreenStartDelay(iVal);
		iVal = ini.GetInteger(strSection, "CENTER_45_INK_INTERVAL_DELAY", 1000);
		inspSpecPara->set45DegreenIntervalDelay(iVal);
		//KJH2
		iVal = ini.GetInteger(strSection, "CENTER_USE_YGAP_LIGHT", 0);
		inspSpecPara->setUseCenterNozzleYLight(iVal);
		iVal = ini.GetInteger(strSection, "NOZZLE_YGAP_THRESHOLD", 0);
		inspSpecPara->setNozzleYGapThreshold(iVal);

		iVal = ini.GetInteger(strSection, "ENABLE_WETOUT_INSP_SIMULATION", 0);
		inspSpecPara->setWetoutInspectionSimulation(iVal);

		// blue 2022.09.02 CINK1+CINK2(EGL)에서 wetout 계산시 GlassEdge 대신 MetalEdge 사용(F=기존 GlassEdge 사용)
		iVal = ini.GetInteger(strSection, "ENABLE_CALC_WETOUT_METALEDGE", 0);
		inspSpecPara->setCalcWetoutMetalEdge(iVal);

		// blue 2022.09.09
		iVal = ini.GetInteger(strSection, "ENABLE_DIFF_ROI_MERGE", 0);
		inspSpecPara->setDiffRoiMergeEnable(iVal);

		// SJB 2022-10-03 Scratch Parameter
		iVal = ini.GetInteger(strSection, "SCRATCH_INSP_ENABLE", 0);
		inspSpecPara->setScratchCheck(iVal);
		iVal = ini.GetInteger(strSection, "SCRATCH_INSP_THRESH", 180);
		inspSpecPara->setScratchThresh(iVal);
		dVal = ini.GetReal(strSection, "SCRATCH_MASKING_RADIUS", 2.0);
		inspSpecPara->setScratchMaskingRadius(dVal);
		iVal = ini.GetInteger(strSection, "SCRATCH_INSP_SPEC", 4);
		inspSpecPara->setScratchInspSpec(iVal);
		iVal = ini.GetInteger(strSection, "SCRATCH_INSP_AREA_SPEC", 50);
		inspSpecPara->setScratchInspAreaSpec(iVal);

		// YCS 2022-10-31 필름 유무검사 영역 사이즈 고정 
		iVal = ini.GetInteger(strSection, "FIXED_FILM_REATTACH_USE", 0);
		inspSpecPara->setFixedFilmReattachUse(iVal);
		dVal = ini.GetReal(strSection, "FIXED_FILM_REATTACH_SIZE", 2.5);
		inspSpecPara->setFixedFilmReattachSize(dVal);

		// YCS 2022-11-19 필름얼라인 각도 비교 스펙 파라미터 분리
		dVal = ini.GetReal(strSection, "FILM_ANGLE_COMPARE_SPEC", 0.3);
		inspSpecPara->setFilmAngleSpec(dVal);
		iVal = ini.GetInteger(strSection, "FILM_ANGLE_COMPARE_USE", 0);
		inspSpecPara->setFilmAngleInspectionUse(iVal);

		// YCS 2022-11-19
		iVal = ini.GetInteger(strSection, "FILM_USE_REATTACH_CHECK_USE_REVERSE_THRESH", 0);
		inspSpecPara->setUseReverseThresh(iVal);

		// YCS 2022-12-01 Wetout_ASPC 스펙 추가
		dVal = ini.GetReal(strSection, "WETOUT_ASPC_SPEC", 0.1);
		inspSpecPara->setWetoutASPCSpec(dVal);

		setViewerReferencePos();
	}
	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}

//lhj add 220503
BOOL CLET_AlignClientDlg::readInspSpecParaSameCenterItem(int nJob, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		TCHAR cData[MAX_PATH];
		CString strData, strKey;
		CString strModelFilePath = strModelPath + "\\InspSpecPara.ini";

		CFileFind findFile;
		if (findFile.FindFile(strModelFilePath) != TRUE)	return bSuccess;

		strKey.Format("ENABLE_DIFF_INSP");
		::GetPrivateProfileStringA("INSP_PARAMETER_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		sFileData.bWetoutEnable = atoi(cData);

		strKey.Format("USE_INPUT_INSPECTION");
		::GetPrivateProfileStringA("INSP_PARAMETER_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		sFileData.bDustEnable = atoi(cData);

		strKey.Format("ENABLE_DUST_INSP");
		::GetPrivateProfileStringA("INSP_PARAMETER_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		sFileData.bLiquidDropsEnable = atoi(cData);

		strKey.Format("EXIST_DUMMY_GRAY");
		::GetPrivateProfileStringA("INSP_PARAMETER_INFO", strKey, "200", cData, MAX_PATH, strModelFilePath);
		sFileData.inputThresh = atoi(cData);

		strKey.Format("INSP_DUST_INSP_THRESH");
		::GetPrivateProfileStringA("INSP_PARAMETER_INFO", strKey, "150", cData, MAX_PATH, strModelFilePath);
		sFileData.iLiquidDropsThresh = atoi(cData);

		strKey.Format("ELB_INSP_HIGH_THRESH");
		::GetPrivateProfileStringA("INSP_PARAMETER_INFO", strKey, "210", cData, MAX_PATH, strModelFilePath);
		sFileData.hthresh = atoi(cData);

		strKey.Format("ELB_INSP_LOW_THRESH");
		::GetPrivateProfileStringA("INSP_PARAMETER_INFO", strKey, "80", cData, MAX_PATH, strModelFilePath);
		sFileData.lthresh = atoi(cData);

		strModelFilePath = strModelPath + "\\AlignInfo.ini";
		if (findFile.FindFile(strModelFilePath) != TRUE)	return bSuccess;

		strKey.Format("USE_DUMMY_CORNER_INSPECTION"); //22.06.02
		::GetPrivateProfileStringA("ALIGN_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		sFileData.bCircleShapeModeEnable = atoi(cData);
	}
	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}

BOOL CLET_AlignClientDlg::saveInspSpecPara(int nJob, CInspSpecPara* inspSpecPara, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		CString strModelFilePath = strModelPath + "\\InspSpecPara.ini";
		CString strKey, strData;

		for (int nPoint = 0; nPoint < MAX_INSP_POS; nPoint++)
		{// 검사 SPEC
			strKey.Format("INSP_SPEC%d", nPoint + 1);
			strData.Format("%.3f", inspSpecPara->getInSpec(nPoint));
			::WritePrivateProfileStringA("INSP_SPEC_INFO", strKey, strData, strModelFilePath);

			strKey.Format("INSP_SPEC_TORR%d", nPoint + 1);
			strData.Format("%.3f", inspSpecPara->getInSpecTorr(nPoint));
			::WritePrivateProfileStringA("INSP_SPEC_INFO", strKey, strData, strModelFilePath);

			strKey.Format("OUT_SPEC%d", nPoint + 1);
			strData.Format("%.3f", inspSpecPara->getOutSpec(nPoint));
			::WritePrivateProfileStringA("INSP_SPEC_INFO", strKey, strData, strModelFilePath);

			strKey.Format("OUT_SPEC_TORR%d", nPoint + 1);
			strData.Format("%.3f", inspSpecPara->getOutSpecTorr(nPoint));
			::WritePrivateProfileStringA("INSP_SPEC_INFO", strKey, strData, strModelFilePath);

			strKey.Format("TOTAL_SPEC%d", nPoint + 1);
			strData.Format("%.3f", inspSpecPara->getTotalSpec(nPoint));
			::WritePrivateProfileStringA("INSP_SPEC_INFO", strKey, strData, strModelFilePath);

			strKey.Format("TOTAL_SPEC_TORR%d", nPoint + 1);
			strData.Format("%.3f", inspSpecPara->getTotalSpecTorr(nPoint));
			::WritePrivateProfileStringA("INSP_SPEC_INFO", strKey, strData, strModelFilePath);

			strKey.Format("DISTANCE_SPEC%d", nPoint + 1);
			strData.Format("%.3f", inspSpecPara->getDistanceSpec(nPoint));
			::WritePrivateProfileStringA("INSP_SPEC_INFO", strKey, strData, strModelFilePath);

			strKey.Format("DISTANCE_SPEC_TORR%d", nPoint + 1);
			strData.Format("%.3f", inspSpecPara->getDistanceSpecTorr(nPoint));
			::WritePrivateProfileStringA("INSP_SPEC_INFO", strKey, strData, strModelFilePath);
		}

		for (int iPoint = 0; iPoint < MAX_INSP_POS; iPoint++)
		{// 검사 PARA
			strKey.Format("START_SERCH_POINT%d", iPoint + 1);
			strData.Format("%.3f", inspSpecPara->getStartSerchPoint(iPoint));
			::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

			strKey.Format("END_SERCH_POINT%d", iPoint + 1);
			strData.Format("%.3f", inspSpecPara->getEndSerchPoint(iPoint));
			::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

			strKey.Format("SERCH_MIN_MAX_JUDGE_OFFSET_IN%d", iPoint + 1);
			strData.Format("%.3f", inspSpecPara->getSerchMinMaxJudgeOffsetIn(iPoint));
			::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

			strKey.Format("SERCH_MIN_MAX_JUDGE_OFFSET_OUT%d", iPoint + 1);
			strData.Format("%.3f", inspSpecPara->getSerchMinMaxJudgeOffsetOut(iPoint));
			::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

			strKey.Format("DUST_INSP_IN%d", iPoint + 1);
			strData.Format("%.3f", inspSpecPara->getDustInspIn(iPoint));
			::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

			strKey.Format("DUST_INSP_OUT%d", iPoint + 1);
			strData.Format("%.3f", inspSpecPara->getDustInspOut(iPoint));
			::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

			strKey.Format("LIMIT_LINE_INSP%d", iPoint + 1);
			strData.Format("%.3f", inspSpecPara->getLimitLineInspOffset(iPoint));

			strKey.Format("INK_CHECK_THRESH%d", iPoint + 1);
			strData.Format("%d", inspSpecPara->getInkCheckThresh(iPoint));
			::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

			strKey.Format("LAMI_CHECK_THRESH%d", iPoint + 1);
			strData.Format("%d", inspSpecPara->getLamiCheckThresh(iPoint));
			::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

		}

		//KJH 2021-11-12 Trace Parameter 작업 시작

		strData.Format("%d", inspSpecPara->getTraceImageThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "TRACE_IMAGE_THRESH", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getFindEdgeThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FIND_EDGE_THRESH", strData, strModelFilePath);

		//KJH 2021-12-01 Dust Insp Image Para 추가

		strData.Format("%.3f", inspSpecPara->getDiffInspROISize());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "DUST_INSP_ROI_SIZE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getDiffInspROIShape());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "DUST_INSP_ROI_SHAPE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getDispensingStatusEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_DISP_STATUS_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getLamiStatusEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_LAMI_STATUS_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getCenterDistanceEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_CENTER_DIST_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getCenterCCDistanceEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_CC_DIST_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getNozzleToHoleEdgeEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_NOZZLE_HOLE_DIST_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getCircleMetalRadiusCheck());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_METAL_RADIUS_CHECK_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getCircleMetalCenterCheck());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_METAL_CENTER_CHECK_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getNozzlePanelHoleCheck());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_NOZZLE_PANLE_CHECK_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getCircleFindCenterCheck());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_FINDCICLE_CENTER_CHECK_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getInspectionDebugCheck());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_DEBUG_MODE_CHECK_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getNozzleAngleSearchMode());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_INSP_NOZZLEANGLE_SEARCH_MODE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getDustInspGrabDelay());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "GRAB_DELAY_DUST_INSP", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getDropInspGrabDelay());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "GRAB_DELAY_DROP_INSP", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getCenterAlignGrabDelay());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "GRAB_DELAY_CENTER_ALIGN", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getNozzleAlignGrabDelay());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "GRAB_DELAY_NOZZLE_ALIGN", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getFilmInspGrabDelay());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "GRAB_DELAY_FILM_INSP", strData, strModelFilePath);

		strData.Format("%.3f", inspSpecPara->getFilmInspExceptionSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_INSP_EX_SPEC", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getFilmInspExceptionCount());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_INSP_EX_COUNT", strData, strModelFilePath);


		//HSJ 2022-01-07 필름검사 Method 파라미터 추가
		strData.Format("%d", inspSpecPara->getFilmInspMethod());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_INSP_METHOD", strData, strModelFilePath);

		//HSJ 2022-01-17 필름검사 마크 찾을 시 캘리퍼 사용 유무
		strData.Format("%d", inspSpecPara->getPanelCaliperEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "PANEL_USE_CALIPER", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getFilmCaliperEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_USE_CALIPER", strData, strModelFilePath);

		//hsj 2022-01-27 필름검사 scale 파라미터 추가
		strData.Format("%d", inspSpecPara->getFilmScaleEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_USE_SCALE", strData, strModelFilePath);

		strData.Format("%.4f", inspSpecPara->getFilmLXScale());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_LX_SCALE", strData, strModelFilePath);
		strData.Format("%.4f", inspSpecPara->getFilmRXScale());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_RX_SCALE", strData, strModelFilePath);
		strData.Format("%.4f", inspSpecPara->getFilmLYScale());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_LY_SCALE", strData, strModelFilePath);
		strData.Format("%.4f", inspSpecPara->getFilmRYScale());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_RY_SCALE", strData, strModelFilePath);

		// hsj 2022-02-07 필름검사 L check 기능 추가
		strData.Format("%d", inspSpecPara->getPanelLcheckEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "PANEL_USE_LCHECK", strData, strModelFilePath);
		strData.Format("%.4f", inspSpecPara->getPanelLcheckLength());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "PANEL_LCHECK_LENGTH", strData, strModelFilePath);
		strData.Format("%.4f", inspSpecPara->getPanelLcheckTorr());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "PANEL_LCHECK_LENGTH_TORR", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getFilmLcheckEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_USE_LCHECK", strData, strModelFilePath);
		strData.Format("%.4f", inspSpecPara->getFilmLcheckLength());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_LCHECK_LENGTH", strData, strModelFilePath);
		strData.Format("%.4f", inspSpecPara->getFilmLcheckTorr());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_LCHECK_LENGTH_TORR", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getFilmReAttachCheckEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_USE_REATTACH_CHECK", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getFilmReAttachCheckThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_USE_REATTACH_CHECK_THRESH", strData, strModelFilePath);	
		strData.Format("%d", inspSpecPara->getUseReverseThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_USE_REATTACH_CHECK_USE_REVERSE_THRESH", strData, strModelFilePath);


		strData.Format("%d", inspSpecPara->getFilmUVCheckEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_USE_UV_CHECK", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getFilmUVCheckThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_USE_UV_CHECK_THRESH", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getFilmUVCheckSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_USE_UV_CHECK_SPEC", strData, strModelFilePath);

		strData.Format("%.4f", inspSpecPara->getNozzleToStageGapOffset());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "NOZZLE_TO_STAGE_GAP_OFFSET", strData, strModelFilePath);
		
		// hsj 2022-02-07 필름검사 threshold 기능 추가
		strData.Format("%d", inspSpecPara->getUsePanelThresh_Auto());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "USE_PANEL_THRESH_ATUO", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getPanelThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "PANEL_THRESH", strData, strModelFilePath);
		
		//phb 2022-04-15 필름검사 파라미터 추가
		strData.Format("%d", inspSpecPara->getUseFilmReversePosition());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "USE_FILM_REVERSE_POSITION", strData, strModelFilePath);
		
		//KJH 2022-01-09 검사 flag Aligninfo->inspSpecinfo로 위치변경

		strKey.Format("ENABLE_DUST_INSP");
		strData.Format("%d", inspSpecPara->getUseDustInsp());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);
		strKey.Format("ENABLE_DIFF_INSP");
		strData.Format("%d", inspSpecPara->getUseDiffInsp());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);
		strKey.Format("USE_INPUT_INSPECTION");
		strData.Format("%d", inspSpecPara->getUseInputInspection());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

		strKey.Format("ELB_INSP_HIGH_THRESH");
		strData.Format("%d", inspSpecPara->getInspectionHighThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);
		strKey.Format("ELB_INSP_LOW_THRESH");
		strData.Format("%d", inspSpecPara->getInspectionLowThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

		strKey.Format("EXIST_DUMMY_GRAY");
		strData.Format("%d", inspSpecPara->getExistDummyGray());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

		strKey.Format("EXIST_PANEL_GRAY");
		strData.Format("%d", inspSpecPara->getExistPanelGray());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INSP_DUST_INSP_THRESH");
		strData.Format("%d", inspSpecPara->getInspDustThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

		strKey.Format("INSP_SUB_INSP_MINSIZE");
		strData.Format("%.4f", inspSpecPara->getInspMinSize());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", strKey, strData, strModelFilePath);

		//KJH 2022-01-12 WetoutInsp Para Insp Para로 분기
		strData.Format("%d", inspSpecPara->getCCFindFilter());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "WETOUT_INSP_CC_FILTER_THRESHOLD", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getTestImageSave());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "WETOUT_INSP_TEST_IMAGE_SAVE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getAdaptiveDispensingFlag());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_ADAPTIVE_DISPNSING_FLAG", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getAdaptiveDispensingBaseOffset());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ADAPTIVE_DISPNSING_BASE_OFFSET", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getAdaptiveDispensingScaleOffset());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ADAPTIVE_DISPNSING_SCALE_OFFSET", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getAdaptiveDispensingRange());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ADAPTIVE_DISPNSING_DISPENSING_RANGE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getMetalSearchRemoveNoiseFlag());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_METRALSEARCH_PREPROC_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getTraceUsingAlignFlag());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_TRACE_USING_ALIGN_FLAG", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getSearchElbEndPosFlag());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_CINKINSP_ELBENDSEARCH_FLAG", strData, strModelFilePath);

		//KJH 2022-01-25 ELB Cover CInk mode
		strData.Format("%d", inspSpecPara->getELBCoverCInkMode());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_COVER_CINK_MODE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getELBCG_Edge_CalcModeEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_CGEDGE_CALC_MODE", strData, strModelFilePath);

		strData.Format("%.3f", inspSpecPara->getELB_Line_Pocket_Size());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_LINE_POCKET_SIZE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getELBPartial_DispensingModeEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_PATIAL_DISPENSING_MODE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getELBInsp_ShiftSearchEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_INSP_SHIFT_SEARCH", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getAVI_Save_ImageTypeEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "AVI_SAVEIMAGE_TYPE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getLineShift_DispensingModeEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "LINE_SHIFT_DISPENSING_MODE", strData, strModelFilePath);

		strData.Format("%.3f", inspSpecPara->getCInkMinWidthSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_CINK_MINWIDTH_SPEC", strData, strModelFilePath);

		strData.Format("%.3f", inspSpecPara->getLineLengthMinThick());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_LINE_LENGTH_MINTHICK", strData, strModelFilePath);

		strData.Format("%.3f", inspSpecPara->getLineLengthSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_LINE_LENGTH_SPEC", strData, strModelFilePath);

		strData.Format("%.3f", inspSpecPara->getCamCenterToCG());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_CAM_CENTERTO_CG", strData, strModelFilePath);

		strData.Format("%.3f", inspSpecPara->getInkUnderflowSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_INK_UNDERFLOW_SPEC", strData, strModelFilePath);

		//HTK 2022-03-16 DummyInspSpec 추가
		strData.Format("%.3f", inspSpecPara->getDummyMinSizeSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_DUMMY_MINSIZE_SPEC", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getFeriAlignFindThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ELB_FERI_ALIGN_FIND_THRESH", strData, strModelFilePath);

		//KJH 2022-02-05 Metal Over flow Margin
		strData.Format("%.3f", inspSpecPara->getMetalOverflowMargin());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "METAL_OVERFLOW_MARGIN", strData, strModelFilePath);

		//KJH 2022-04-09 PN 반지름 비교 검사 추가
		strData.Format("%d", inspSpecPara->getPNSizeInspEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "PN_SIZE_INSP_ENABLE", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getPNSizeSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "PN_SIZE_SPEC", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getPNSizeSpecTorr());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "PN_SIZE_SPEC_TORR", strData, strModelFilePath);
		
		// KBJ 2022-09-05 Rotate 파라미터 추가
		strData.Format("%.4f", inspSpecPara->getRotateC_Spec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ROTATE_CENTER_SPEC", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getRotateC_binary_value());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ROTATE_CENTER_BINARY", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getRotateC_light_value());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ROTATE_CENTER_LIGHT", strData, strModelFilePath);

		//KJH 2022-04-29 MincountCheckInsp 추가
		//KJH 2022-05-09 Mincount 상시 사용으로 변경
		//strData.Format("%d", inspSpecPara->getMinCountCheckInspModeEnable());
		//::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "MIN_COUNT_CHECK_INSP_MODE", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getMinCountCheckInspContinueCount());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "MIN_COUNT_CHECK_INSP_CONTINUE_COUNT", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getMinCountCheckInspTotalCount());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "MIN_COUNT_CHECK_INSP_TOTAL_COUNT", strData, strModelFilePath);

		//KJH 2022-05-09 R Judge 사용 유무 추가
		strData.Format("%d", inspSpecPara->getWetoutRJudgeModeEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "WETOUT_R_SPEC_JUDGE_MODE", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getWetoutRMinSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "WETOUT_R_MINSPEC", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getWetoutRMaxSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "WETOUT_R_MAXSPEC", strData, strModelFilePath);

		//KJH 2022-05-25 BM In <-> Cink In Insp 추가
		strData.Format("%d", inspSpecPara->getWetoutBJudgeModeEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "WETOUT_B_SPEC_JUDGE_MODE", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getWetoutBMinSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "WETOUT_B_MINSPEC", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getWetoutBMaxSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "WETOUT_B_MAXSPEC", strData, strModelFilePath);

		strData.Format("%.3f", inspSpecPara->getLineLengthFDC_Distance());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "LINE_FDC_DISTANCE", strData, strModelFilePath);

		//SJB 2022-11-11 Overflow Min 파라미터 추가
		strData.Format("%.3f", inspSpecPara->getLineOverflowMinSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "LINE_OVERFLOW_MINSPEC", strData, strModelFilePath);

		//SJB 2022-11-19 CG Exposure Time 파라미터 추가
		strData.Format("%d", inspSpecPara->getCGGrabExposure());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "CG_GRAB_EXPOSURE", strData, strModelFilePath);

		//HTK 2022-06-29 Wetout Min,Max Judge 사용유무 추가
		strData.Format("%d", inspSpecPara->getWetoutMinMaxJudgeModeEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "WETOUT_MINMAX_SPEC_JUDGE_MODE", strData, strModelFilePath);

		//KJH 2022-04-29 ELB CENTER ALIGN LIVE VIEW 가이드 라인 그리기 추가
		strData.Format("%.3f", inspSpecPara->getCenterLiveViewGuideLineOffset());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "CENTER_LIVE_GUIDE_LINE_OFFSET", strData, strModelFilePath);

		//HTK 2022-06-29 Nozzle Align Y Recalc
		strData.Format("%d", inspSpecPara->getCenterNozzleYAlignRecalc());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "CENTER_NOZZLE_ALIGN_Y_RECALC", strData, strModelFilePath);

		// KBJ 2022-12-06 Side Nozzle Align Z Recalc
		strData.Format("%d", inspSpecPara->getSideNozzleZAlignRecalc());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "SIDE_NOZZLE_ALIGN_Z_RECALC", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getCenterNozzleAlignMethod());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "CENTER_NOZZLE_ALIGN_METHOD", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getCenterNozzleToPanelDistanceLight());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "CENTER_NOZZLE_O_DIST_LIGHT", strData, strModelFilePath);

		//HTK 2022-07-12 Nozzel#45에 약액상태 검사 추가
		strData.Format("%.3f", inspSpecPara->get45DegreeInkInspThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "CENTER_45_INK_INSP_THRESH", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->get45DegreeInkInspEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "CENTER_45_INK_INSP_ENABLE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->get45DegreenStartDelay());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "CENTER_45_INK_START_DELAY", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->get45DegreenIntervalDelay());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "CENTER_45_INK_INTERVAL_DELAY", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getUseCenterNozzleYLight());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "CENTER_USE_YGAP_LIGHT", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getNozzleYGapThreshold());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "NOZZLE_YGAP_THRESHOLD", strData, strModelFilePath);

		// blue 2022.09.02 CINK1+CINK2(EGL)에서 wetout 계산시 GlassEdge 대신 MetalEdge 사용(F=기존 GlassEdge 사용)
		strData.Format("%d", inspSpecPara->getCalcWetoutMetalEdge());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_CALC_WETOUT_METALEDGE", strData, strModelFilePath);

		strData.Format("%d", inspSpecPara->getWetoutInspectionSimulation());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_WETOUT_INSP_SIMULATION", strData, strModelFilePath);		

		// blue 2022.09.09
		strData.Format("%d", inspSpecPara->getDiffRoiMergeEnable());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "ENABLE_DIFF_ROI_MERGE", strData, strModelFilePath);

		// SJB 2022-10-03 Scratch Parameter
		strData.Format("%d", inspSpecPara->getScratchCheck());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "SCRATCH_INSP_ENABLE", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getScratchThresh());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "SCRATCH_INSP_THRESH", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getScratchMaskingRadius());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "SCRATCH_MASKING_RADIUS", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getScratchInspSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "SCRATCH_INSP_SPEC", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getScratchInspAreaSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "SCRATCH_INSP_AREA_SPEC", strData, strModelFilePath);

		// YCS 2022-10-31 필름 유무검사 영역 사이즈 고정
		strData.Format("%d", inspSpecPara->getFixedFilmReattachUse());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FIXED_FILM_REATTACH_USE", strData, strModelFilePath);
		strData.Format("%.3f", inspSpecPara->getFixedFilmReattachSize());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FIXED_FILM_REATTACH_SIZE", strData, strModelFilePath);

		// YCS 2022-11-19 필름얼라인 각도 비교 스펙 파라미터 분리
		strData.Format("%.3f", inspSpecPara->getFilmAngleSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_ANGLE_COMPARE_SPEC", strData, strModelFilePath);
		strData.Format("%d", inspSpecPara->getFilmAngleInspectionUse());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "FILM_ANGLE_COMPARE_USE", strData, strModelFilePath);

		// YCS 2022-12-01 Wetout_ASPC 스펙 추가
		strData.Format("%.3f", inspSpecPara->getWetoutASPCSpec());
		::WritePrivateProfileStringA("INSP_PARAMETER_INFO", "WETOUT_ASPC_SPEC", strData, strModelFilePath);
    }
	catch (...)
	{
		bSuccess = FALSE;
	}
	return bSuccess;
}
BOOL CLET_AlignClientDlg::readPanelExistInfoData(CPanelExistInfo *panelExistInfo, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		TCHAR cData[MAX_PATH];
		CRect rect;
		CString strData, strKey;
		CString strModelFilePath = strModelPath + "\\PanelExistInfo.ini";


		CFileFind findFile;
		if (findFile.FindFile(strModelFilePath) != TRUE)	return bSuccess;

		CRect rcROI;
		for (int nChip = 0; nChip < MAX_PANEL; nChip++)
		{
			////////// Avg Gray Limit
			strKey.Format("AVG_GRAY_LIMIT%d", nChip + 1);
			::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "35.0", cData, MAX_PATH, strModelFilePath);
			panelExistInfo->setAvgGrayLimit(nChip, atof(cData));

			//////// Search ROI
			strKey.Format("SEARCH_ROI_LEFT%d", nChip + 1);
			::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
			rcROI.left = atoi(cData);

			strKey.Format("SEARCH_ROI_TOP%d", nChip + 1);
			::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
			rcROI.top = atoi(cData);

			strKey.Format("SEARCH_ROI_RIGHT%d", nChip + 1);
			::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
			rcROI.right = atoi(cData);

			strKey.Format("SEARCH_ROI_BOTTOM%d", nChip + 1);
			::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
			rcROI.bottom = atoi(cData);

			panelExistInfo->setSearchROI(nChip, rcROI);

			///// Panel Valid Position
			strKey.Format("PANEL_VALID_POS_LEFT%d", nChip + 1);
			::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
			panelExistInfo->setPanelValidPosLeft(nChip, atof(cData));

			strKey.Format("PANEL_VALID_POS_TOP%d", nChip + 1);
			::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
			panelExistInfo->setPanelValidPosTop(nChip, atof(cData));

			strKey.Format("PANEL_VALID_POS_RIGHT%d", nChip + 1);
			::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
			panelExistInfo->setPanelValidPosRight(nChip, atof(cData));

			strKey.Format("PANEL_VALID_POS_BOTTOM%d", nChip + 1);
			::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
			panelExistInfo->setPanelValidPosBottom(nChip, atof(cData));

			for (int nIndex = 0; nIndex < MAX_PATTERN_INDEX; nIndex++)
			{
				strKey.Format("POS_OFFSET_X%d%d", nChip + 1, nIndex + 1);
				::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				panelExistInfo->setPosOffsetX(nChip, nIndex, atof(cData));

				strKey.Format("POS_OFFSET_Y%d%d", nChip + 1, nIndex + 1);
				::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				panelExistInfo->setPosOffsetY(nChip, nIndex, atof(cData));

				strKey.Format("USE_MASK%d%d", nChip + 1, nIndex + 1);
				::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
				panelExistInfo->setUseMask(nChip, nIndex, atoi(cData));
			}
		}

		//
		strKey = "JUDGE_CONDITION";
		::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		panelExistInfo->setJudgeCondition(atoi(cData));

		strKey = "ENABLE_PANEL_VALID_POS_CHECK";
		::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		panelExistInfo->setEnablePanelValidPosCheck(atoi(cData));

		strKey = "ENABLE_EXIST_CHECK_BY_EDGE";
		::GetPrivateProfileStringA("PANEL_EXIST_INFO", strKey, "0", cData, MAX_PATH, strModelFilePath);
		panelExistInfo->setEnableExistCheckByEdge(atoi(cData));

		// Model Data Copy To Object
		for (int nPanel = 0; nPanel < MAX_PANEL; nPanel++)
		{
			GetPanelExist().setAvgGrayLimit(nPanel, panelExistInfo->getAvgGrayLimit(nPanel));
			GetPanelExist().setSearchROI(nPanel, panelExistInfo->getSearchROI(nPanel));

			GetPanelExist().setPanelValidPosLeft(nPanel, panelExistInfo->getPanelValidPosLeft(nPanel));
			GetPanelExist().setPanelValidPosTop(nPanel, panelExistInfo->getPanelValidPosTop(nPanel));
			GetPanelExist().setPanelValidPosRight(nPanel, panelExistInfo->getPanelValidPosRight(nPanel));
			GetPanelExist().setPanelValidPosBottom(nPanel, panelExistInfo->getPanelValidPosBottom(nPanel));
		}

		GetPanelExist().setJudgeCondition(panelExistInfo->getJudgeCondition());
	}
	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}
BOOL CLET_AlignClientDlg::savePanelExistInfoData(CPanelExistInfo *panelExistInfo, CString strModelPath)
{
	BOOL bSuccess = TRUE;

	try {
		CString strData, strKey;
		CString strModelFilePath = strModelPath + "\\PanelExistInfo.ini";

		strKey.Format("MODEL_PATH");
		::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strModelFilePath, strModelFilePath);

		GetPanelExist().setNumPanelInTray(4);

		// Data Copy
		for (int nPanel = 0; nPanel < GetPanelExist().getNumPanelInTray(); nPanel++)
		{
			panelExistInfo->setAvgGrayLimit(nPanel, GetPanelExist().getAvgGrayLimit(nPanel));
			panelExistInfo->setSearchROI(nPanel, GetPanelExist().getSearchROI(nPanel));

			panelExistInfo->setPanelValidPosLeft(nPanel, GetPanelExist().getPanelValidPosLeft(nPanel));
			panelExistInfo->setPanelValidPosTop(nPanel, GetPanelExist().getPanelValidPosTop(nPanel));
			panelExistInfo->setPanelValidPosRight(nPanel, GetPanelExist().getPanelValidPosRight(nPanel));
			panelExistInfo->setPanelValidPosBottom(nPanel, GetPanelExist().getPanelValidPosBottom(nPanel));
		}

		panelExistInfo->setJudgeCondition(GetPanelExist().getJudgeCondition());

		for (int nPanel = 0; nPanel < GetPanelExist().getNumPanelInTray(); nPanel++)
		{
			if (nPanel >= MAX_PANEL) continue;

			strData.Format("%.1f", GetPanelExist().getAvgGrayLimit(nPanel));
			strKey.Format("AVG_GRAY_LIMIT%d", nPanel + 1);
			::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);
		}

		for (int nPanel = 0; nPanel < GetPanelExist().getNumPanelInTray(); nPanel++)
		{
			if (nPanel >= MAX_PANEL) continue;

			strData.Format("%d", panelExistInfo->getSearchROI(nPanel).left);
			strKey.Format("SEARCH_ROI_LEFT%d", nPanel + 1);
			::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);

			strData.Format("%d", panelExistInfo->getSearchROI(nPanel).top);
			strKey.Format("SEARCH_ROI_TOP%d", nPanel + 1);
			::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);

			strData.Format("%d", panelExistInfo->getSearchROI(nPanel).right);
			strKey.Format("SEARCH_ROI_RIGHT%d", nPanel + 1);
			::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);

			strData.Format("%d", panelExistInfo->getSearchROI(nPanel).bottom);
			strKey.Format("SEARCH_ROI_BOTTOM%d", nPanel + 1);
			::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);
		}

		strData.Format("%d", panelExistInfo->getJudgeCondition());
		strKey = "JUDGE_CONDITION";
		::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);

		for (int nPanel = 0; nPanel < GetPanelExist().getNumPanelInTray(); nPanel++)
		{
			if (nPanel >= MAX_PANEL) continue;

			strData.Format("%.2f", panelExistInfo->getPanelValidPosLeft(nPanel));
			strKey.Format("PANEL_VALID_POS_LEFT%d", nPanel + 1);
			::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);

			strData.Format("%.2f", panelExistInfo->getPanelValidPosTop(nPanel));
			strKey.Format("PANEL_VALID_POS_TOP%d", nPanel + 1);
			::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);

			strData.Format("%.2f", panelExistInfo->getPanelValidPosRight(nPanel));
			strKey.Format("PANEL_VALID_POS_RIGHT%d", nPanel + 1);
			::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);

			strData.Format("%.2f", panelExistInfo->getPanelValidPosBottom(nPanel));
			strKey.Format("PANEL_VALID_POS_BOTTOM%d", nPanel + 1);
			::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);
		}

		for (int nPanel = 0; nPanel < GetPanelExist().getNumPanelInTray(); nPanel++)
		{
			if (nPanel >= MAX_PANEL) continue;

			for (int nIndex = 0; nIndex < MAX_PATTERN_INDEX; nIndex++)
			{
				strData.Format("%.1f", panelExistInfo->getPosOffsetX(nPanel, nIndex));
				strKey.Format("POS_OFFSET_X%d%d", nPanel + 1, nIndex + 1);
				::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);

				strData.Format("%.1f", panelExistInfo->getPosOffsetY(nPanel, nIndex));
				strKey.Format("POS_OFFSET_Y%d%d", nPanel + 1, nIndex + 1);
				::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);
			}
		}

		for (int nPanel = 0; nPanel < GetPanelExist().getNumPanelInTray(); nPanel++)
		{
			if (nPanel >= MAX_PANEL) continue;

			for (int nIndex = 0; nIndex < MAX_PATTERN_INDEX; nIndex++)
			{
				strData.Format("%d", panelExistInfo->getUseMask(nPanel, nIndex));
				strKey.Format("USE_MASK%d%d", nPanel + 1, nIndex + 1);
				::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);
			}
		}

		strData.Format("%d", panelExistInfo->getEnablePanelValidPosCheck());
		strKey = "ENABLE_PANEL_VALID_POS_CHECK";
		::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);

		strData.Format("%d", panelExistInfo->getEnableExistCheckByEdge());
		strKey = "ENABLE_EXIST_CHECK_BY_EDGE";
		::WritePrivateProfileStringA("PANEL_EXIST_INFO", strKey, strData, strModelFilePath);

	}

	catch (...)
	{
		bSuccess = FALSE;
	}

	return bSuccess;
}
void CLET_AlignClientDlg::save_result_image_nozzle_xy(BYTE *pImage, BOOL bJudge, int nJob, int nCam)
{
	CString strImageDir, str;
	CString strTime, str_modelID, str_algo, str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[nJob].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID  \\ JOB이름 \\ OK/NG   \\ PanelID \\ 변경전
	///  D:\\ Result \\ Image \\ 날짜 \\ JOB이름 \\ OK/NG   \\ PanelID \\ 			 변경후

	//날짜
	strTime.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	strImageDir.Format("%s%s", m_strImageDir, strTime);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[nJob].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format(_T("%s"), vt_job_info[nJob].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else if (bJudge)
	{
		strImageDir.Format("%s\\OK", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		strImageDir.Format("%s\\NG", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}

	//PanelID
	//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
	if (strlen(vt_job_info[nJob].main_object_id.c_str()) <= 13)
	{
		strImageDir.Format("%s\\Not Exist Panel ID", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	strImageDir.Format("%s\\%s", strImageDir, vt_job_info[nJob].main_object_id.c_str());
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//이미지저장 시간
	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);


	int real_cam = vt_job_info[nJob].camera_index[nCam];

	if (strlen(vt_job_info[nJob].main_object_id.c_str()) <= 13)
	{
		//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
		str.Format("%s\\NO_NAME_%s_%s_Img.%s", strImageDir,		// 이미지 저장 디렉토리
			strTime,											// 시간
			m_stCamInfo[real_cam].cName,						// 카메라 이름
			str_ImageType);										// Image Type
	}
	else
	{
		//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
		str.Format("%s\\%s_%s_%s_Img.%s", strImageDir,		// 이미지 저장 디렉토리
			vt_job_info[nJob].main_object_id.c_str(),		// 모델이름
			strTime,										// 시간
			m_stCamInfo[real_cam].cName,						// 카메라 이름
			str_ImageType);										// Image Type
	}

	char raw_image_path[1024] = { 0, };
	char result_image_path[1024] = { 0, };

	sprintf(result_image_path, "%s", (LPCTSTR)str);

	//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
	if (strlen(vt_job_info[nJob].main_object_id.c_str()) <= 13)
	{
		//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
		str.Format("%s\\NO_NAME_%s_%s_ImgRaw.%s", strImageDir,		// 이미지 저장 디렉토리
			strTime,												// 시간
			m_stCamInfo[real_cam].cName,						// 카메라 이름
			str_ImageType);										// Image Type
	}
	else
	{
		//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
		str.Format("%s\\%s_%s_%s_ImgRaw.%s", strImageDir,			// 이미지 저장 디렉토리
			vt_job_info[nJob].main_object_id.c_str(),				// 모델이름
			strTime,												// 시간
			m_stCamInfo[real_cam].cName,						// 카메라 이름
			str_ImageType);										// Image Type
	}
	sprintf(raw_image_path, "%s", (LPCTSTR)str);

	int w = vt_job_info[nJob].camera_size[nCam].x;
	int h = vt_job_info[nJob].camera_size[nCam].y;
	cv::Mat img(h, w, CV_8UC1, pImage);
	cv::Mat color_img;
	cv::cvtColor(img, color_img, cv::COLOR_GRAY2BGR);

	cv::imwrite(raw_image_path, img);

	CvFont font;
	font = cvFont(2, 2);
	font.thickness = 1;
	font.vscale = (float)0.2;

	CString str_temp;
	CvPoint pt;
	pt.x = 100;
	pt.y = 100;

	str_temp.Format("y : %.3f", vt_result_info[nJob].revision_data[nCam][2]);
	if (bJudge)
	{
		double pos_x = vt_result_info[nJob].revision_data[nCam][0];
		double pos_y = vt_result_info[nJob].revision_data[nCam][0];

		cv::line(color_img, cv::Point(pos_x - 30, pos_y), cv::Point(pos_x + 30, pos_y), cv::Scalar(0, 255, 0), 1);
		cv::line(color_img, cv::Point(pos_x, pos_y - 30), cv::Point(pos_x, pos_y + 30), cv::Scalar(0, 255, 0), 1);
		cv::putText(color_img, std::string(str_temp), pt, cv::FONT_ITALIC, 1, cv::Scalar(0, 255, 0), 3);
	}
	else		cv::putText(color_img, std::string("NG"), pt, cv::FONT_ITALIC, 1, cv::Scalar(0, 0, 255), 3);


	cv::imwrite(result_image_path, color_img);

	color_img.release();
}
void CLET_AlignClientDlg::save_result_image_nozzle_gap(BYTE *pImage, BOOL bJudge, int nJob, int nCam, double m_dCGThickness)
{
	CString strImageDir, strFileDir, str;
	CString strDate, strTime, str_modelID, str_algo, str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[nJob].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID  \\ JOB이름 \\ OK/NG   \\ PanelID \\ 변경전
	//KJH 2022-05-19 Z Gap Insp result File 생성
	///////////////////////////////////// Data 저장 폴더
	///  D:\\ Result \\ Files \\ 날짜 \\ 모델ID  \\ JOB이름 \\ OK/NG   \\ PanelID \\ 변경전
	/*
	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_Result_%s.csv", strFileDir, algo_name, Date_str);
	*/
	
	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	//날짜
	strDate.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	strImageDir.Format("%s%s", m_strImageDir, strDate);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	strFileDir.Format("%s%s", strFileDir, strDate);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[nJob].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	strFileDir.Format("%s\\%s", strFileDir, str_modelID);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	//JOB이름
	str_algo.Format(_T("%s"), vt_job_info[nJob].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	strFileDir.Format("%s\\%s", strFileDir, str_algo);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	// YCS 2022-11-30 시간폴더 추가. 시뮬레이션인 경우 시간폴더 생성하지 않음
	//이미지저장 시간
	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
	if (!m_bSimulationStart)
	{
		strImageDir.Format("%s\\%s", strImageDir, strTime);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else if (bJudge)
	{
		strImageDir.Format("%s\\OK", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		strImageDir.Format("%s\\NG", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}

	////PanelID
	////KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
	//if (strlen(vt_job_info[nJob].main_object_id.c_str()) <= 13)
	//{
	//	strImageDir.Format("%s\\Not Exist Panel ID", strImageDir);
	//	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	//}
	//strImageDir.Format("%s\\%s", strImageDir, vt_job_info[nJob].main_object_id.c_str());
	//if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	strFileDir.Format("%s\\%s_ZGap_Result.csv", strFileDir, strDate);

	//이미지저장 시간
	//strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);


	int real_cam = vt_job_info[nJob].camera_index[nCam];

	//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
	str.Format("%s\\%s_%s_Img.%s",		strImageDir,						// 이미지 저장 디렉토리
										strTime,							// 시간
										m_stCamInfo[real_cam].cName,						// 카메라 이름
										str_ImageType);										// Image Type

	char raw_image_path[1024] = { 0, };
	char result_image_path[1024] = { 0, };

	sprintf(result_image_path, "%s", (LPCTSTR)str);

	//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
	str.Format("%s\\%s_%s_ImgRaw.%s",	strImageDir,						// 이미지 저장 디렉토리
										strTime,							// 시간
										m_stCamInfo[real_cam].cName,						// 카메라 이름
										str_ImageType);										// Image Type

	sprintf(raw_image_path, "%s", (LPCTSTR)str);

#pragma	region Image Log 저장

	int w = vt_job_info[nJob].camera_size[nCam].x;
	int h = vt_job_info[nJob].camera_size[nCam].y;
	cv::Mat img(h, w, CV_8UC1, pImage);
	cv::Mat color_img;
	cv::cvtColor(img, color_img, cv::COLOR_GRAY2BGR);

	cv::imwrite(raw_image_path, img);

	CvFont font;
	font = cvFont(2, 2);
	font.thickness = 1;
	font.vscale = (float)0.2;

	double pos_x = vt_result_info[nJob].revision_data[nCam][0];
	double pos_y = vt_result_info[nJob].revision_data[nCam][1];
	double _offset = vt_job_info[nJob].model_info.getInspSpecParaInfo().getNozzleToStageGapOffset();

	CString str_temp;
	CvPoint pt;
	pt.x = (int)pos_x + 50;
	pt.y = (int)pos_y;

	str_temp.Format("Z : %.4fum, Original : %.4fum", vt_result_info[nJob].revision_data[nCam][2], vt_result_info[nJob].revision_data[nCam][2] - _offset);
	if (bJudge)
	{
		cv::line(color_img, cv::Point(pos_x - 30, pos_y), cv::Point(pos_x + 30, pos_y), cv::Scalar(0, 255, 0), 1);
		cv::line(color_img, cv::Point(pos_x, pos_y - 30), cv::Point(pos_x, pos_y + 30), cv::Scalar(0, 255, 0), 1);
		cv::line(color_img, cv::Point(0, h/2), cv::Point(w, h/2), cv::Scalar(0, 255, 0), 1);
		cv::line(color_img, cv::Point(0, (h/2)+ _offset), cv::Point(w, (h/2)+ _offset), cv::Scalar(0, 0, 255), 1);
		cv::putText(color_img, std::string(str_temp), pt, cv::FONT_ITALIC, 2, cv::Scalar(0, 255, 0), 3);
	}
	else		cv::putText(color_img, std::string("NG"), pt, cv::FONT_ITALIC, 2, cv::Scalar(0, 0, 255), 3);

	cv::imwrite(result_image_path, color_img);

	color_img.release();

#pragma	endregion

#pragma	region Data Log 저장

	CString strTemp;

	BOOL bNew = FALSE;
	if (_access(strFileDir, 0) != 0) bNew = TRUE;

	CFile file;
	if (file.Open(strFileDir, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate) != TRUE)
	{

	}
	else
	{
		file.SeekToEnd();

		if (bNew)
		{
			strTemp = "DATE,TIME,Z Gap,Orignal,CG_Target\r\n";
			file.Write(strTemp, strTemp.GetLength());
		}

		strTemp.Format("%s,%s,%.4f,%.4f,%.4f\r\n", strDate, strTime, vt_result_info[nJob].revision_data[nCam][2], vt_result_info[nJob].revision_data[nCam][2] - _offset, m_dCGThickness);

		file.Write(strTemp, strTemp.GetLength());
		file.Close();
	}

#pragma	endregion

}
void CLET_AlignClientDlg::save_result_image_ELB_center_align(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, str;
	CString strTime, str_modelID, str_algo, strDate, str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[algo].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	CString stage = "NULL";
	if (m_nClientID == 3)	stage = "A1";
	else if (m_nClientID == 4)	stage = "A2";
	else if (m_nClientID == 5)	stage = "B1";
	else if (m_nClientID == 6)	stage = "B2";



	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ JOB이름 \\ Align \\ OK/NG \\ PanelID 

	// KBJ 2022-02-23 changed strTime
	//이미지저장 시간
	if (m_strResultTime[algo].IsEmpty())	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
	else									strTime.Format("%s", m_strResultTime[algo]);

	//날짜
	if (m_strResultDate[algo].IsEmpty())	strDate.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	else									strDate.Format("%s", m_strResultDate[algo]);
	strImageDir.Format("%s%s", m_strImageDir, strDate);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format(_T("%s"), vt_job_info[algo].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//Align
	strImageDir.Format("%s\\Align", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		if (bJudge)
		{
			strImageDir.Format("%s\\OK", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
		else
		{
			strImageDir.Format("%s\\NG", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
	}

	//PanelID
	//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
	if (strlen(vt_job_info[algo].main_object_id.c_str()) <= 13)
	{
		strImageDir.Format("%s\\Not Exist Panel ID\\", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}

	// KBJ 2022-02-23 If panel_id of memoried is same current panel_id that divide folder_name to time.
	strImageDir.Format("%s\\%s", strImageDir, vt_job_info[algo].main_object_id.c_str());
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	else
	{
		strImageDir.Format("%s_%s", strImageDir, strTime);
		if (_access(strImageDir, 0) != 0) CreateDirectory(strImageDir, NULL);
	}

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int nCam = 0;
	int real_cam = 0;

	for (nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		int index = m_nSaveImageRingBufIndex[algo][nCam];

		index = m_nSaveImageRingBufIndex[algo][nCam];

		//KJH 2021-08-14 Caliper 4개로 Display 이미지 저장용
		int Max_nPos = vt_job_info[algo].num_of_position;

		if (vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_1SHOT_ALIGN ||
			vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_1SHOT_FILM ||
			vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP)

		{
			m_stSaveImageInfo[algo][nCam][index].bUsing1Cam = TRUE;
			m_stSaveImageInfo[algo][nCam][index].nNumPos = Max_nPos;

			//KJH 2021-08-14 Caliper 4개로 Display 이미지 저장용
			for (int i = 0; i < Max_nPos; i++)
			{
				if (i < 2)
				{
					m_stSaveImageInfo[algo][nCam][index].line[2 * i] = GetMatching(algo).getFindInfo(nCam, i).GetLine(0);
					m_stSaveImageInfo[algo][nCam][index].line[2 * i + 1] = GetMatching(algo).getFindInfo(nCam, i).GetLine(1);
					m_stSaveImageInfo[algo][nCam][index].bFindline[2 * i] = GetMatching(algo).getFindInfo(nCam, i).GetFindline(0);
					m_stSaveImageInfo[algo][nCam][index].bFindline[2 * i + 1] = GetMatching(algo).getFindInfo(nCam, i).GetFindline(1);
				}

				for (int j = 0; j < 4; j++)
				{
					m_stSaveImageInfo[algo][nCam][index].dLineX[i][j] = GetMatching(algo).getFindInfo(nCam, i).GetLineX(j);
					m_stSaveImageInfo[algo][nCam][index].dLineY[i][j] = GetMatching(algo).getFindInfo(nCam, i).GetLineY(j);
				}
			}
		}
		else
		{
			m_stSaveImageInfo[algo][nCam][index].bUsing1Cam = FALSE;
			m_stSaveImageInfo[algo][nCam][index].nNumPos = 1;
			m_stSaveImageInfo[algo][nCam][index].line[0] = GetMatching(algo).getFindInfo(nCam, 0).GetLine(0);
			m_stSaveImageInfo[algo][nCam][index].line[1] = GetMatching(algo).getFindInfo(nCam, 0).GetLine(1);
			m_stSaveImageInfo[algo][nCam][index].bFindline[0] = GetMatching(algo).getFindInfo(nCam, 0).GetFindline(0);
			m_stSaveImageInfo[algo][nCam][index].bFindline[1] = GetMatching(algo).getFindInfo(nCam, 0).GetFindline(1);

			for (int j = 0; j < 4; j++)
			{
				m_stSaveImageInfo[algo][nCam][index].dLineX[0][j] = GetMatching(algo).getFindInfo(nCam, 0).GetLineX(j);
				m_stSaveImageInfo[algo][nCam][index].dLineY[0][j] = GetMatching(algo).getFindInfo(nCam, 0).GetLineY(j);
			}
		}

		m_stSaveImageInfo[algo][nCam][index].b4Align = vt_job_info[algo].model_info.getAlignInfo().getUse4PointAlign();
		m_stSaveImageInfo[algo][nCam][index].dPosX[0] = GetMatching(algo).getFindInfo(nCam, 0).GetXPos();
		m_stSaveImageInfo[algo][nCam][index].dPosY[0] = GetMatching(algo).getFindInfo(nCam, 0).GetYPos();
		m_stSaveImageInfo[algo][nCam][index].nFound[0] = GetMatching(algo).getFindInfo(nCam, 0).GetFound();
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_X] = m_dbRevisionData[algo][AXIS_X];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Y] = m_dbRevisionData[algo][AXIS_Y];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_T] = m_dbRevisionData[algo][AXIS_T];
		m_stSaveImageInfo[algo][nCam][index].bJudge = bJudge;
		m_stSaveImageInfo[algo][nCam][index].nRetry = m_nRetryCount[algo] - 1;
		m_stSaveImageInfo[algo][nCam][index].bFinal = bRetryEnd;
		m_stSaveImageInfo[algo][nCam][index].nAlgorithm = algo;
		m_stSaveImageInfo[algo][nCam][index].nCam = nCam;
		m_stSaveImageInfo[algo][nCam][index].bLcheckNG = m_bLcheckNG[algo];

		//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
		if (strlen(vt_job_info[algo].main_object_id.c_str()) <= 13)
		{
			str.Format("%s\\NO_NAME_%s_%s.%s", strImageDir,		// 이미지 저장 디렉토리
				strTime,												// 시간
				m_stCamInfo[real_cam].cName,					// 카메라 이름
				str_ImageType);									// 이미지 확장자
		}
		else
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\%s_%s_%s_Img.%s", strImageDir,		// 이미지 저장 디렉토리
				strTime,										// 시간
				vt_job_info[algo].main_object_id.c_str(),		// 모델이름
				m_stCamInfo[real_cam].cName,					// 카메라 이름
				str_ImageType);									// 이미지 확장자
		}

		copyMemory(getSaveImageBuffer(real_cam, index), getProcBuffer(real_cam, 0), W * H);
		sprintf(m_cSaveImageRingBufPath[algo][nCam][index], "%s", (LPCTSTR)str);

		//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
		if (strlen(vt_job_info[algo].main_object_id.c_str()) <= 13)
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\NO_NAME_%s_%s_ImgRaw.%s", strImageDir,		// 이미지 저장 디렉토리
				strTime,												// 시간
				m_stCamInfo[real_cam].cName,					// 카메라 이름
				str_ImageType);									// 이미지 확장자
		}
		else
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\%s_%s_%s_ImgRaw.%s", strImageDir,			// 이미지 저장 디렉토리
				vt_job_info[algo].main_object_id.c_str(),				// 모델이름
				strTime,												// 시간
				m_stCamInfo[real_cam].cName,					// 카메라 이름
				str_ImageType);									// 이미지 확장자
		}
		sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index], "%s", (LPCTSTR)str);

		m_nSaveImageRingBufIndex[algo][nCam] = (m_nSaveImageRingBufIndex[algo][nCam] + 1) % MAX_SAVE_IMAGE_RING_BUF;
	}
}
void CLET_AlignClientDlg::SaveResultImageINFRA_Align(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, str;
	CString strTime, str_modelID, str_algo, strDate, str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[algo].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	//CString stage = "NULL";
	//if	  (m_nClientID == 3)	stage = "A1";
	//else if (m_nClientID == 4)	stage = "A2";
	//else if (m_nClientID == 5)	stage = "B1";
	//else if (m_nClientID == 6)	stage = "B2";

	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID  \\ JOB이름 \\ OK/NG   \\ PanelID \\

	// KBJ 2022-02-23 changed strTime
	//이미지저장 시간
	if (m_strResultTime[algo].IsEmpty())	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
	else									strTime.Format("%s", m_strResultTime[algo]);

	//날짜
	if (m_strResultDate[algo].IsEmpty())	strDate.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	else									strDate.Format("%s", m_strResultDate[algo]);

	strImageDir.Format("%s%s", m_strImageDir, strDate);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	
	//모델ID
	str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format(_T("%s"), vt_job_info[algo].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		if (bJudge)
		{
			strImageDir.Format("%s\\OK", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
		else
		{
			strImageDir.Format("%s\\NG", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
	}

	//PanelID
	//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
	if (strlen(vt_job_info[algo].main_object_id.c_str()) <= 13)
	{
		strImageDir.Format("%s\\Not Exist Panel ID\\", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}

	// KBJ 2022-02-23 If panel_id of memoried is same current panel_id that divide folder_name to time.
	strImageDir.Format("%s\\%s", strImageDir, vt_job_info[algo].main_object_id.c_str());
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	else
	{
		strImageDir.Format("%s_%s", strImageDir, strTime);
		if (_access(strImageDir, 0) != 0) CreateDirectory(strImageDir, NULL);
	}

	//이미지저장 시간
	//strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int nCam = 0;
	int real_cam = 0;

	for (nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		int index = m_nSaveImageRingBufIndex[algo][nCam];

		index = m_nSaveImageRingBufIndex[algo][nCam];
		
		//KJH 2021-08-14 Caliper 4개로 Display 이미지 저장용
		int Max_nPos = vt_job_info[algo].num_of_position;

		if (vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_1SHOT_ALIGN||
			vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_1SHOT_FILM ||
			vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP)
		{
			m_stSaveImageInfo[algo][nCam][index].bUsing1Cam		= TRUE;
			m_stSaveImageInfo[algo][nCam][index].nNumPos		= Max_nPos;
			
			//KJH 2021-08-14 Caliper 4개로 Display 이미지 저장용
			for (int i = 0; i < Max_nPos; i++)
			{
				if(i < 2)
				{
					m_stSaveImageInfo[algo][nCam][index].line[2 * i]			= GetMatching(algo).getFindInfo(nCam, i).GetLine(0);
					m_stSaveImageInfo[algo][nCam][index].line[2 * i + 1]		= GetMatching(algo).getFindInfo(nCam, i).GetLine(1);
					m_stSaveImageInfo[algo][nCam][index].bFindline[2 * i]		= GetMatching(algo).getFindInfo(nCam, i).GetFindline(0);
					m_stSaveImageInfo[algo][nCam][index].bFindline[2 * i + 1]	= GetMatching(algo).getFindInfo(nCam, i).GetFindline(1);
				}

				for (int j = 0; j < 4; j++)
				{
					m_stSaveImageInfo[algo][nCam][index].dLineX[i][j]			= GetMatching(algo).getFindInfo(nCam, i).GetLineX(j);
					m_stSaveImageInfo[algo][nCam][index].dLineY[i][j]			= GetMatching(algo).getFindInfo(nCam, i).GetLineY(j);
				}
			}
		}
		else
		{
			m_stSaveImageInfo[algo][nCam][index].bUsing1Cam						= FALSE;
			m_stSaveImageInfo[algo][nCam][index].nNumPos						= 1;
			m_stSaveImageInfo[algo][nCam][index].line[0]						= GetMatching(algo).getFindInfo(nCam, 0).GetLine(0);
			m_stSaveImageInfo[algo][nCam][index].line[1]						= GetMatching(algo).getFindInfo(nCam, 0).GetLine(1);
			m_stSaveImageInfo[algo][nCam][index].bFindline[0]					= GetMatching(algo).getFindInfo(nCam, 0).GetFindline(0);
			m_stSaveImageInfo[algo][nCam][index].bFindline[1]					= GetMatching(algo).getFindInfo(nCam, 0).GetFindline(1);
			
			for (int j = 0; j < 4; j++)
			{
				m_stSaveImageInfo[algo][nCam][index].dLineX[0][j]				= GetMatching(algo).getFindInfo(nCam, 0).GetLineX(j);
				m_stSaveImageInfo[algo][nCam][index].dLineY[0][j]				= GetMatching(algo).getFindInfo(nCam, 0).GetLineY(j);
			}
		}

		m_stSaveImageInfo[algo][nCam][index].b4Align							= vt_job_info[algo].model_info.getAlignInfo().getUse4PointAlign();
		m_stSaveImageInfo[algo][nCam][index].dPosX[0]							= GetMatching(algo).getFindInfo(nCam, 0).GetXPos();
		m_stSaveImageInfo[algo][nCam][index].dPosY[0]							= GetMatching(algo).getFindInfo(nCam, 0).GetYPos();
		m_stSaveImageInfo[algo][nCam][index].nFound[0]							= GetMatching(algo).getFindInfo(nCam, 0).GetFound();
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_X]					= m_dbRevisionData[algo][AXIS_X];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Y]					= m_dbRevisionData[algo][AXIS_Y];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_T]					= m_dbRevisionData[algo][AXIS_T];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Z]					= m_dbRevisionData[algo][AXIS_Z];
		m_stSaveImageInfo[algo][nCam][index].bJudge								= bJudge;
		m_stSaveImageInfo[algo][nCam][index].nRetry								= m_nRetryCount[algo] - 1;
		m_stSaveImageInfo[algo][nCam][index].bFinal								= bRetryEnd;
		m_stSaveImageInfo[algo][nCam][index].nAlgorithm							= algo;
		m_stSaveImageInfo[algo][nCam][index].nCam = nCam;
		m_stSaveImageInfo[algo][nCam][index].bLcheckNG							= m_bLcheckNG[algo];

		//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
		if (strlen(vt_job_info[algo].main_object_id.c_str()) <= 13)
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\NO_NAME_%s_%s_Img.%s", strImageDir,		// 이미지 저장 디렉토리
				strTime,										// 시간
				m_stCamInfo[real_cam].cName,					// 카메라 이름
				str_ImageType);
		}
		else
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\%s_%s_%s_Img.%s", strImageDir,		// 이미지 저장 디렉토리
				vt_job_info[algo].main_object_id.c_str(),		// 모델이름
				strTime,										// 시간
				m_stCamInfo[real_cam].cName,					// 카메라 이름
				str_ImageType);					
		}
		
		copyMemory(getSaveImageBuffer(real_cam, index), getProcBuffer(real_cam, 0), W * H);
		sprintf(m_cSaveImageRingBufPath[algo][nCam][index], "%s", (LPCTSTR)str);

		//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
		if (strlen(vt_job_info[algo].main_object_id.c_str()) <= 13)
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\NO_NAME_%s_%s_ImgRaw.%s", strImageDir,		// 이미지 저장 디렉토리
				strTime,												// 시간
				m_stCamInfo[real_cam].cName,					// 카메라 이름
				str_ImageType);
		}
		else
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\%s_%s_%s_ImgRaw.%s", strImageDir,			// 이미지 저장 디렉토리
				vt_job_info[algo].main_object_id.c_str(),				// 모델이름
				strTime,												// 시간
				m_stCamInfo[real_cam].cName,					// 카메라 이름
				str_ImageType);
		}
		sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index], "%s", (LPCTSTR)str);

		m_nSaveImageRingBufIndex[algo][nCam] = (m_nSaveImageRingBufIndex[algo][nCam] + 1) % MAX_SAVE_IMAGE_RING_BUF;
	}
}
void CLET_AlignClientDlg::SaveResultImageNozzle_XYZ_Insp(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, str;
	CString strTime, str_modelID, str_algo, strDate,str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[algo].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	//CString stage = "NULL";
	//if	  (m_nClientID == 3)	stage = "A1";
	//else if (m_nClientID == 4)	stage = "A2";
	//else if (m_nClientID == 5)	stage = "B1";
	//else if (m_nClientID == 6)	stage = "B2";

	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID  \\ JOB이름 \\ OK/NG \\

	// KBJ 2022-02-23 changed strTime
	//이미지저장 시간
	if (m_strResultTime[algo].IsEmpty())	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
	else									strTime.Format("%s", m_strResultTime[algo]);

	//날짜
	if (m_strResultDate[algo].IsEmpty())	strDate.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	else									strDate.Format("%s", m_strResultDate[algo]);
	strImageDir.Format("%s%s", m_strImageDir, strDate);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format(_T("%s"), vt_job_info[algo].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		if (bJudge)
		{
			strImageDir.Format("%s\\OK", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
		else
		{
			strImageDir.Format("%s\\NG", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
	}

	////PanelID
	////KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
	//if (strlen(vt_job_info[algo].main_object_id.c_str()) <= 13)
	//{
	//	strImageDir.Format("%s\\Not Exist Panel ID\\", strImageDir);
	//	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	//}

	//// KBJ 2022-02-23 If panel_id of memoried is same current panel_id that divide folder_name to time.
	//strImageDir.Format("%s\\%s", strImageDir, vt_job_info[algo].main_object_id.c_str());
	//if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	//else
	//{
	//	strImageDir.Format("%s_%s", strImageDir, strTime);
	//	if (_access(strImageDir, 0) != 0) CreateDirectory(strImageDir, NULL);
	//}

	//이미지저장 시간
	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int nCam = 0;
	int real_cam = 0;

	for (nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		int index = m_nSaveImageRingBufIndex[algo][nCam];

		index = m_nSaveImageRingBufIndex[algo][nCam];

		//KJH 2021-08-14 Caliper 4개로 Display 이미지 저장용
		int Max_nPos = vt_job_info[algo].num_of_position;

		m_stSaveImageInfo[algo][nCam][index].bUsing1Cam = FALSE;
		m_stSaveImageInfo[algo][nCam][index].nNumPos = 1;
		m_stSaveImageInfo[algo][nCam][index].line[0] = GetMatching(algo).getFindInfo(nCam, 0).GetLine(0);
		m_stSaveImageInfo[algo][nCam][index].line[1] = GetMatching(algo).getFindInfo(nCam, 0).GetLine(1);
		m_stSaveImageInfo[algo][nCam][index].bFindline[0] = GetMatching(algo).getFindInfo(nCam, 0).GetFindline(0);
		m_stSaveImageInfo[algo][nCam][index].bFindline[1] = GetMatching(algo).getFindInfo(nCam, 0).GetFindline(1);

		for (int j = 0; j < 4; j++)
		{
			m_stSaveImageInfo[algo][nCam][index].dLineX[0][j] = GetMatching(algo).getFindInfo(nCam, 0).GetLineX(j);
			m_stSaveImageInfo[algo][nCam][index].dLineY[0][j] = GetMatching(algo).getFindInfo(nCam, 0).GetLineY(j);
		}

		double posX = GetMatching(algo).getFindInfo(1, 0).GetXPos();
		double posY = GetMatching(algo).getFindInfo(1, 0).GetYPos();
		double posZ = GetMatching(algo).getFindInfo(0, 0).GetYPos();

		double refX = GetMatching(algo).getRefX(1, 0);
		double refY = GetMatching(algo).getRefY(1, 0);
		double refZ = GetMatching(algo).getRefY(0, 0);

		double xres = GetMachine(algo).getCameraResolutionX(1, 0);
		double yres = GetMachine(algo).getCameraResolutionY(1, 0);
		double zres = GetMachine(algo).getCameraResolutionY(0, 0);

		m_stSaveImageInfo[algo][nCam][index].b4Align = vt_job_info[algo].model_info.getAlignInfo().getUse4PointAlign();
		m_stSaveImageInfo[algo][nCam][index].dPosX[0] = GetMatching(algo).getFindInfo(nCam, 0).GetXPos();
		m_stSaveImageInfo[algo][nCam][index].dPosY[0] = GetMatching(algo).getFindInfo(nCam, 0).GetYPos();
		m_stSaveImageInfo[algo][nCam][index].nFound[0] = GetMatching(algo).getFindInfo(nCam, 0).GetFound();
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_X] = (refX - posX) * xres;
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Y] = (refY - posY) * yres;
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_T] = m_dNozzleCurrentAngle;
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Z] = (refZ - posZ) * zres;
		m_stSaveImageInfo[algo][nCam][index].bJudge = bJudge;
		m_stSaveImageInfo[algo][nCam][index].nRetry = m_nRetryCount[algo] - 1;
		m_stSaveImageInfo[algo][nCam][index].bFinal = bRetryEnd;
		m_stSaveImageInfo[algo][nCam][index].nAlgorithm = algo;
		m_stSaveImageInfo[algo][nCam][index].nCam = nCam;
		m_stSaveImageInfo[algo][nCam][index].bLcheckNG = m_bLcheckNG[algo];

		//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
		str.Format("%s\\%s_%s_Img.%s", strImageDir,				// 이미지 저장 디렉토리
			strTime,											// 시간
			m_stCamInfo[real_cam].cName,						// 카메라 이름
			str_ImageType);										// Image Type

		copyMemory(getSaveImageBuffer(real_cam, index), getProcBuffer(real_cam, 0), W * H);
		sprintf(m_cSaveImageRingBufPath[algo][nCam][index], "%s", (LPCTSTR)str);

		//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
		str.Format("%s\\%s_%s_ImgRaw.%s", strImageDir,			// 이미지 저장 디렉토리
			strTime,												// 시간
			m_stCamInfo[real_cam].cName,						// 카메라 이름
			str_ImageType);										// Image Type

		sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index], "%s", (LPCTSTR)str);

		m_nSaveImageRingBufIndex[algo][nCam] = (m_nSaveImageRingBufIndex[algo][nCam] + 1) % MAX_SAVE_IMAGE_RING_BUF;
	}
}
void CLET_AlignClientDlg::save_result_image_1cam_2object(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, str;
	CString strTime, str_modelID, str_algo, strDate, str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[algo].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	//이미지저장 시간
	if (m_strResultTime[algo].IsEmpty())	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
	else									strTime.Format("%s", m_strResultTime[algo]);

	//날짜
	if (m_strResultDate[algo].IsEmpty())	strDate.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	else									strDate.Format("%s", m_strResultDate[algo]);

	strImageDir.Format("%s%s", m_strImageDir, strDate);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format("%s", vt_job_info[algo].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		if (bJudge)
		{
			// KBJ 2022-09-16
			if (vt_job_info[algo].job_name == "CONV_ALIGN")
			{
				int nAllFind = TRUE;
				if( GetMatching(algo).getFindInfo(0, 0).GetFound() != FIND_OK) nAllFind = FALSE;
				if (GetMatching(algo).getFindInfo(0, 1).GetFound() != FIND_OK) nAllFind = FALSE;
				if (GetMatching(algo).getFindInfo(0, 2).GetFound() != FIND_OK) nAllFind = FALSE;
				if (GetMatching(algo).getFindInfo(0, 3).GetFound() != FIND_OK) nAllFind = FALSE;
				if (nAllFind != TRUE)
				{
					strImageDir.Format("%s\\NG", strImageDir);
					if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
				}
				else
				{
					strImageDir.Format("%s\\OK", strImageDir);
					if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
				}
			}
			else
			{
				strImageDir.Format("%s\\OK", strImageDir);
				if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
			}
		}
		else
		{
			strImageDir.Format("%s\\NG", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
	}

	//PanelID
	strImageDir.Format("%s\\%s", strImageDir, vt_job_info[algo].main_object_id.c_str());
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	//PanelID가 있는경우
	else
	{
		strImageDir.Format("%s_%s", strImageDir, strTime);
		if (_access(strImageDir, 0) != 0) CreateDirectory(strImageDir, NULL);
	}

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int nCam = 0;
	int real_cam = 0;

	for (nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		int index = m_nSaveImageRingBufIndex[algo][nCam];

		index = m_nSaveImageRingBufIndex[algo][nCam];

		m_stSaveImageInfo[algo][nCam][index].bUsing1Cam = TRUE;
		// kbj 2022-01-03 nNumpos changed 8-> 4
		//m_stSaveImageInfo[algo][nCam][index].nNumPos = 8;
		m_stSaveImageInfo[algo][nCam][index].nNumPos = 4;
		//Caliper 8개로 Display 이미지 저장용
		for (int i = 0; i < 4; i++)
		{
			m_stSaveImageInfo[algo][nCam][index].line[2 * i] = GetMatching(algo).getFindInfo(nCam, i).GetLine(0);
			m_stSaveImageInfo[algo][nCam][index].line[2 * i + 1] = GetMatching(algo).getFindInfo(nCam, i).GetLine(1);
			m_stSaveImageInfo[algo][nCam][index].bFindline[2 * i] = GetMatching(algo).getFindInfo(nCam, i).GetFindline(0);
			m_stSaveImageInfo[algo][nCam][index].bFindline[2 * i + 1] = GetMatching(algo).getFindInfo(nCam, i).GetFindline(1);
			m_stSaveImageInfo[algo][nCam][index].dRef_PosX[i] = GetMatching(algo).getRefX(nCam, i);
			m_stSaveImageInfo[algo][nCam][index].dRef_PosY[i] = GetMatching(algo).getRefY(nCam, i);
			m_stSaveImageInfo[algo][nCam][index].dPosX[i] = GetMatching(algo).getFindInfo(nCam, i).GetXPos();
			m_stSaveImageInfo[algo][nCam][index].dPosY[i] = GetMatching(algo).getFindInfo(nCam, i).GetYPos();

			for (int j = 0; j < 4; j++)
			{
				m_stSaveImageInfo[algo][nCam][index].dLineX[i][j] = GetMatching(algo).getFindInfo(nCam, i).GetLineX(j);
				m_stSaveImageInfo[algo][nCam][index].dLineY[i][j] = GetMatching(algo).getFindInfo(nCam, i).GetLineY(j);
			}
		}
	
		m_stSaveImageInfo[algo][nCam][index].b4Align = vt_job_info[algo].model_info.getAlignInfo().getUse4PointAlign();
		m_stSaveImageInfo[algo][nCam][index].nFound[0] = GetMatching(algo).getFindInfo(nCam, 0).GetFound();
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_X]			 = m_dbRevisionData_obejct[algo][0][AXIS_X];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Y]			 = m_dbRevisionData_obejct[algo][0][AXIS_Y];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_T]			 = m_dbRevisionData_obejct[algo][0][AXIS_T];
		// YCS 2022-07-28 CV 보정값 건내주는 배열 인덱스 수정
		m_stSaveImageInfo[algo][nCam][index].dRevision_object[AXIS_X][0] = m_dbRevisionData_obejct[algo][AXIS_X][0];
		m_stSaveImageInfo[algo][nCam][index].dRevision_object[AXIS_Y][0] = m_dbRevisionData_obejct[algo][AXIS_Y][0];
		m_stSaveImageInfo[algo][nCam][index].dRevision_object[AXIS_T][0] = m_dbRevisionData_obejct[algo][AXIS_T][0];
		m_stSaveImageInfo[algo][nCam][index].dRevision_object[AXIS_X][1] = m_dbRevisionData_obejct[algo][AXIS_X][1];
		m_stSaveImageInfo[algo][nCam][index].dRevision_object[AXIS_Y][1] = m_dbRevisionData_obejct[algo][AXIS_Y][1];
		m_stSaveImageInfo[algo][nCam][index].dRevision_object[AXIS_T][1] = m_dbRevisionData_obejct[algo][AXIS_T][1];

		m_stSaveImageInfo[algo][nCam][index].bJudge = bJudge;
		m_stSaveImageInfo[algo][nCam][index].nRetry = m_nRetryCount[algo] - 1;
		m_stSaveImageInfo[algo][nCam][index].bFinal = bRetryEnd;
		m_stSaveImageInfo[algo][nCam][index].nAlgorithm = algo;
		m_stSaveImageInfo[algo][nCam][index].nCam = nCam;

		//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
		if (strlen(vt_job_info[algo].main_object_id.c_str()) <= 13)
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\NO_NAME_%s_%s_Img.%s", strImageDir,		// 이미지 저장 디렉토리
				strTime,											// 시간
				m_stCamInfo[real_cam].cName,						// 카메라 이름
				str_ImageType);										// 이미지 확장자
		}
		else
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\%s_%s_%s_Img.%s", strImageDir,		// 이미지 저장 디렉토리
				vt_job_info[algo].main_object_id.c_str(),		// 모델이름
				strTime,										// 시간
				m_stCamInfo[real_cam].cName,					// 카메라 이름
				str_ImageType);									// 이미지 확장자
		}


		copyMemory(getSaveImageBuffer(real_cam, index), getProcBuffer(real_cam, 0), W * H);
		sprintf(m_cSaveImageRingBufPath[algo][nCam][index], "%s", (LPCTSTR)str);

		//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
		if (strlen(vt_job_info[algo].main_object_id.c_str()) <= 13)
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\NO_NAME_%s_%s_ImgRaw.%s", strImageDir,		// 이미지 저장 디렉토리
				strTime,												// 시간
				m_stCamInfo[real_cam].cName,							// 카메라 이름
				str_ImageType);											// Image Type
		}
		else
		{
			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
			str.Format("%s\\%s_%s_%s_ImgRaw.%s", strImageDir,			// 이미지 저장 디렉토리
				vt_job_info[algo].main_object_id.c_str(),				// 모델이름
				strTime,												// 시간
				m_stCamInfo[real_cam].cName,							// 카메라 이름
				str_ImageType);											// Image Type
		}
		sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index], "%s", (LPCTSTR)str);

		m_nSaveImageRingBufIndex[algo][nCam]++;
		m_nSaveImageRingBufIndex[algo][nCam] = m_nSaveImageRingBufIndex[algo][nCam] % MAX_SAVE_IMAGE_RING_BUF;
	}
}
void CLET_AlignClientDlg::save_result_image_1shot_align_infra(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, strTime, strDate, str_modelID, str_algo, str_ImageType;
	CString str;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[algo].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID \\ JOB이름 \\ OK/NG \\ PanelID \\ 

	//이미지저장 시간
	if (m_strResultTime[algo].IsEmpty())	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
	else									strTime.Format("%s", m_strResultTime[algo]);

	//날짜
	if (m_strResultDate[algo].IsEmpty())	strDate.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	else									strDate.Format("%s", m_strResultDate[algo]);
	strImageDir.Format("%s%s", m_strImageDir, strDate);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format("%s", vt_job_info[algo].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		if (bJudge)
		{
			strImageDir.Format("%s\\OK", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
		else
		{
			strImageDir.Format("%s\\NG", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
	}

	//PanelID
	strImageDir.Format("%s\\%s", strImageDir, vt_job_info[algo].main_object_id.c_str());
	if (_access(strImageDir, 0) != 0) CreateDirectory(strImageDir, NULL);
	//PanelID가 있는경우
	else
	{
		strImageDir.Format("%s_%s", strImageDir, strTime);
		if (_access(strImageDir, 0) != 0) CreateDirectory(strImageDir, NULL);
	}

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int nCam = 0;
	int real_cam = 0;

	int Max_nPos = vt_job_info[algo].num_of_position;
	for (nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		int index = m_nSaveImageRingBufIndex[algo][nCam];
		m_stSaveImageInfo[algo][nCam][index].nNumPos = Max_nPos;

		for (int i = 0; i < Max_nPos; i++)
		{
			if (vt_job_info[algo].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING)
			{
				// matching
				m_stSaveImageInfo[algo][nCam][index].dPosX[i] = GetMatching(algo).getFindInfo(nCam, i).GetXPos();
				m_stSaveImageInfo[algo][nCam][index].dPosY[i] = GetMatching(algo).getFindInfo(nCam, i).GetYPos();
				m_stSaveImageInfo[algo][nCam][index].nFound[i] = GetMatching(algo).getFindInfo(nCam, i).GetFound();
			}
			else if (vt_job_info[algo].model_info.getAlignInfo().getMarkFindMethod() == METHOD_CALIPER)
			{
				// caliper
				m_stSaveImageInfo[algo][nCam][index].line[2 * i] = GetMatching(algo).getFindInfo(nCam, i).GetLine(0);
				m_stSaveImageInfo[algo][nCam][index].line[2 * i + 1] = GetMatching(algo).getFindInfo(nCam, i).GetLine(1);
				m_stSaveImageInfo[algo][nCam][index].bFindline[2 * i] = GetMatching(algo).getFindInfo(nCam, i).GetFindline(0);
				m_stSaveImageInfo[algo][nCam][index].bFindline[2 * i + 1] = GetMatching(algo).getFindInfo(nCam, i).GetFindline(1);

				for (int j = 0; j < 2; j++)
				{
					m_stSaveImageInfo[algo][nCam][index].dLineX[i][j] = GetMatching(algo).getFindInfo(nCam, i).GetLineX(j);
					m_stSaveImageInfo[algo][nCam][index].dLineY[i][j] = GetMatching(algo).getFindInfo(nCam, i).GetLineY(j);
				}
			}
		}
		m_stSaveImageInfo[algo][nCam][index].b4Align = vt_job_info[algo].model_info.getAlignInfo().getUse4PointAlign();
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_X] = m_dbRevisionData[algo][AXIS_X];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Y] = m_dbRevisionData[algo][AXIS_Y];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_T] = m_dbRevisionData[algo][AXIS_T];
		m_stSaveImageInfo[algo][nCam][index].bJudge = bJudge;
		m_stSaveImageInfo[algo][nCam][index].nRetry = m_nRetryCount[algo] - 1;
		m_stSaveImageInfo[algo][nCam][index].bFinal = bRetryEnd;
		m_stSaveImageInfo[algo][nCam][index].nAlgorithm = algo;
		m_stSaveImageInfo[algo][nCam][index].nCam = nCam;

		str.Format("%s\\%s_%s_%s_Img.%s",		strImageDir,									// 이미지 저장 디렉토리
												vt_job_info[algo].main_object_id.c_str(),		// 모델이름
												strTime,										// 시간
												m_stCamInfo[real_cam].cName,					// 카메라 이름
												str_ImageType);									// Image Type

		copyMemory(getSaveImageBuffer(real_cam, index), getProcBuffer(real_cam, 0), W * H);
		sprintf(m_cSaveImageRingBufPath[algo][nCam][index], "%s", (LPCTSTR)str);

		str.Format("%s\\%s_%s_%s_ImgRaw.%s",	strImageDir,									// 이미지 저장 디렉토리
												vt_job_info[algo].main_object_id.c_str(),		// 모델이름
												strTime,										// 시간
												m_stCamInfo[real_cam].cName,					// 카메라 이름
												str_ImageType);									// Image Type

		sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index], "%s", (LPCTSTR)str);

		m_nSaveImageRingBufIndex[algo][nCam]++;
		m_nSaveImageRingBufIndex[algo][nCam] = m_nSaveImageRingBufIndex[algo][nCam] % MAX_SAVE_IMAGE_RING_BUF;
	}
}

void CLET_AlignClientDlg::SaveResultImageFilm_Insp(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, strTime, strDate, str_modelID, str_algo, str_ImageType;
	CString str;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[algo].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	//이미지저장 시간
	if (m_strResultTime[algo].IsEmpty())	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
	else									strTime.Format("%s", m_strResultTime[algo]);

	//날짜
	if (m_strResultDate[algo].IsEmpty())	strDate.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	else									strDate.Format("%s", m_strResultDate[algo]);
	strImageDir.Format("%s%s", m_strImageDir, strDate);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format("%s", vt_job_info[algo].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		if (bJudge)
		{
			strImageDir.Format("%s\\OK", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
		else
		{
			strImageDir.Format("%s\\NG", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
	}

	//PanelID
	strImageDir.Format("%s\\%s", strImageDir, vt_job_info[algo].main_object_id.c_str());
	if (_access(strImageDir, 0) != 0) CreateDirectory(strImageDir, NULL);
	//PanelID가 있는경우
	else
	{
		strImageDir.Format("%s_%s", strImageDir, strTime);
		if (_access(strImageDir, 0) != 0) CreateDirectory(strImageDir, NULL);
	}

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int nCam = 0;
	int real_cam = 0;

	int Max_nPos = vt_job_info[algo].num_of_position;
	for (nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		int index = m_nSaveImageRingBufIndex[algo][nCam];
		m_stSaveImageInfo[algo][nCam][index].nNumPos = Max_nPos;

		m_stSaveImageInfo[algo][nCam][index].bJudge = bJudge;
		m_stSaveImageInfo[algo][nCam][index].nRetry = m_nRetryCount[algo] - 1;
		m_stSaveImageInfo[algo][nCam][index].bFinal = bRetryEnd;
		m_stSaveImageInfo[algo][nCam][index].nAlgorithm = algo;
		m_stSaveImageInfo[algo][nCam][index].nCam = nCam;
		m_stSaveImageInfo[algo][nCam][index].nNumPos = Max_nPos;

		str.Format("%s\\%s_%s_%s_Img.%s",	strImageDir,									// 이미지 저장 디렉토리
											vt_job_info[algo].main_object_id.c_str(),		// 모델이름
											strTime,										// 시간
											m_stCamInfo[real_cam].cName,					// 카메라 이름
											str_ImageType);									// Image Type
		//KJH FILM_MARKING
		copyMemory(getSaveImageBuffer(real_cam, index), getProcBuffer(real_cam, 1), W * H);
		sprintf(m_cSaveImageRingBufPath[algo][nCam][index], "%s", (LPCTSTR)str);

		str.Format("%s\\%s_%s_%s_ImgRaw.%s",	strImageDir,									// 이미지 저장 디렉토리
												vt_job_info[algo].main_object_id.c_str(),		// 모델이름
												strTime,										// 시간
												m_stCamInfo[real_cam].cName,					// 카메라 이름
												str_ImageType);									// Image Type

		sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index], "%s", (LPCTSTR)str);

		m_nSaveImageRingBufIndex[algo][nCam]++;
		m_nSaveImageRingBufIndex[algo][nCam] = m_nSaveImageRingBufIndex[algo][nCam] % MAX_SAVE_IMAGE_RING_BUF;
	}
}
void CLET_AlignClientDlg::SaveResultImageNozzleView_Insp(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int real_cam = camBuf.at(0);

	m_stSaveImageInfo[algo][real_cam][0].nCam = 0;
	m_stSaveImageInfo[algo][real_cam][0].nAlgorithm = algo;
	m_stSaveImageInfo[algo][real_cam][0].bJudge = bJudge;
	_stSaveImageInfo* pInfo = &m_stSaveImageInfo[algo][real_cam][0];
	pInfo->pDlg = this;

	AfxBeginThread(Thread_NozzleView_Insp_ImageSave, pInfo);
}
void CLET_AlignClientDlg::SaveResultImageScan_Insp(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, str;
	CString strTime, str_modelID, str_algo, str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[algo].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";


	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID \\ JOB이름 \\ OK/NG \\ PanelID \\ 

	//날짜
	strTime.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	strImageDir.Format("%s%s", m_strImageDir, strTime);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format(_T("%s"), vt_job_info[algo].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else if (bJudge)
	{
		strImageDir.Format("%s\\OK", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		strImageDir.Format("%s\\NG", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}

	//PanelID
	strImageDir.Format("%s\\%s", strImageDir, vt_job_info[algo].main_object_id.c_str());
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//이미지 순서
	strImageDir.Format("%s\\Grab_%d", strImageDir, m_nSeqScanInspGrabCount[algo]);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//이미지저장 시간
	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int nCam = 0;
	int real_cam = 0;

	for (nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);

		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h * (m_nSeqScanInspGrabCount[algo] == 1 ? _SCAN_GRAB_MAXCOUNT : 1);

		int index = m_nSaveImageRingBufIndex[algo][nCam];

		index = m_nSeqScanInspGrabCount[algo];

		m_stSaveImageInfo[algo][nCam][index].bUsing1Cam				= FALSE;
		m_stSaveImageInfo[algo][nCam][index].b4Align				= vt_job_info[algo].model_info.getAlignInfo().getUse4PointAlign();
		m_stSaveImageInfo[algo][nCam][index].dPosX[0]				= GetMatching(algo).getFindInfo(nCam, 0).GetXPos();
		m_stSaveImageInfo[algo][nCam][index].dPosY[0]				= GetMatching(algo).getFindInfo(nCam, 0).GetYPos();
		m_stSaveImageInfo[algo][nCam][index].nFound[0]				= GetMatching(algo).getFindInfo(nCam, 0).GetFound();
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_X]		= m_dbRevisionData[algo][AXIS_X];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Y]		= m_dbRevisionData[algo][AXIS_Y];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_T]		= m_dbRevisionData[algo][AXIS_T];
		m_stSaveImageInfo[algo][nCam][index].bJudge					= bJudge;
		m_stSaveImageInfo[algo][nCam][index].nRetry					= m_nRetryCount[algo] - 1;
		m_stSaveImageInfo[algo][nCam][index].bFinal					= bRetryEnd;
		m_stSaveImageInfo[algo][nCam][index].nNumPos				= 1;
		m_stSaveImageInfo[algo][nCam][index].nAlgorithm				= algo;
		m_stSaveImageInfo[algo][nCam][index].nCam					= nCam;
		m_stSaveImageInfo[algo][nCam][index].line[0]				= GetMatching(algo).getFindInfo(nCam, 0).GetLine(0);
		m_stSaveImageInfo[algo][nCam][index].line[1]				= GetMatching(algo).getFindInfo(nCam, 0).GetLine(1);
		m_stSaveImageInfo[algo][nCam][index].bFindline[0]			= GetMatching(algo).getFindInfo(nCam, 0).GetFindline(0);
		m_stSaveImageInfo[algo][nCam][index].bFindline[1]			= GetMatching(algo).getFindInfo(nCam, 0).GetFindline(1);

		for (int i = 0; i < 4; i++)
		{
			m_stSaveImageInfo[algo][nCam][index].dLineX[0][i] = GetMatching(algo).getFindInfo(nCam, 0).GetLineX(i);
			m_stSaveImageInfo[algo][nCam][index].dLineY[0][i] = GetMatching(algo).getFindInfo(nCam, 0).GetLineY(i);
		}

		str.Format("%s\\%s_%s_%s_%d_Img.%s", strImageDir,					// 이미지 저장 디렉토리
			vt_job_info[algo].main_object_id.c_str(),						// 모델이름
			strTime,														// 시간
			m_stCamInfo[real_cam].cName,									// 카메라 이름
			m_nSeqScanInspGrabCount[algo],									// Grab Num
			str_ImageType);													// Image Type
				
		sprintf(m_cSaveImageRingBufPath[algo][nCam][index],		"%s", (LPCTSTR)str);

		str.Format("%s\\%s_%s_%s_%d_ImgRaw.%s", strImageDir,				// 이미지 저장 디렉토리
			vt_job_info[algo].main_object_id.c_str(),						// 모델이름
			strTime,														// 시간
			m_stCamInfo[real_cam].cName,									// 카메라 이름
			m_nSeqScanInspGrabCount[algo],									// Grab Num
			str_ImageType);													// Image Type

		sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index],	"%s", (LPCTSTR)str);

		//KJH 2021-07-29 이미지 저장
		if (m_nSeqScanInspGrabCount[algo] == 1)
		{
			int nIndex = m_nSeqScanInspGrabCount[algo];
			m_stSaveImageInfo[algo][nCam][nIndex].nCam = nCam;
			m_stSaveImageInfo[algo][nCam][nIndex].nIndex = nIndex;
			_stSaveImageInfo* pInfo = &m_stSaveImageInfo[algo][nCam][nIndex];
			pInfo->pDlg = this;

			AfxBeginThread(Thread_ScanImageSave, pInfo);
		}
		else
		{
			int nIndex = m_nSeqScanInspGrabCount[algo];
			m_stSaveImageInfo[algo][nCam][nIndex].nCam = nCam;
			m_stSaveImageInfo[algo][nCam][nIndex].nIndex = nIndex;
			_stSaveImageInfo* pInfo = &m_stSaveImageInfo[algo][nCam][nIndex];
			pInfo->pDlg = this;

			AfxBeginThread(Thread_ScanOneImageSave, pInfo);
		}
	}
}

void CLET_AlignClientDlg::draw_mark_pos_2cam_2shot(int algorithm)
{
	_stAlignResult Info;
	int camCount = vt_job_info[algorithm].num_of_camera;
	if (camCount <= 0) return;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;
	int posCount = vt_job_info[algorithm].num_of_position;
	int total = camCount * posCount;

	// cam 2	pos 1
	// cam 1
	// cam 2

	// cam 1	pos 2
	// pos 1
	// pos 2

	// cam 2	pos 2
	// cam 1	pos 1
	// cam 1	pos 2
	// cam 2	pos 1
	// cam 2	pos 2
	for (int i = 0; i < camCount; i++)
	{
		for (int nPos = 0; nPos < posCount; nPos++)
		{
			Info.nCam = i;
			Info.nViewer = vt_job_info[algorithm].viewer_index[i * posCount + nPos];
			Info.nAlgorithm = algorithm;
			Info.bErase = TRUE;
			Info.nPos = nPos;
			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DRAW_ALIGN_RESULT, (LPARAM)&Info);
		}
	}
}
void CLET_AlignClientDlg::drawMarkPos(int algorithm)
{	

	int nMethod = vt_job_info[algorithm].algo_method;
	switch (nMethod)
	{
		case CLIENT_TYPE_ALIGN:							draw_mark_pos_2cam_1shot(algorithm);	break;
		case CLIENT_TYPE_1CAM_1SHOT_ALIGN:
		case CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP:
		case CLIENT_TYPE_1CAM_1SHOT_FILM:				draw_mark_pos_1cam_1shot(algorithm);	break;
		case CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN:			draw_mark_pos_2cam_2shot(algorithm);	break;
		case CLIENT_TYPE_4CAM_1SHOT_ALIGN:				draw_mark_pos_4cam_1shot(algorithm);	break;
		case CLIENT_TYPE_1CAM_4POS_ROBOT:
		case CLIENT_TYPE_1CAM_2POS_REFERENCE:           draw_mark_pos_1cam_2object(algorithm);  break; // Reel 얼라인 Tkyuha 20211018
		case CLIENT_TYPE_ELB_CENTER_ALIGN:				draw_mark_pos_1cam_elb(algorithm);		break;
		case CLIENT_TYPE_CENTER_NOZZLE_ALIGN:
		case CLIENT_TYPE_NOZZLE_ALIGN:					draw_mark_pos_1cam_nozzle(algorithm);	break;
		default:
		{
			_stAlignResult Info;
			int camCount = vt_job_info[algorithm].num_of_camera;
			if (camCount <= 0) return;
			std::vector<int> camBuf = vt_job_info[algorithm].camera_index;
			int posCount = vt_job_info[algorithm].num_of_position;
			int total = camCount * posCount;

			for (int i = 0; i < camCount; i++)
			{
				Info.nCam = i;
				Info.nViewer = vt_job_info[algorithm].viewer_index[i];
				Info.nAlgorithm = algorithm;
				Info.bErase = TRUE;
				Info.nPos = posCount;
				::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DRAW_ALIGN_RESULT, (LPARAM)&Info);
			}
		}
		break;
	}
}

void CLET_AlignClientDlg::draw_align_revision(int nJob, int nRet)
{
	int nMethod = vt_job_info[nJob].algo_method;
	int camCount = vt_job_info[nJob].num_of_camera;
	if (camCount <= 0) return;

	int real_cam, W, H = 0;

	int nCam, nViewer = 0;
	CString text, text2;
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
	COLORREF color, color_text;

	if (nRet == 1)	color = COLOR_GREEN; // OK
	else
	{
		real_cam = vt_job_info[nJob].camera_index[0];
		W = m_stCamInfo[real_cam].w;
		H = m_stCamInfo[real_cam].h;

		color = COLOR_RED; //NG
		if (m_nErrorType[nJob] == 0)
		{
			text.Format("Find Pattern Failed !!");
			nViewer = vt_job_info[nJob].viewer_index[0];
			draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color, 12, 12, 40, H - 300, TRUE);
			return;
		}
		else if (m_nErrorType[nJob] == ERR_TYPE_REVISION_FAIL)
		{
			text.Format("Revision Failed !!");
			nViewer = vt_job_info[nJob].viewer_index[0];
			draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color, 12, 12, 40, H - 300, TRUE);
			return;
		}
		//HTK 2022-06-29 Align Revision Error Type 추가
		else if (m_nErrorType[nJob] == ERR_TYPE_REVISION_LIMIT)
		{
			text.Format("Revision Data Limit !!");
			nViewer = vt_job_info[nJob].viewer_index[0];
			draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color, 12, 12, 40, H - 500, TRUE);
			return;
		}
		else if (m_nErrorType[nJob] == ERR_TYPE_ANGLE_ERROR)
		{
			text.Format("Include Angle Error !!");
			nViewer = vt_job_info[nJob].viewer_index[0];
			draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color, 12, 12, 40, H - 300, TRUE);
			return;
		}
	}

	switch (nMethod)
	{
	case CLIENT_TYPE_ALIGN:
	case CLIENT_TYPE_1CAM_1SHOT_ALIGN:
	case CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP:
	case CLIENT_TYPE_1CAM_1SHOT_FILM:
	case CLIENT_TYPE_4CAM_1SHOT_ALIGN:
	case CLIENT_TYPE_ELB_CENTER_ALIGN:
	case CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN:
	case CLIENT_TYPE_NOZZLE_ALIGN:
	{
		int method = vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod();

		if (method == METHOD_LINE)
		{
			for (int i = 0; i < camCount; i++)
			{
				real_cam = vt_job_info[nJob].camera_index[i];
				W = m_stCamInfo[real_cam].w;
				H = m_stCamInfo[real_cam].h;

				text.Format("Y : %.4f", m_dbRevisionData[nJob][AXIS_Y]);
				//draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color, 20, 20, W / 2 - 300, H / 2 + 200, TRUE);
				pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().AddHardGraphic(new GraphicLabel(10, -10, text, Anchor::TopRight)); //SJB 2022-11-25 Viewer 머징 수정
			}
		}
		else
		{
			for (int i = 0; i < camCount; i++)
			{
				real_cam = vt_job_info[nJob].camera_index[i];
				W = m_stCamInfo[real_cam].w;
				H = m_stCamInfo[real_cam].h;
	
				text.Format("X : %.4f, Y : %.4f, T : %.4f )", m_dbRevisionData[nJob][AXIS_X], m_dbRevisionData[nJob][AXIS_Y], m_dbRevisionData[nJob][AXIS_T]);
				nCam = i;
				nViewer = vt_job_info[nJob].viewer_index[i];
				//draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color, 12, 12, 40, H - 300, TRUE);
				pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().AddHardGraphic(new GraphicLabel(10, -10, text, Anchor::TopRight));
			}
		}
	}
	break;
	case CLIENT_TYPE_CENTER_NOZZLE_ALIGN:
		for (int i = 0; i < camCount; i++)
		{
			real_cam = vt_job_info[nJob].camera_index[i];
			W = m_stCamInfo[real_cam].w;
			H = m_stCamInfo[real_cam].h;

			nCam = i;
			nViewer = vt_job_info[nJob].viewer_index[i];

			double posX = GetMatching(nJob).getFindInfo(nCam, 0).GetXPos();
			double posY = GetMatching(nJob).getFindInfo(nCam, 0).GetYPos();

			double refX = GetMatching(nJob).getRefX(nCam, 0);
			double refY = GetMatching(nJob).getRefY(nCam, 0);

			double xres = GetMachine(nJob).getCameraResolutionX(nCam, 0);
			double yres = GetMachine(nJob).getCameraResolutionY(nCam, 0);

			color_text = COLOR_PURPLE;

			if (i == 0) text.Format("Z : %.4f, T : %.4f", (refY - posY) * yres, m_dNozzleCurrentAngle);
			if (i == 1) text.Format("X : %.4f, Y : %.4f", (refX - posX) * xres , (refY - posY) * yres);
			
			CDlgViewer* mViewer;
			int viewer = vt_job_info[nJob].machine_viewer_index[i];
			mViewer = pFormMain->m_pDlgViewerMain[viewer];
			double _MAG = mViewer->GetViewer().GetMagnification();
			if (_MAG == 0) _MAG = 1;

			//KJH 2022-05-09 Nozzle Align Display Size 변경
			//if (nCam == 0) draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color_text, 5 + 5/ _MAG, 5 + 5 / _MAG, W/2  + (-W/4)* _MAG, H / 2 + 30, FALSE);
			//if (nCam == 1) draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color_text, 5 + 3/ _MAG, 5 + 3/  _MAG, W/2  + (-W/2)* _MAG, H / 2 + 30, FALSE);
		
			if (nCam == 0) draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color_text, 12, 12, W/2 , H / 2 + 30, FALSE);
			if (nCam == 1) draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color_text, 12, 12, W/2 , H / 2 + 30, FALSE);

			text.Format("X: %.4f, Y: %.4f, Z: %.4f, T: %.4f", m_dbRevisionData[nJob][AXIS_X], m_dbRevisionData[nJob][AXIS_Y], m_dbRevisionData[nJob][AXIS_Z], m_dbRevisionData[nJob][AXIS_T]);
			//draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color, 12, 12, 40, H - 300, TRUE);
			pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().AddHardGraphic(new GraphicLabel(10, 10, text));
			//pFormMain->m_pDlgViewerMain[nViewer]->Invalidate();
		}
	break;
	case CLIENT_TYPE_1CAM_4POS_ROBOT:
	case CLIENT_TYPE_1CAM_2POS_REFERENCE:
	{
		real_cam = vt_job_info[nJob].camera_index[0];
		W = m_stCamInfo[real_cam].w;
		H = m_stCamInfo[real_cam].h;

		double xres = GetMachine(nJob).getCameraResolutionX(0, 0);
		double yres = GetMachine(nJob).getCameraResolutionY(0, 0);
		text.Format("[1] X : %.4f, Y : %.4f, T : %.4f, Gap Distance : %.4f", m_dbRevisionData_obejct[nJob][AXIS_X][0], m_dbRevisionData_obejct[nJob][AXIS_Y][0], m_dbRevisionData_obejct[nJob][AXIS_T][0], m_dReeltoStageDistance[0] * yres);
		nViewer = vt_job_info[nJob].viewer_index[0];
		//draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color, 12, 12, 40, H - 300, TRUE);

		text2.Format("[2] X: %.4f, Y: %.4f, T: %.4f, Gap Distance: %.4f", m_dbRevisionData_obejct[nJob][AXIS_X][1], m_dbRevisionData_obejct[nJob][AXIS_Y][1], m_dbRevisionData_obejct[nJob][AXIS_T][1], m_dReeltoStageDistance[1] * yres);
		//draw_text(&pFormMain->m_pDlgViewerMain[nViewer]->GetViewer(), text, color, 12, 12, 40, H - 100, TRUE);

		pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().AddHardGraphic(new GraphicLabel(10, -10, fmt("%s\n%s", text, text2), Anchor::TopRight));
		//pFormMain->m_pDlgViewerMain[nViewer]->Invalidate();

	}
	default:
	break;
	}

	pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().SoftDirtyRefresh();
}

void CLET_AlignClientDlg::draw_mark_pos_4cam_1shot(int algorithm)
{
	_stAlignResult Info;
	int camCount = vt_job_info[algorithm].num_of_camera;
	if (camCount <= 0) return;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;
	int posCount = vt_job_info[algorithm].num_of_position;
	int total = camCount * posCount;

	for (int i = 0; i < camCount; i++)
	{
		Info.nCam = i;
		Info.nViewer = vt_job_info[algorithm].viewer_index[i];
		Info.nAlgorithm = algorithm;
		Info.bErase = TRUE;
		Info.nPos = 0;
		::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DRAW_ALIGN_RESULT, (LPARAM)&Info);
	}
}
void CLET_AlignClientDlg::draw_mark_pos_2cam_1shot(int algorithm)
{
	_stAlignResult Info;
	int camCount = vt_job_info[algorithm].num_of_camera;
	if (camCount <= 0) return;

	for (int i = 0; i < camCount; i++)
	{
		Info.nCam = i;
		Info.nViewer = vt_job_info[algorithm].viewer_index[i];
		Info.nAlgorithm = algorithm;
		Info.bErase = TRUE;
		Info.nPos = 0;
		::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DRAW_ALIGN_RESULT, (LPARAM)&Info);
	}
}
void CLET_AlignClientDlg::draw_mark_pos_1cam_1shot(int algorithm)
{
	_stAlignResult Info;
	int camCount = vt_job_info[algorithm].num_of_camera;
	if (camCount <= 0) return;

	int real_cam = vt_job_info[algorithm].camera_index[0];
	int size = m_stCamInfo[real_cam].w * m_stCamInfo[real_cam].h;
	memcpy(getProcBuffer(real_cam, 1), getProcBuffer(real_cam, 0), size);

	for (int i = 0; i < 2; i++)
	{
		Info.nCam = 0;//  vt_job_info[algorithm].camera_index[0]; 211118 TK
		Info.nViewer = vt_job_info[algorithm].viewer_index[0];
		Info.nAlgorithm = algorithm;
		Info.bErase = i == 0 ? TRUE : FALSE;
		Info.nPos = i;
		::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DRAW_ALIGN_RESULT, (LPARAM)&Info);
		//::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DRAW_LINE_RESULT, (LPARAM)&Info);
	}

	if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFilmReAttachCheckEnable())
	{
		int real_cam = vt_job_info[algorithm].camera_index[0];
		if (m_pDlgCaliper->m_Caliper[real_cam][0][0].getCircleCaliper())
		{
			_st32fPoint spt = m_pDlgCaliper->m_Caliper[real_cam][0][0].getStartPt();
			_st32fPoint ept = m_pDlgCaliper->m_Caliper[real_cam][0][0].getEndPt();
			CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
			int nViewer = vt_job_info[algorithm].viewer_index[0];
			CViewerEx* pViewer = &pFormMain->m_pDlgViewerMain[nViewer]->GetViewer();

			// YCS 2022-10-31 필름 유무검사 영역 사이즈 고정
			if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFixedFilmReattachUse()
				&& vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFixedFilmReattachSize() != 0)
			{
				// YCS 2022-10-31 getCameraResolutionX 파라미터 하드코딩...
				double dResolution = GetMachine(algorithm).getCameraResolutionX(0, 0);
				double dCenterX = (spt.x + ept.x) / 2.0;
				double dCenterY = (spt.y + ept.y) / 2.0;
				double dRectSize = vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFixedFilmReattachSize() / dResolution;
				spt.x = dCenterX - dRectSize;
				spt.y = dCenterY + dRectSize;
				ept.x = dCenterX + dRectSize;
				ept.y = dCenterY - dRectSize;
			}
			else
			{
				if (fabs(spt.y - ept.y) < 20 || fabs(spt.x - ept.x) < 20)
				{
					double dCenterX = (spt.x + ept.x) / 2.0;
					double dCenterY = (spt.y + ept.y) / 2.0;
					double dRectSize = GetDistance(CPointF<double>(spt.x,spt.y), CPointF<double>(ept.x, ept.y))/2;
					spt.x = dCenterX - dRectSize;
					spt.y = dCenterY + dRectSize;
					ept.x = dCenterX + dRectSize;
					ept.y = dCenterY - dRectSize;
				}
			}

			if (spt.x > ept.x) swap(spt.x, ept.x);
			if (spt.y > ept.y) swap(spt.y, ept.y);

			pViewer->AddSoftGraphic(new GraphicRectangle(spt.x, spt.y, ept.x, ept.y, Gdiplus::Color::Blue));
            pViewer->SoftDirtyRefresh();
		}
	}

	if (vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING_LINE_THETA)
	{
		int real_cam = vt_job_info[algorithm].camera_index[0];

		sLine line_info[2];
		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][0][0].m_lineInfo;
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][1][0].m_lineInfo;

		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		int nViewer = vt_job_info[algorithm].viewer_index[0];
		CViewerEx* pViewer = &pFormMain->m_pDlgViewerMain[nViewer]->GetViewer();
		//struct stFigure figure;
		//figure.ptBegin.x = line_info[0].sx - 30;
		//figure.ptBegin.y = line_info[0].sy;
		//figure.ptEnd.x = line_info[0].sx + 30;
		//figure.ptEnd.y = line_info[0].sy;
		//pViewer->addFigureLine(figure, 3, 3, COLOR_BLUE);
		//figure.ptBegin.x = line_info[0].sx;
		//figure.ptBegin.y = line_info[0].sy - 30;
		//figure.ptEnd.x = line_info[0].sx;
		//figure.ptEnd.y = line_info[0].sy + 30;
		//pViewer->addFigureLine(figure, 3, 3, COLOR_BLUE);

		//figure.ptBegin.x = line_info[1].sx - 30;
		//figure.ptBegin.y = line_info[1].sy;
		//figure.ptEnd.x = line_info[1].sx + 30;
		//figure.ptEnd.y = line_info[1].sy;
		//pViewer->addFigureLine(figure, 3, 3, COLOR_BLUE);
		//figure.ptBegin.x = line_info[1].sx;
		//figure.ptBegin.y = line_info[1].sy - 30;
		//figure.ptEnd.x = line_info[1].sx;
		//figure.ptEnd.y = line_info[1].sy + 30;
		//pViewer->addFigureLine(figure, 3, 3, COLOR_BLUE);

		pViewer->AddSoftGraphic(new GraphicPoint(cv::Point2f(line_info[0].sx, line_info[0].sy), Gdiplus::Color::Blue, 5));
		pViewer->AddSoftGraphic(new GraphicPoint(cv::Point2f(line_info[1].sx, line_info[1].sy), Gdiplus::Color::Blue, 5));
		pViewer->SoftDirtyRefresh();
	}
}

//Reel Align 카메라 한개에 2개 object 마크 그리기 Tkyuha 20211018
void CLET_AlignClientDlg::draw_mark_pos_1cam_2object(int algorithm)
{
	_stAlignResult Info;
	int camCount = vt_job_info[algorithm].num_of_camera;
	if (camCount <= 0) return;

	for (int i = 0; i < 4; i++)
	{
		Info.nCam = 0;// vt_job_info[algorithm].camera_index[0];
		Info.nViewer = vt_job_info[algorithm].viewer_index[0];
		Info.nAlgorithm = algorithm;
		Info.bErase = i == 0 ? TRUE : FALSE;
		Info.nPos = i;
		::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DRAW_ALIGN_RESULT, (LPARAM)&Info);
	}
}
void CLET_AlignClientDlg::draw_mark_pos_1cam_elb(int algorithm)
{
	int method = vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod();
	if (method == METHOD_LINE) return;

	_stAlignResult Info;
	int camCount = vt_job_info[algorithm].num_of_camera;
	if (camCount <= 0) return;

	for (int i = 0; i < camCount; i++)
	{
		Info.nCam = i;
		Info.nViewer = vt_job_info[algorithm].viewer_index[i];
		Info.nAlgorithm = algorithm;
		Info.bErase = FALSE;
		Info.nPos = 0;
		Info.bType = TRUE;

		//MSG_FMV_DRAW_ALIGN_RESULT = TEXT 표시
		//MSG_FMV_DRAW_LINE_RESULT = Align 결과 화면 그리기

		::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DRAW_ALIGN_RESULT, (LPARAM)&Info);
		::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DRAW_LINE_RESULT, (LPARAM)&Info);
	}
}
void CLET_AlignClientDlg::draw_mark_pos_1cam_nozzle(int algorithm)
{
	_stAlignResult Info;
	int camCount = vt_job_info[algorithm].num_of_camera;
	if (camCount <= 0) return;

	for (int i = 0; i < camCount; i++)
	{
		Info.nCam = i;
		Info.nViewer = vt_job_info[algorithm].viewer_index[i];
		Info.nAlgorithm = algorithm;
		Info.bErase = TRUE;
		Info.nPos = 0;
		::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DRAW_ALIGN_RESULT, (LPARAM)&Info);
	}
}
void CLET_AlignClientDlg::draw_inspection(int nJob)
{
	int nMethod = vt_job_info[nJob].algo_method;

	if (nMethod == CLIENT_TYPE_PCB_DISTANCE_INSP)
	{
		draw_pcb_distance_insp(nJob);
	}
	else if (nMethod == CLIENT_TYPE_FILM_INSP) // 안에 내용물 채워줘야함 Film 검사용임 Tkyuha 20211018
	{
		//draw_film_distance_insp(nJob);
	}
	else
	{
		drawInspectionDistancePos(nJob);
	}
}

void CLET_AlignClientDlg::draw_calib_direction(int nJob, int nForm)
{
	if (vt_system_option[nJob].show_calib_direction != TRUE)
	{
		return;
	}

	int nMethod = vt_job_info[nJob].algo_method;
	int camCount = vt_job_info[nJob].num_of_camera;
	int nViewerCount = 0;

	std::vector <CViewerEx*> vt_Viewer;
	std::vector <int> vt_real_view;
	switch (nForm)
	{
	case FORM_MAIN:
	{
		nViewerCount = int(vt_job_info[nJob].main_viewer_index.size());

		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		for (int nViewer = 0; nViewer < nViewerCount; nViewer++)
		{
			int real_view = vt_job_info[nJob].main_viewer_index[nViewer];
			vt_real_view.push_back(real_view);
			vt_Viewer.push_back(&pFormMain->m_pDlgViewerMain[real_view]->GetViewer()); // 221107 real_view 인지 nViewer 인지 디버그 확인 필요 
		}
	}
	break;
	case FORM_MACHINE:
	{
		nViewerCount = int(vt_job_info[nJob].machine_viewer_index.size());

		CFormMachineView* pFormMachine = (CFormMachineView*)m_pForm[FORM_MACHINE];
		for (int nViewer = 0; nViewer < nViewerCount; nViewer++)
		{
			int real_view = vt_job_info[nJob].machine_viewer_index[nViewer];
			vt_real_view.push_back(real_view);
			vt_Viewer.push_back(&pFormMachine->m_pDlgViewerMachine[real_view]->GetViewer());
		}
	}
	break;
	}

	for (int nViewer = 0; nViewer < nViewerCount; nViewer++)
	{
		int real_view = vt_real_view[nViewer];
		int real_cam = vt_viewer_info[real_view].camera_index;

		for (int nCam = 0; nCam < vt_job_info[nJob].num_of_camera; nCam++)
		{
			if (real_cam == vt_job_info[nJob].camera_index[nCam])
			{
				int W = m_stCamInfo[real_cam].w;
				int H = m_stCamInfo[real_cam].h;

				int dir_x = GetMachine(nJob).getCalibDirectionX(nCam, 0);
				int dir_y = GetMachine(nJob).getCalibDirectionY(nCam, 0);

				int min = MIN(W, H);

				int strat_x = int(W * 0.875);
				int strat_y = int(H * 0.875);

				switch (vt_job_info[nJob].algo_method)
				{
				case CLIENT_TYPE_CENTER_NOZZLE_ALIGN:
				{
					if (nCam == 0)
					{
						draw_direction(vt_Viewer[nViewer], dir_x, min * 0.1, "Y+", COLOR_GREEN, strat_x, strat_y);
						draw_direction(vt_Viewer[nViewer], dir_y, min * 0.1, "Z+", COLOR_YELLOW, strat_x, strat_y);
					}
				}
				break;
				case CLIENT_TYPE_CENTER_SIDE_YGAP:
				case CLIENT_TYPE_NOZZLE_SIDE_VIEW:
				{
					draw_direction(vt_Viewer[nViewer], dir_x, min * 0.1, "Y+", COLOR_GREEN, strat_x, strat_y);
					draw_direction(vt_Viewer[nViewer], dir_y, min * 0.1, "Z+", COLOR_YELLOW, strat_x, strat_y);
				}
				break;
				default:
				{
					draw_direction(vt_Viewer[nViewer], dir_x, min * 0.1, "X+", COLOR_GREEN, strat_x, strat_y);
					draw_direction(vt_Viewer[nViewer], dir_y, min * 0.1, "Y+", COLOR_YELLOW, strat_x, strat_y);
				}
				break;
				}
			}
		}
		vt_Viewer[nViewer]->SoftDirtyRefresh();
	}

	vt_real_view.clear();
	vt_Viewer.clear();
}

void CLET_AlignClientDlg::draw_pcb_distance_insp(int algorithm)
{
	_stAlignResult Info;
	int nMethod = vt_job_info[algorithm].algo_method;
	int camCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;

	Info.nAlgorithm = algorithm;
	Info.bErase = TRUE;

	for (int nPos = 0; nPos < m_nSeqTotalInspGrabCount; nPos++)
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			Info.nCam = nCam;
			Info.nPos = nPos;
			Info.nViewer = vt_job_info[algorithm].viewer_index[nCam * 4 + nPos];	// 최대 POSITION 4임

			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_PCB_DISTANCE, (LPARAM)&Info);
		}
	}
}
void CLET_AlignClientDlg::draw_film_distance_insp(int algorithm)
{
	_stAlignResult Info;

	int camCount = vt_job_info[algorithm].num_of_camera;

	Info.nAlgorithm = algorithm;
	Info.bErase = TRUE;

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		Info.nCam = nCam;
		Info.nPos = 0;
		Info.nViewer = vt_job_info[algorithm].viewer_index[nCam];

		::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_FILM_DISTANCE, (LPARAM)&Info);
	}
}
void CLET_AlignClientDlg::drawInspectionDistancePos(int algorithm)
{

#ifndef JOB_INFO
	_stAlignResult Info;
	int nMethod = m_pAlgorithmInfo.getAlgorithmMethod(algorithm);
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);

	for (int i = 0; i < camCount; i++)
	{
		Info.nCam = camBuf.at(i);
		if (nMethod == CLIENT_TYPE_PCB_DISTANCE_INSP)	Info.nPos = m_nSeqCurrentInspGrabCount;
		else											Info.nPos = 0;
		Info.nViewer = Info.nCam;
		Info.nAlgorithm = algorithm;
		Info.bErase = TRUE;

		if (nMethod == CLIENT_TYPE_PANEL_EXIST_INSP)
			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_PANEL_EXIST, (LPARAM)&Info);
		else if (nMethod == CLIENT_TYPE_PCB_DISTANCE_INSP)
			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_PCB_DISTANCE, (LPARAM)&Info);
		else if (nMethod == CLIENT_TYPE_ASSEMBLE_INSP)
			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_PANEL_ASSEMBLE, (LPARAM)&Info);
}
#else
	_stAlignResult Info;
	int nMethod = vt_job_info[algorithm].algo_method;
	int camCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;

	for (int i = 0; i < camCount; i++)
	{
		Info.nCam = camBuf[i];
		if (nMethod == CLIENT_TYPE_PCB_DISTANCE_INSP)
		{
			Info.nPos = m_nSeqCurrentInspGrabCount;
			Info.nViewer = vt_job_info[algorithm].viewer_index[i * 4 + m_nSeqCurrentInspGrabCount];
		}
		else
		{
			Info.nPos = 0;
			Info.nViewer = vt_job_info[algorithm].viewer_index[i];
		}
		Info.nAlgorithm = algorithm;
		Info.bErase = TRUE;

		if (nMethod == CLIENT_TYPE_PANEL_EXIST_INSP)
			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_PANEL_EXIST, (LPARAM)&Info);
		else if (nMethod == CLIENT_TYPE_ASSEMBLE_INSP)
			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_PANEL_ASSEMBLE, (LPARAM)&Info);
		else if (nMethod == CLIENT_TYPE_PCB_DISTANCE_INSP)
			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_PCB_DISTANCE, (LPARAM)&Info);
		else if (nMethod == CLIENT_TYPE_SCAN_INSP)
		{
			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_SCAN_INSP, (LPARAM)&Info);
		}
	}
#endif
}

BOOL CLET_AlignClientDlg::write_result_exist_insp(CString serialNum, BOOL bjudge, int algorithm)
{

	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algorithm];
	BOOL bWriteHeader = FALSE;

	CString algo_name = vt_job_info[algorithm].job_name.c_str();

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d:%02d:%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		Time_str = m_strResultTime[algorithm];
		Date_str = m_strResultDate[algorithm];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_Result_%s.csv", strFileDir, algo_name, Date_str);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}
	int nCamCount = vt_job_info[algorithm].num_of_camera;

	CString strHeader, strBody;

	strTemp.Format("TIME");																					strHeader += strTemp;
	strTemp.Format("%s", Time_str);																			strBody += strTemp;

	strTemp.Format(",MODEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);															strBody += strTemp;

	strTemp.Format(",PANEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", serialNum);																		strBody += strTemp;

	strTemp.Format(",JUDGE");																				strHeader += strTemp;
	strTemp.Format(",%s", bjudge ? "OK" : "NG");															strBody += strTemp;

	strTemp.Format(",Result");																				strHeader += strTemp;
	strTemp.Format(",%s", m_strExistResult);																strBody += strTemp;

	strTemp.Format(",Avg Brightness");																		strHeader += strTemp;
	strTemp.Format(",%.1f", m_dExistResultData);															strBody += strTemp;

	strTemp.Format(",Setting Panel Brightness");															strHeader += strTemp;
	strTemp.Format(",%d", vt_job_info[algorithm].model_info.getInspSpecParaInfo().getExistDummyGray());		strBody += strTemp;

	strTemp.Format(",Sep Thershold");																		strHeader += strTemp;
	strTemp.Format(",%d", vt_job_info[algorithm].model_info.getInspSpecParaInfo().getExistPanelGray());		strBody += strTemp;

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader)
	{
		WriteFile.WriteString(strHeader);
	}

	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);
	WriteFile.Close();

	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_diff_insp_ELB(CString serialNum, BOOL bjudge, int algorithm)
{
	EnterCriticalSection(&m_csScanWrite);

	CString strTemp, Time_str, Date_str,strSummary, Real_time;
	CString strFileDir = m_strResultDir + m_strResultDate[algorithm];
	BOOL bWriteHeader = FALSE;

	CString algo_name = vt_job_info[algorithm].job_name.c_str();
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	CString stage = "NULL";
	if		(m_nClientID == 3)	stage = "A1";
	else if (m_nClientID == 4)	stage = "A2";
	else if (m_nClientID == 5)	stage = "B1";
	else if (m_nClientID == 6)	stage = "B2";

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	Real_time.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d:%02d:%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		if(m_strResultTime[algorithm]=="") 
			Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		else Time_str = m_strResultTime[algorithm];
		if(m_strResultDate[algorithm]=="")
			Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
		else Date_str = m_strResultDate[algorithm];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	
	strSummary.Format("%s%s_%s_InspSummary_Result.csv", strFileDir, stage, Date_str);
	strFileDir.Format("%sDIFF_INSP\\", strFileDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_%s_Insp_Result_%s.csv", strFileDir, stage, serialNum, Time_str);

	if ((_access(strSummary, 0)) == -1)		bWriteHeader = TRUE;
	else
	{
		strTemp.Format("%s%s_%s_Insp_Result_%s.csv", strFileDir, stage, serialNum, Real_time);
		if ((_access(strSummary, 0)) == -1)		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile,summaryFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}
	if (summaryFile.Open(strSummary, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}	
	
	int nCamCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;;
	int real_cam = camBuf[0];
	int W = m_stCamInfo[real_cam].w;
	int H = m_stCamInfo[real_cam].h;
	int Center_W = m_stCamInfo[real_cam].w / 2;
	int Center_H = m_stCamInfo[real_cam].h / 2;
	double xres = GetMachine(algorithm).getCameraResolutionX(real_cam, 0);
	double yres = GetMachine(algorithm).getCameraResolutionY(real_cam, 0);
	int datasheet = 0;
	double minDistance_in = m_ELB_DiffInspResult[datasheet].m_vELB_ReverseRotateCenter.x;
	double maxDistance_in = m_ELB_DiffInspResult[datasheet].m_vELB_ReverseRotateCenter.y;
	double minDistance_out = m_ELB_DiffInspResult[datasheet].m_vELB_RotateCenter.x;	//SJB 2022-11-11 Overflow Min Log Sheet 수정
	double maxDistance_out = m_ELB_DiffInspResult[datasheet].m_vELB_RotateCenter.y;
	double minDistance = m_ELB_DiffInspResult[datasheet].m_vELB_DistMinMax.x;
	double maxDistance = m_ELB_DiffInspResult[datasheet].m_vELB_DistMinMax.y;
	double minmaxangle[10] = { 0, };
	
	memcpy(minmaxangle,m_ELB_DiffInspResult[datasheet + 1].m_ELB_ResultAngle,sizeof(double)*9);

	// m_ELB_DiffInspResult[0][0] = Center To Target In Distance	//
	// m_ELB_DiffInspResult[0][1] = Center To Target Out Distance	//
	// m_ELB_DiffInspResult[0][2] = Angle							//
	// m_ELB_DiffInspResult[0][3] = Target Out X Position			//
	// m_ELB_DiffInspResult[0][4] = Target Out Y Position			//
	// m_ELB_DiffInspResult[1][0] = Target In Distance				//
	// m_ELB_DiffInspResult[1][1] = Target Out Distance				//
	// m_ELB_DiffInspResult[1][2] = Center To Cink Start Distance	//
	// m_ELB_DiffInspResult[1][3] = Target In X Position			//
	// m_ELB_DiffInspResult[1][4] = Target In Y Position			//
	// m_ELB_DiffInspResult[2][0] = Center To CC In Distance		//

	CString strHeader, strBody;

	strTemp.Format("TIME");							strHeader += strTemp;
	strTemp.Format("%s_%s", Date_str,Time_str);		strBody += strTemp;

	strTemp.Format(",MODEL ID");					strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);	strBody += strTemp;

	strTemp.Format(",PANEL ID");					strHeader += strTemp;
	strTemp.Format(",%s", serialNum);				strBody += strTemp;

	strTemp.Format(",STAGE");						strHeader += strTemp;
	strTemp.Format(",%s", stage);					strBody += strTemp;	

	strTemp.Format(",JUDGE");						strHeader += strTemp;
	strTemp.Format(",%s", bjudge ? "OK" : "NG");	strBody += strTemp;

	// JSY 2022-11-05 이물검사 결과 추가 Dust Insp
	/// Comment : InputInspection = Dust Insp
	strTemp.Format(",Dust Inspection Judge");								strHeader += strTemp;
	if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getUseInputInspection()) { 	// Check Used Dust Inspection
		strTemp.Format(",%s", pFormMain->m_bDustInspJudge ? "OK" : "NG");	strBody += strTemp;
	}
	else {
		strTemp.Format(",%s", "N/A");										strBody += strTemp;
	}
	// END JSY 2022-11-05 이물 검사 결과 추가 Dust Insp

	// JSY 2022-11-05 액튐검사 결과 추가 Liquid Drops
	/// Comment : DustInsp = LiquidDrops (Function name error)
	strTemp.Format(",Liquid Drops Inspection Judge");						strHeader += strTemp;
	if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getUseDustInsp()) { 	// Check Used Dust Inspection
		strTemp.Format(",%s", pFormMain->m_bLiquidInspJudge ? "OK" : "NG");	strBody += strTemp;
	}
	else {
		strTemp.Format(",%s", "N/A");										strBody += strTemp;
	}
	// END JSY 2022-11-05 액튐검사 결과 추가 Liquid Drops

    if (vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod() == METHOD_CIRCLE)
	{
		//KJH 2021-10-26 각 Pos X,Y 로그 변경

		strTemp.Format(",MP_R");																	strHeader += strTemp;
		strTemp.Format(",%4.3f", pFormMain->m_dCircleRadius_MP * xres);								strBody += strTemp;
		strTemp.Format(",MP_X");																	strHeader += strTemp;
		strTemp.Format(",%4.3f", ((double)pFormMain->m_ptCircleCenter_MP.x - Center_W) * xres);		strBody += strTemp;
		strTemp.Format(",MP_Y");																	strHeader += strTemp;
		strTemp.Format(",%4.3f", (Center_H - (double)pFormMain->m_ptCircleCenter_MP.y) * yres);		strBody += strTemp;

		strTemp.Format(",PN_R");																	strHeader += strTemp;
		strTemp.Format(",%4.3f", m_dCircleRadius_PN * xres);										strBody += strTemp;
		strTemp.Format(",PN_X");																	strHeader += strTemp;
		strTemp.Format(",%4.3f", (m_ELB_TraceResult.m_ELB_ResultXY.x - Center_W) * xres);			strBody += strTemp;
		strTemp.Format(",PN_Y");																	strHeader += strTemp;
		strTemp.Format(",%4.3f", (Center_H - m_ELB_TraceResult.m_ELB_ResultXY.y) * yres);			strBody += strTemp;

		strTemp.Format(",CC_R");																	strHeader += strTemp;
		strTemp.Format(",%4.3f", pFormMain->m_dCircleRadius_CC * xres);								strBody += strTemp;
		strTemp.Format(",CC_X");																	strHeader += strTemp;
		strTemp.Format(",%4.3f", ((double)pFormMain->m_ptCircleCenter_CC.x - Center_W) * xres);		strBody += strTemp;
		strTemp.Format(",CC_Y");																	strHeader += strTemp;
		strTemp.Format(",%4.3f", (Center_H - (double)pFormMain->m_ptCircleCenter_CC.y) * yres);		strBody += strTemp;

		strTemp.Format(",WETOUT_X(mm)");															strHeader += strTemp;
		strTemp.Format(",%4.1f", (W/2 - m_dWetoutProperty[0]) * xres);								strBody += strTemp;
		strTemp.Format(",WETOUT_Y(mm)");															strHeader += strTemp;
		strTemp.Format(",%4.1f", (H/2 - m_dWetoutProperty[1]) * yres);								strBody += strTemp;
		strTemp.Format(",WETOUT_R(mm)");															strHeader += strTemp;
		strTemp.Format(",%4.1f", m_dWetoutProperty[2]* xres);										strBody += strTemp;
		strTemp.Format(",WETOUT_S");																strHeader += strTemp;
		strTemp.Format(",%4.1f", m_dWetoutProperty[3] * xres);										strBody += strTemp;
		strTemp.Format(",WETOUT_Mean");																strHeader += strTemp;
		strTemp.Format(",%4.1f", m_dWetoutProperty[4]);												strBody += strTemp;
		strTemp.Format(",WETOUT_Stdev");															strHeader += strTemp;
		strTemp.Format(",%4.1f", m_dWetoutProperty[5]);												strBody += strTemp;
		strTemp.Format(",WETOUT_Q2");																strHeader += strTemp;
		strTemp.Format(",%4.1f", m_dWetoutProperty[6]);												strBody += strTemp;
		strTemp.Format(",WETOUT_Q1");																strHeader += strTemp;
		strTemp.Format(",%4.1f", m_dWetoutProperty[7]);												strBody += strTemp;
		strTemp.Format(",WETOUT_Q3");																strHeader += strTemp;
		strTemp.Format(",%4.1f", m_dWetoutProperty[8]);												strBody += strTemp;
		strTemp.Format(",WETOUT_Ratio");				   											strHeader += strTemp; //210909 Tkyuha wetoutMin/WetoutMat 비율
		strTemp.Format(",%4.1f", maxDistance_in==0?1.0: minDistance_in /maxDistance_in);			strBody += strTemp;
	}

	strTemp.Format(",MIN DISTANCE_IN");																strHeader += strTemp;
	strTemp.Format(",%4.4f", minDistance_in);														strBody += strTemp;		//210909 Tkyuha 잘못 표기됨
	strTemp.Format(",MIN_IN_ANGLE");																strHeader += strTemp;
	strTemp.Format(",%4.1f", minmaxangle[0]);														strBody += strTemp;

	strTemp.Format(",MAX DISTANCE_IN");																strHeader += strTemp;
	strTemp.Format(",%4.4f", maxDistance_in);														strBody += strTemp;
	strTemp.Format(",MAX_IN_ANGLE");																strHeader += strTemp;
	strTemp.Format(",%4.1f", minmaxangle[1]);														strBody += strTemp;

	strTemp.Format(",MIN DISTANCE_OUT");															strHeader += strTemp;
	strTemp.Format(",%4.4f", minDistance_out);														strBody += strTemp;
	strTemp.Format(",MIN_OUT_ANGLE");																strHeader += strTemp;
	strTemp.Format(",%4.1f", minmaxangle[2]);														strBody += strTemp;

	strTemp.Format(",MAX DISTANCE_OUT");															strHeader += strTemp;
	strTemp.Format(",%4.4f", maxDistance_out);														strBody += strTemp;
	strTemp.Format(",MAX_OUT_ANGLE");																strHeader += strTemp;
	strTemp.Format(",%4.1f", minmaxangle[3]);														strBody += strTemp;

	strTemp.Format(",MIN DISTANCE");																strHeader += strTemp;
	strTemp.Format(",%4.4f", minDistance);															strBody += strTemp;
	strTemp.Format(",MIN_ANGLE");																	strHeader += strTemp;
	strTemp.Format(",%4.1f", minmaxangle[4]);														strBody += strTemp;

	strTemp.Format(",MAX DISTANCE");																strHeader += strTemp;
	strTemp.Format(",%4.4f", maxDistance);															strBody += strTemp;
	strTemp.Format(",MAX_ANGLE");																	strHeader += strTemp;
	strTemp.Format(",%4.1f", minmaxangle[5]);														strBody += strTemp;

	strTemp.Format(",METAL_CIRCLE");																strHeader += strTemp;
	strTemp.Format(",%4.4f", pFormMain->m_dCircleDistance_X_MP);									strBody += strTemp;

	if (vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod()==METHOD_CIRCLE)
	{
		int n=vt_job_info[algorithm].model_info.getAlignInfo().getInspResultCount();
		n = MIN(MAX(4, n),360);

		int step = 360 / n;
		for (int i = 0; i < n; i++)
		{
			int curDeg = (270 + (step * i))% 360;
			//KJH 2021-09-16 sx???ex?????? Wet_In / Wet_Out이 맞지않나???? Header도 -_-
			/*
			double sx = m_ELB_DiffInspResult[1].m_vTraceProfile[0].at(curDeg);
			double ex = m_ELB_DiffInspResult[1].m_vTraceProfile[1].at(curDeg);
			*/
			double m_nWetOut_In = m_ELB_DiffInspResult[datasheet + 1].m_vTraceProfile[0].at(curDeg);
			double m_nWetOut	= m_ELB_DiffInspResult[datasheet + 1].m_vTraceProfile[1].at(curDeg);
			double angle		= m_ELB_DiffInspResult[datasheet].m_vTraceProfile[2].at(curDeg);

			strTemp.Format(",%3d - Deg(WetOut_In)",		(90 + curDeg) % 360);						strHeader += strTemp;
			strTemp.Format(",%4.4f", m_nWetOut_In);													strBody += strTemp;
			strTemp.Format(",%3d - Deg(WetOut)",		(90 + curDeg) % 360);						strHeader += strTemp;
			strTemp.Format(",%4.4f", m_nWetOut);													strBody += strTemp;
			//KJH 2021-09-16 내용 중복 삭제
			//strTemp.Format(",%3d - Deg", (90 + curDeg) % 360);									strHeader += strTemp;
			//strTemp.Format(",%4.4f", angle);														strBody += strTemp;
		}
	}
	else
	{
		if (vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod() == METHOD_LINE)
		{
			for (int i = 0; i <8; i++)
			{
				strTemp.Format(",C%1d_Wet_In", i);													strHeader += strTemp;
				strTemp.Format(",%4.4f", m_dCPos[i].x);												strBody += strTemp;
				strTemp.Format(",C%1d_Wet_Out", i);													strHeader += strTemp;
				strTemp.Format(",%4.4f", m_dCPos[i].y);												strBody += strTemp;
			}
		}
		else
		{
			for (int i = 3; i >= 0; i--)
			{
				strTemp.Format(",C%1d_Wet_In", 4 - i);												strHeader += strTemp;
				strTemp.Format(",%4.4f", m_dCPos[i].x * xres);										strBody += strTemp;
				strTemp.Format(",C%1d_Wet_Out", 4 - i);												strHeader += strTemp;
				strTemp.Format(",%4.4f", m_dCPos[i].y * xres);										strBody += strTemp;
			}
		}

		//int n = vt_job_info[algorithm].model_info.getAlignInfo().getInspResultCount();
		//n = MIN(MAX(4, n), int(m_ELB_DiffInspResult[1].m_vTraceProfile[0].size()-1));
		//
		//int step =int( m_ELB_DiffInspResult[1].m_vTraceProfile[0].size() / n);
		//for (int i = 1; i <= n-1; i++)
		//{
		//	int curDeg = step * i;
		//	double sx = m_ELB_DiffInspResult[1].m_vTraceProfile[0].at(curDeg);
		//	double ex = m_ELB_DiffInspResult[1].m_vTraceProfile[1].at(curDeg);
		//	double angle = m_ELB_DiffInspResult[0].m_vTraceProfile[2].at(curDeg);
		//
		//	strTemp.Format(",C%3d", i);				strHeader += strTemp;
		//	strTemp.Format(",%4.4f", sx);			strBody += strTemp;
		//	strTemp.Format(",C%3d", i);				strHeader += strTemp;
		//	strTemp.Format(",%4.4f", ex);			strBody += strTemp;
		//	strTemp.Format(",C%3d", i);				strHeader += strTemp;
		//	strTemp.Format(",%4.4f", angle);		strBody += strTemp;
		//}

		double _length = (m_ELB_DiffInspResult[datasheet].m_ELB_ResultXY.y - m_ELB_DiffInspResult[datasheet].m_ELB_ResultXY.x) * xres;
		strTemp.Format(",Length(mm)");																	strHeader += strTemp;
		strTemp.Format(",%4.4f", _length);																strBody += strTemp;

		strTemp.Format(",Left(mm)");																	strHeader += strTemp;
		strTemp.Format(",%4.4f", (W/2 - m_ELB_DiffInspResult[datasheet].m_ELB_ResultXY.x) * xres);		strBody += strTemp;

		strTemp.Format(",Right(mm)");																	strHeader += strTemp;
		strTemp.Format(",%4.4f", (m_ELB_DiffInspResult[datasheet].m_ELB_ResultXY.y - W/2)* xres);		strBody += strTemp;
	}

	//KJH 2021-09-17 장재관 수석 요청으로 Insp Log에 Nozzle Distance Log 추가
	//Z축에 따른 미검사 가능성 설명드림 , 검사 Seq진행안할시 Log 저장 누락 설명드림
	//우선 Nozzle 폴더에도 Summary 남기자
	strTemp.Format(",Nozzle Gap(mm)");																	strHeader += strTemp;
	strTemp.Format(",%.3f", m_ELB_TraceResult.m_nNozzleCheckDistance);									strBody += strTemp;

	if (vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod() == METHOD_LINE)
	{
		strTemp.Format(",PocketToStart(mm)");															strHeader += strTemp;
		strTemp.Format(",%.3f", m_ELB_DiffInspResult[datasheet].m_ELB_ResultT);							strBody += strTemp;

		double _tl = fabs(m_ELB_DiffInspResult[datasheet].m_ELB_ResultAngle[1] - m_ELB_DiffInspResult[datasheet].m_ELB_ResultAngle[0]) * xres;
		strTemp.Format(",TotalLength(mm)");																strHeader += strTemp;
		strTemp.Format(",%.3f", _tl);																	strBody += strTemp;	

		strTemp.Format(",CGtoStart(mm)");																strHeader += strTemp;
		strTemp.Format(",%.3f", m_ELB_DiffInspResult[datasheet].m_ELB_ResultAngle[2]);	        		strBody += strTemp;

		strTemp.Format(",Overflow(mm)");																strHeader += strTemp;
		strTemp.Format(",%.3f", m_ELB_DiffInspResult[datasheet].m_ELB_ResultAngle[9]);	        		strBody += strTemp;
	}

	if (vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod() == METHOD_CIRCLE)
	{
		//Tkyuha 2022-03-10 도포 반대편 1/2 평균값 계산 추가

		strTemp.Format(",R Min");																		strHeader += strTemp;
		strTemp.Format(",%4.4f", m_ELB_DiffInspResult[datasheet].m_RminResult);	        				strBody += strTemp;
		strTemp.Format(",R Min Angle");																	strHeader += strTemp;
		strTemp.Format(",%4.1f", m_ELB_DiffInspResult[datasheet].m_RminAngle);	        				strBody += strTemp;

		strTemp.Format(",R Max");																		strHeader += strTemp;
		strTemp.Format(",%4.4f", m_ELB_DiffInspResult[datasheet].m_RmaxResult);	        				strBody += strTemp;
		strTemp.Format(",R Max Angle");																	strHeader += strTemp;
		strTemp.Format(",%4.1f", m_ELB_DiffInspResult[datasheet].m_RmaxAngle);	        				strBody += strTemp;

		for (int i = 0; i < 4; i++)
		{
			strTemp.Format(",%3d - Deg(R Value)", (i * 45));											strHeader += strTemp;
			strTemp.Format(",%4.4f", m_ELB_DiffInspResult[datasheet].m_RCheckangle[i]);					strBody += strTemp;
		}

		strTemp.Format(",B Min");																		strHeader += strTemp;
		strTemp.Format(",%4.4f", m_ELB_DiffInspResult[datasheet].m_BminResult);	        				strBody += strTemp;
		strTemp.Format(",B Min Angle");																	strHeader += strTemp;
		strTemp.Format(",%4.1f", m_ELB_DiffInspResult[datasheet].m_BminAngle);	        				strBody += strTemp;

		strTemp.Format(",B Max");																		strHeader += strTemp;
		strTemp.Format(",%4.4f", m_ELB_DiffInspResult[datasheet].m_BmaxResult);	        				strBody += strTemp;
		strTemp.Format(",B Max Angle");																	strHeader += strTemp;
		strTemp.Format(",%4.1f", m_ELB_DiffInspResult[datasheet].m_BmaxAngle);	        				strBody += strTemp;
		
		//KJH 2022-06-06 B 특수각 로그 및 보고관련 추가
		for (int i = 0; i < 8; i++)
		{
			strTemp.Format(",%3d - Deg(B Value)", (i * 45));											strHeader += strTemp;
			strTemp.Format(",%4.4f", m_ELB_DiffInspResult[datasheet].m_BCheckangle[i]);					strBody += strTemp;
		}

		//KJH 2022-07-01 Lack Of Cink Total Count 로그 추가
		strTemp.Format(",Lack Total");																	strHeader += strTemp;
		strTemp.Format(",%d", m_ELB_DiffInspResult[datasheet].m_nLackOfInkAngleCount_Total);	        strBody += strTemp;
		strTemp.Format(",Lack Continue");																strHeader += strTemp;
		strTemp.Format(",%d", m_ELB_DiffInspResult[datasheet].m_nLackOfInkAngleCount_Continue);	        strBody += strTemp;
		strTemp.Format(",Lack Judge");																	strHeader += strTemp;
		strTemp.Format(",%d", m_ELB_DiffInspResult[datasheet].m_nLackOfInkAngleCount_Judge);	        strBody += strTemp;
	}

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader == TRUE)
	{
		summaryFile.WriteString(strHeader);
	}
	
	summaryFile.SeekToEnd();
	summaryFile.WriteString(strBody);
	summaryFile.Close();

	WriteFile.WriteString(strHeader);
	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);

	strTemp.Format("Start_Dist, End_Dist, Angle,X_Pos, Y_Pos, WetOut_In, WetOut_Out, Metal_Dist, Lack_Of_Ink, CINK2_Dopo_Width\n");
	WriteFile.WriteString(strTemp);

	double a[10];
	
	for (int i = 0; i < m_ELB_DiffInspResult[datasheet].m_vTraceProfile[0].size(); i++)
	{
		a[0] = m_ELB_DiffInspResult[datasheet].m_vTraceProfile[0].at(i);
		a[1] = m_ELB_DiffInspResult[datasheet].m_vTraceProfile[1].at(i);
		a[2] = m_ELB_DiffInspResult[datasheet].m_vTraceProfile[2].at(i);
		a[3] = m_ELB_DiffInspResult[datasheet + 1].m_vTraceProfile[3].at(i);
		a[4] = m_ELB_DiffInspResult[datasheet + 1].m_vTraceProfile[4].at(i);
		a[5] = m_ELB_DiffInspResult[datasheet + 1].m_vTraceProfile[0].at(i);
		a[6] = m_ELB_DiffInspResult[datasheet + 1].m_vTraceProfile[1].at(i);
		a[7] = m_ELB_DiffInspResult[datasheet + 1].m_vTraceProfile[2].at(i);
		a[8] = m_ELB_DiffInspResult[datasheet]._bLackOfInkAlgleJudge[i];
		a[9] = m_ELB_DiffInspResult[datasheet]._dbCink2DopoWidth[i];

		strTemp.Format("%4.4f, %4.4f, %4.4f,%4.4f, %4.4f, %4.4f, %4.4f, %4.4f, %d, %4.4f\n", a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], bool(a[8]), a[9]);
		WriteFile.WriteString(strTemp);
	}

	WriteFile.Close();

	LeaveCriticalSection(&m_csScanWrite);
	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_Film_insp(CString serialNum, BOOL bjudge, int algorithm)
{
	EnterCriticalSection(&m_csScanWrite);

	CString strTemp, Time_str, Date_str, strSummary;
	CString strFileDir = m_strResultDir + m_strResultDate[algorithm];
	BOOL bWriteHeader = FALSE;

	CString algo_name = vt_job_info[algorithm].job_name.c_str();
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;;
	int real_cam = camBuf[0];

	CString stage = "NULL";
	if (algorithm == 0)	stage = "A1";
	else stage = "A2";

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d:%02d:%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		if (m_strResultTime[algorithm] == "")
			Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		else Time_str = m_strResultTime[algorithm];
		if (m_strResultDate[algorithm] == "")
			Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
		else Date_str = m_strResultDate[algorithm];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	strSummary.Format("%s%s_%s_InspSummary_Result.csv", strFileDir, stage, Date_str);
	strFileDir.Format("%sFilm_Insp\\", strFileDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_%s_Insp_Result_%s.csv", strFileDir, stage, serialNum, Time_str);

	if ((_access(strSummary, 0)) == -1)		bWriteHeader = TRUE;

	CStdioFile WriteFile, summaryFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}
	if (summaryFile.Open(strSummary, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}

	CString strHeader, strBody;

	strTemp.Format("TIME");																strHeader += strTemp;
	strTemp.Format("%s_%s", Date_str, Time_str);										strBody += strTemp;

	strTemp.Format(",MODEL ID");														strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);										strBody += strTemp;

	strTemp.Format(",PANEL ID");														strHeader += strTemp;
	strTemp.Format(",%s", serialNum);													strBody += strTemp;

	strTemp.Format(",STAGE");															strHeader += strTemp;
	strTemp.Format(",%s", stage);														strBody += strTemp;

	strTemp.Format(",JUDGE");															strHeader += strTemp;
	strTemp.Format(",%s", bjudge ? "OK" : "NG");										strBody += strTemp;		

	strTemp.Format(",LEFT DISTANCE");													strHeader += strTemp;
	strTemp.Format(",%4.4f", m_stInsp_DistanceResult[real_cam][0].dWidthDistance);	    strBody += strTemp;
	strTemp.Format(",RIGHT DISTANCE");													strHeader += strTemp;
	strTemp.Format(",%4.1f", m_stInsp_DistanceResult[real_cam][0].dHeightDistance);	    strBody += strTemp;

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader == TRUE)
	{
		summaryFile.WriteString(strHeader);
	}

	summaryFile.SeekToEnd();
	summaryFile.WriteString(strBody);
	summaryFile.Close();

	WriteFile.WriteString(strHeader);
	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);

	WriteFile.Close();

	LeaveCriticalSection(&m_csScanWrite);
	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_Film_insp_new(CString serialNum, BOOL bjudge, int algorithm)
{
	EnterCriticalSection(&m_csScanWrite);

	CString strTemp, Time_str, Date_str, strSummary;
	CString strFileDir = m_strResultDir + m_strResultDate[algorithm];
	BOOL bWriteHeader = FALSE;

	CString algo_name = vt_job_info[algorithm].job_name.c_str();
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;;
	int real_cam = camBuf[0];

	CString stage = "NULL";
	if (m_nClientID == 3)	stage = "A1";
	else stage = "A2";

	stage.Format("A%d", algorithm);

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		if (m_strResultTime[algorithm] == "")
			Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		else Time_str = m_strResultTime[algorithm];
		if (m_strResultDate[algorithm] == "")
			Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
		else Date_str = m_strResultDate[algorithm];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%sFilm_Insp\\", strFileDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	if (m_bSimulationStart)
	{
		strFileDir.Format("%ssimulation\\", strFileDir);
		if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	}

	strSummary.Format("%s%s_%s_InspSummary_Result.csv", strFileDir, stage, Date_str);
	strTemp.Format("%s%s_%s_Insp_Result_%s.csv", strFileDir, stage, serialNum, Time_str);

	if ((_access(strSummary, 0)) == -1)		bWriteHeader = TRUE;
	if ((_access(strTemp, 0)) == -1)		bWriteHeader = TRUE;

	CStdioFile WriteFile, summaryFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}
	if (summaryFile.Open(strSummary, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}

	CString strHeader, strBody;

	strTemp.Format("TIME");									strHeader += strTemp;
	strTemp.Format("%s_%s", Date_str, Time_str);			strBody += strTemp;

	strTemp.Format(",MODEL ID");							strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);			strBody += strTemp;

	strTemp.Format(",PANEL ID");							strHeader += strTemp;
	strTemp.Format(",%s", serialNum);						strBody += strTemp;

	strTemp.Format(",STAGE");								strHeader += strTemp;
	strTemp.Format(",%s", stage);							strBody += strTemp;

	strTemp.Format(",JUDGE");								strHeader += strTemp;
	strTemp.Format(",%s", bjudge ? "OK" : "NG");			strBody += strTemp;

	
	PF_FILM_INSP *pData = &vt_result_info[algorithm].pf_film_insp_data;
	
	strTemp.Format(",panel_lx");							strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->panel_pos_x[0]);	    strBody += strTemp;
	strTemp.Format(",panel_ly");							strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->panel_pos_y[0]);	    strBody += strTemp;

	strTemp.Format(",panel_rx");							strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->panel_pos_x[1]);	    strBody += strTemp;
	strTemp.Format(",panel_ry");							strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->panel_pos_y[1]);	    strBody += strTemp;

	strTemp.Format(",film_lx");								strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->film_pos_x[0]);			strBody += strTemp;
	strTemp.Format(",film_ly");								strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->film_pos_y[0]);			strBody += strTemp;

	strTemp.Format(",film_rx");								strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->film_pos_x[1]);			strBody += strTemp;
	strTemp.Format(",film_ry");								strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->film_pos_y[1]);			strBody += strTemp;

	// hsj 2022-01-12 file 결과값 저장 시 method에 따라서 다르게...  ___START
	
	int iFilmInspMethod = vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFilmInspMethod();

	CString strMethod = "";
	switch (iFilmInspMethod)
	{
	case 0: strMethod = "C"; break;
	case 1: strMethod = "L"; break;
	case 2: strMethod = "R"; break;
	case 3: strMethod = "M"; break;
	case 4: strMethod = "A"; break;
	}

	if (iFilmInspMethod == 4)
	{
		for (int i = 0; i < 3; i++)
		{
			switch (i)
			{
			case 0: strMethod = "C"; break;
			case 1: strMethod = "L"; break;
			case 2: strMethod = "R"; break;
			}

			strTemp.Format(",%s <-> LTX", strMethod);					strHeader += strTemp;
			strTemp.Format(",%4.4f", pData->dist_lx[i]);				strBody += strTemp;
			strTemp.Format(",%s <-> LTY", strMethod);					strHeader += strTemp;
			strTemp.Format(",%4.4f", pData->dist_ly[i]);				strBody += strTemp;

			strTemp.Format(",%s <-> RTX", strMethod);					strHeader += strTemp;
			strTemp.Format(",%4.4f", pData->dist_rx[i]);				strBody += strTemp;
			strTemp.Format(",%s <-> RTY", strMethod);					strHeader += strTemp;
			strTemp.Format(",%4.4f", pData->dist_ry[i]);				strBody += strTemp;
		}
	}
	else if (iFilmInspMethod == 3)
	{
		strTemp.Format(",L <-> LTX");									strHeader += strTemp;
		strTemp.Format(",%4.4f", pData->dist_lx[1]);					strBody += strTemp;
		strTemp.Format(",L <-> LTY");									strHeader += strTemp;
		strTemp.Format(",%4.4f", pData->dist_ly[1]);					strBody += strTemp;

		strTemp.Format(",R <-> RTX");									strHeader += strTemp;
		strTemp.Format(",%4.4f", pData->dist_rx[2]);					strBody += strTemp;
		strTemp.Format(",R <-> RTY");									strHeader += strTemp;
		strTemp.Format(",%4.4f", pData->dist_ry[2]);					strBody += strTemp;
	}
	else
	{
		strTemp.Format(",%s <-> LTX", strMethod);						strHeader += strTemp;
		strTemp.Format(",%4.4f", pData->dist_lx[iFilmInspMethod]);		strBody += strTemp;
		strTemp.Format(",%s <-> LTY", strMethod);						strHeader += strTemp;
		strTemp.Format(",%4.4f", pData->dist_ly[iFilmInspMethod]);		strBody += strTemp;

		strTemp.Format(",%s <-> RTX", strMethod);						strHeader += strTemp;
		strTemp.Format(",%4.4f", pData->dist_rx[iFilmInspMethod]);		strBody += strTemp;
		strTemp.Format(",%s <-> RTY", strMethod);						strHeader += strTemp;
		strTemp.Format(",%4.4f", pData->dist_ry[iFilmInspMethod]);		strBody += strTemp;
	}

	////////END

	strTemp.Format(",Film Angle");										strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->film_angle);						strBody += strTemp;

	strTemp.Format(",Panel Angle");										strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->panel_angle);						strBody += strTemp;

	strTemp.Format(",Attach Angle");									strHeader += strTemp;
	strTemp.Format(",%4.4f", pData->attach_angle);						strBody += strTemp;

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader == TRUE)
	{
		summaryFile.WriteString(strHeader);
	}

	summaryFile.SeekToEnd();
	summaryFile.WriteString(strBody);
	summaryFile.Close();

	WriteFile.WriteString(strHeader);
	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);

	WriteFile.Close();

	LeaveCriticalSection(&m_csScanWrite);
	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_NozzleView_insp(CString serialNum, BOOL bjudge, int algorithm)
{
	EnterCriticalSection(&m_csScanWrite);

	CString strTemp, Time_str, Date_str, strSummary;
	CString strFileDir = m_strResultDir + m_strResultDate[algorithm];
	BOOL bWriteHeader = FALSE;

	CString algo_name = vt_job_info[algorithm].job_name.c_str();
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;;
	int real_cam = camBuf[0];

	CString stage = "NULL";
	if (m_nClientID == 3)	stage = "A1";
	else stage = "A2";

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		if (m_strResultTime[algorithm] == "")
			Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		else Time_str = m_strResultTime[algorithm];
		if (m_strResultDate[algorithm] == "")
			Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
		else Date_str = m_strResultDate[algorithm];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	strSummary.Format("%s%s_%s_InspSummary_Result.csv", strFileDir, stage, Date_str);
	strFileDir.Format("%sNozzleView_Insp\\", strFileDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_%s_Insp_Result_%s.csv", strFileDir, stage, serialNum, Time_str);

	if ((_access(strSummary, 0)) == -1)		bWriteHeader = TRUE;

	CStdioFile WriteFile, summaryFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}
	if (summaryFile.Open(strSummary, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}

	CString strHeader, strBody;

	strTemp.Format("TIME");																strHeader += strTemp;
	strTemp.Format("%s_%s", Date_str, Time_str);										strBody += strTemp;

	strTemp.Format(",MODEL ID");														strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);										strBody += strTemp;

	strTemp.Format(",PANEL ID");														strHeader += strTemp;
	strTemp.Format(",%s", serialNum);													strBody += strTemp;

	strTemp.Format(",STAGE");															strHeader += strTemp;
	strTemp.Format(",%s", stage);														strBody += strTemp;

	strTemp.Format(",JUDGE");															strHeader += strTemp;
	strTemp.Format(",%s", bjudge ? "OK" : "NG");										strBody += strTemp;

	strTemp.Format(",LEFT DISTANCE");													strHeader += strTemp;
	strTemp.Format(",%4.4f", m_stInsp_DistanceResult[real_cam][0].dWidthDistance);	    strBody += strTemp;
	strTemp.Format(",RIGHT DISTANCE");													strHeader += strTemp;
	strTemp.Format(",%4.1f", m_stInsp_DistanceResult[real_cam][0].dHeightDistance);	    strBody += strTemp;

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader == TRUE)
	{
		summaryFile.WriteString(strHeader);
	}

	summaryFile.SeekToEnd();
	summaryFile.WriteString(strBody);
	summaryFile.Close();

	WriteFile.WriteString(strHeader);
	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);

	WriteFile.Close();

	LeaveCriticalSection(&m_csScanWrite);
	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_align_data_1cam_1shot_ELB(CString serialNum, BOOL bJudge, int algo){
	CString strTemp, Time_str, Date_str;

	//CString strFileDir = m_strResultDir + m_strResultDate[algo];
	// YCS 2022-11-28 병준짱 요청사항
	CString strFileDir = NULL;
	BOOL bWriteHeader = FALSE;
	// YCS 2022-11-28 병준짱 요청사항
	strFileDir.Format("%s%s", m_strResultDir, m_strResultDate[algo]);

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);
	CString algo_name = m_pAlgorithmInfo.getAlgorithmName(algo).c_str();
#else
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	CString algo_name = vt_job_info[algo].job_name.c_str();
#endif

	CString stage = "NULL";
	if		(m_nClientID == 3)	stage = "A1";
	else if (m_nClientID == 4)	stage = "A2";
	else if (m_nClientID == 5)	stage = "B1";
	else if (m_nClientID == 6)	stage = "B2";

	int cam_no[8] = { 0, };

	for (int i = 0; i < camCount; i++)
	{
		cam_no[i] = camBuf.at(i);
	}

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		Time_str = m_strResultTime[algo];
		Date_str = m_strResultDate[algo];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_%s_Result_%s.csv", strFileDir, stage, algo_name, Date_str);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}

	// 매번 불필요하게 header 부분에 대한 처리가 들어 가지만, 
	// Header<->Body 작성시 실수를 줄이기 위함.
	CString strHeader, strBody;

	strTemp.Format("TIME");																					strHeader += strTemp;
	strTemp.Format("%s", Time_str);																			strBody += strTemp;

	strTemp.Format(",MODEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);															strBody += strTemp;

	strTemp.Format(",PANEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", serialNum);																		strBody += strTemp;

	strTemp.Format(",JUDGE");																				strHeader += strTemp;
	strTemp.Format(",%s", bJudge ? "OK" : "NG");															strBody += strTemp;

	strTemp.Format(",X");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_X]);												strBody += strTemp;

	strTemp.Format(",Y");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_Y]);												strBody += strTemp;

	strTemp.Format(",T");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_T]);												strBody += strTemp;

	strTemp.Format(",MARK X1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).GetYPos());									strBody += strTemp;
	

	//KJH L-Check를 과연... 써야되나??
	if (vt_job_info[algo].model_info.getAlignInfo().getEnableLCheck() == TRUE)
	{
		strTemp.Format(",L-Check JUDGE");																	strHeader += strTemp;
		strTemp.Format(",L-Check");																			strHeader += strTemp;
		strTemp.Format(",L-Check Spec");																	strHeader += strTemp;

		double dist_tor = vt_job_info[algo].model_info.getAlignInfo().getLCheckTor();
		double dist_spec = 0;
		int target_dir = vt_job_info[algo].model_info.getAlignInfo().getAlignmentTargetDir();	// vertical or horizontal
		if (target_dir == 0)	dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecX();// horizontal
		else					dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecY();// vertical

		strTemp.Format(",%s", m_bLcheckNG[algo] ? "NG" : "OK");												strBody += strTemp;
		strTemp.Format(",%.3f", m_dbLCheck[algo][0]);														strBody += strTemp;
		strTemp.Format(",%.3f ~ %.3f", dist_spec - dist_tor, dist_spec + dist_tor);							strBody += strTemp;
	}
	else
	{
		strTemp.Format(",L-Check");																			strHeader += strTemp;
		strTemp.Format(",NO USE");																			strBody += strTemp;
	}

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader)
	{
		WriteFile.WriteString(strHeader);
	}

	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);
	WriteFile.Close();

	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_pcb_distance_insp(CString serialNum, BOOL bjudge, int algo)
{
	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algo];
	BOOL bWriteHeader = FALSE;

	/*
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);
	CString algo_name = m_pAlgorithmInfo.getAlgorithmName(algo).c_str();
	*/
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	CString algo_name = vt_job_info[algo].job_name.c_str();
	int real_cam = camBuf[0];

	int cam_no[8] = { 0, };

	for (int i = 0; i < camCount; i++)
	{
		cam_no[i] = camBuf.at(i);
	}

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);

	if (m_bSimulationStart)
	{
		Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		Time_str = m_strResultTime[algo];
		Date_str = m_strResultDate[algo];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_Result_%s.csv", strFileDir, algo_name, Date_str);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}
	CString strHeader, strBody;

	// 매번 불필요하게 header 부분에 대한 처리가 들어 가지만, 
	// Header<->Body 작성시 실수를 줄이기 위함.

	strTemp.Format("TIME");																								strHeader += strTemp;
	strTemp.Format("%s", Time_str);																						strBody += strTemp;

	strTemp.Format(",MODEL ID");																						strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);																		strBody += strTemp;

	strTemp.Format(",PANEL ID");																						strHeader += strTemp;
	strTemp.Format(",%s", serialNum);																					strBody += strTemp;

	strTemp.Format(",JUDGE_PG");																						strHeader += strTemp;
	strTemp.Format(",%s", bjudge ? "OK" : "NG");																		strBody += strTemp;

	strTemp.Format(",JUDGE_RCS");																						strHeader += strTemp;
	switch (vt_result_info[algo].rcs_judge) {
	case 1:	strTemp = ",OK";	break;	case 2:	strTemp = ",NG";	break;	default:	strTemp = ",N/A";	break;	}	strBody += strTemp;

	int total_point = m_nSeqTotalInspGrabCount * 2 + 2;	
	for (int i = 0; i < total_point; i++)
	{
		strTemp.Format(",GAP_P%d", i + 1);																				strHeader += strTemp;
		strTemp.Format(",%.3f", m_dDistanceInspDataResult[i]);															strBody += strTemp;
	}
	
	for (int i = 0; i < total_point; i++)
	{
		strTemp.Format(",LSL_%d", i + 1);																				strHeader += strTemp;
		strTemp.Format(",%.3f", vt_job_info[algo].model_info.getAlignInfo().getDistanceInspSpecLSL(i));					strBody += strTemp;
	}
	
	for (int i = 0; i < total_point; i++)
	{
		strTemp.Format(",USL_%d", i + 1);																				strHeader += strTemp;
		strTemp.Format(",%.3f", vt_job_info[algo].model_info.getAlignInfo().getDistanceInspSpecUSL(i));					strBody += strTemp;
	}

	for (int i = 0; i < total_point; i++)
	{
		strTemp.Format(",GAP_P%d_JUDGE", i + 1);																		strHeader += strTemp;
		strTemp.Format(",%s", m_dDistanceInspJudgeResult[i] ? "OK" : "NG");												strBody += strTemp;
	}

	strTemp.Format(",POS_X_PNL_L");																						strHeader += strTemp;
	strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 0][0].xPos[0]);											strBody += strTemp;
	strTemp.Format(",POS_Y_PNL_L");																						strHeader += strTemp;
	strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 0][0].yPos[0]);											strBody += strTemp;

	strTemp.Format(",POS_X_PNL_R");																						strHeader += strTemp;
	strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 1][m_nSeqTotalInspGrabCount - 1].xPos[0]);				strBody += strTemp;
	strTemp.Format(",POS_Y_PNL_L");																						strHeader += strTemp;
	strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 1][m_nSeqTotalInspGrabCount - 1].yPos[0]);				strBody += strTemp;

	for (int i = 0; i < m_nSeqTotalInspGrabCount; i++)
	{
		strTemp.Format(",POS_X_TAB%d_%s", i / 2 + 1, i % 2 ? "R" : "L");												strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 0][i].xPos[1]);										strBody += strTemp;
		strTemp.Format(",POS_Y_TAB%d_%s", i / 2 + 1, i % 2 ? "R" : "L");												strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 0][i].yPos[1]);										strBody += strTemp;
	}

	// tab수는	m_nSeqTotalInspGrabCount / 2 이다.
	// 2번 카메라의 시작 tab번호도 m_nSeqTotalInspGrabCount / 2 이다.
	int tab_off = m_nSeqTotalInspGrabCount / 2;
	for (int i = 0; i < m_nSeqTotalInspGrabCount; i++)
	{
		strTemp.Format(",POS_X_TAB%d_%s", i / 2 + 1 + tab_off, i % 2 ? "R" : "L");										strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 1][i].xPos[1]);										strBody += strTemp;
		strTemp.Format(",POS_Y_TAB%d_%s", i / 2 + 1 + tab_off, i % 2 ? "R" : "L");										strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 1][i].yPos[1]);										strBody += strTemp;
	}

	strTemp.Format(",ANG_PNL_L");																						strHeader += strTemp;
	strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 0][0].included_angle[0]);								strBody += strTemp;

	strTemp.Format(",ANG_PNL_R");																						strHeader += strTemp;
	strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 1][m_nSeqTotalInspGrabCount - 1].included_angle[0]);		strBody += strTemp;

	for (int i = 0; i < m_nSeqTotalInspGrabCount; i++)
	{
		strTemp.Format(",ANG_TAB%d_%s", i / 2 + 1, i % 2 ? "R" : "L");													strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 0][i].included_angle[1]);							strBody += strTemp;
	}

	// tab수는	m_nSeqTotalInspGrabCount / 2 이다.
	// 2번 카메라의 tab번호는 tab수  / 2 이다.
	for (int i = 0; i < m_nSeqTotalInspGrabCount; i++)
	{
		strTemp.Format(",ANG_TAB%d_%s", i / 2 + 1 + tab_off, i % 2 ? "R" : "L");										strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 1][i].included_angle[1]);							strBody += strTemp;
	}


	// avg gray level
	for (int i = 0; i < m_nSeqTotalInspGrabCount; i++)
	{
		strTemp.Format(",AVG_GRAY_TAB%d_%s", i / 2 + 1 + 0, i % 2 ? "R" : "L");											strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 0][i].avg_image_gray);								strBody += strTemp;
	}

	for (int i = 0; i < m_nSeqTotalInspGrabCount; i++)
	{
		strTemp.Format(",AVG_GRAY_TAB%d_%s", i / 2 + 1 + tab_off, i % 2 ? "R" : "L");									strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + 1][i].avg_image_gray);								strBody += strTemp;
	}

	// matching rate
	for (int i = 0; i < m_nSeqTotalInspGrabCount; i++)
	{
		strTemp.Format(",MATCH_RATE_TAB%d_%s", i / 2 + 1 + 0, i % 2 ? "R" : "L");										strHeader += strTemp;
		strTemp.Format(",%.3f", GetMatching(algo).getFindInfo(0, i).getScore());										strBody += strTemp;
	}

	for (int i = 0; i < m_nSeqTotalInspGrabCount; i++)
	{
		strTemp.Format(",MATCH_RATE_TAB%d_%s", i / 2 + 1 + tab_off, i % 2 ? "R" : "L");									strHeader += strTemp;
		strTemp.Format(",%.3f", GetMatching(algo).getFindInfo(1, i).getScore());										strBody += strTemp;
	}

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader)
	{
		WriteFile.WriteString(strHeader);
	}

	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);
	WriteFile.Close();

	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_assemble_insp(CString serialNum, BOOL bjudge, int algorithm)
{
	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algorithm];
	BOOL bWriteHeader = FALSE;

	CString algo_name = vt_job_info[algorithm].job_name.c_str();

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		Time_str = m_strResultTime[algorithm];
		Date_str = m_strResultDate[algorithm];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_Result_%s.csv", strFileDir, algo_name, Date_str);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}
	int nCamCount = vt_job_info[algorithm].num_of_camera;

	CString strHeader, strBody;
	CString str_side[4] = { "LT", "RT", "LB", "RB" };

	strTemp.Format("TIME");																								strHeader += strTemp;
	strTemp.Format("%s", Time_str);																						strBody += strTemp;

	strTemp.Format(",MODEL ID");																						strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);																		strBody += strTemp;

	strTemp.Format(",PANEL ID");																						strHeader += strTemp;
	strTemp.Format(",%s", serialNum);																					strBody += strTemp;

	strTemp.Format(",JUDGE_PG");																						strHeader += strTemp;
	strTemp.Format(",%s", bjudge ? "OK" : "NG");																		strBody += strTemp;

	strTemp.Format(",JUDGE_RCS");																						strHeader += strTemp;
	switch (vt_result_info[algorithm].rcs_judge) {
	case 1:	strTemp = ",OK";	break;	case 2:	strTemp = ",NG";	break;	default:	strTemp = ",N/A";	break;	}	strBody += strTemp;


	for (int i = 0; i < 8; i++)
	{
		strTemp.Format(",GAP P%d", i + 1);																				strHeader += strTemp;
		strTemp.Format(",%.3f", m_dDistanceInspDataResult[i]);															strBody += strTemp;
	}
	for (int i = 0; i < 8; i++)
	{
		strTemp.Format(",LSL_P%d", i + 1);																				strHeader += strTemp;
		strTemp.Format(",%.3f", vt_job_info[algorithm].model_info.getAlignInfo().getDistanceInspSpecLSL(i));			strBody += strTemp;
	}
	for (int i = 0; i < 8; i++)
	{
		strTemp.Format(",USL_P%d", i + 1);																				strHeader += strTemp;
		strTemp.Format(",%.3f", vt_job_info[algorithm].model_info.getAlignInfo().getDistanceInspSpecUSL(i));			strBody += strTemp;
	}
	for (int i = 0; i < 8; i++)
	{
		strTemp.Format(",GAP_P%d_JUDGE", i + 1);																		strHeader += strTemp;
		strTemp.Format(",%s", m_dDistanceInspJudgeResult[i] ? "OK" : "NG");												strBody += strTemp;
	}
	for (int i = 0; i < 4; i++)
	{
		strTemp.Format(",TILT_%d", i + 1);																				strHeader += strTemp;
		strTemp.Format(",%.3f", m_dDistanceInspSubDataResult[i]);														strBody += strTemp;
	}
	for (int i = 0; i < 4; i++)
	{
		strTemp.Format(",TILT_%d_SPEC", i + 1);																			strHeader += strTemp;
		strTemp.Format(",%.3f",	vt_job_info[algorithm].model_info.getAlignInfo().getDistanceInspSubSpec(i)
								+vt_job_info[algorithm].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(0));	strBody += strTemp;
	}

	for (int i = 0; i < 4; i++)
	{
		strTemp.Format(",TILT_%d_JUDGE", i + 1);																		strHeader += strTemp;
		strTemp.Format(",%s", m_dDistanceInspSubJudgeResult[i] ? "OK" : "NG");											strBody += strTemp;
	}

	strTemp.Format(",GAP_P1_P6");																						strHeader += strTemp;
	strTemp.Format(",%.3f", m_dDistanceInspDataResult[0] + m_dDistanceInspDataResult[5]);								strBody += strTemp;

	strTemp.Format(",GAP_P2_P5");																						strHeader += strTemp;
	strTemp.Format(",%.3f", m_dDistanceInspDataResult[1] + m_dDistanceInspDataResult[4]);								strBody += strTemp;

	strTemp.Format(",GAP_P3_P8");																						strHeader += strTemp;
	strTemp.Format(",%.3f", m_dDistanceInspDataResult[2] + m_dDistanceInspDataResult[7]);								strBody += strTemp;
	
	strTemp.Format(",GAP_P4_P7");																						strHeader += strTemp;
	strTemp.Format(",%.3f", m_dDistanceInspDataResult[3] + m_dDistanceInspDataResult[6]);								strBody += strTemp;

	int real_cam = vt_job_info[algorithm].camera_index[0];

	for (int i = 0; i < 4; i++)
	{
		strTemp.Format(",PNL_ANG_%s", str_side[i]);																		strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + i][0].included_angle[0]);							strBody += strTemp;
	}

	for (int i = 0; i < 4; i++)
	{
		strTemp.Format(",BOT_ANG_%s", str_side[i]);																		strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + i][0].included_angle[1]);							strBody += strTemp;
	}

	for (int i = 0; i < 4; i++)
	{
		strTemp.Format(",PNL_X_%s", str_side[i]);																		strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + i][0].xPos[0]);										strBody += strTemp;
		strTemp.Format(",PNL_Y_%s", str_side[i]);																		strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + i][0].yPos[0]);										strBody += strTemp;
	}

	for (int i = 0; i < 4; i++)
	{
		strTemp.Format(",BOT_X_%s", str_side[i]);																		strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + i][0].xPos[1]);										strBody += strTemp;
		strTemp.Format(",BOT_Y_%s", str_side[i]);																		strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + i][0].yPos[1]);										strBody += strTemp;
	}

	for (int i = 0; i < 4; i++)
	{
		strTemp.Format(",AVG_GRAY_%s", str_side[i]);																	strHeader += strTemp;
		strTemp.Format(",%.3f", m_stInsp_DistanceResult[real_cam + i][0].avg_image_gray);								strBody += strTemp;
	}

	for (int i = 0; i < 4; i++)
	{
		strTemp.Format(",MATCH_RATE_%s", str_side[i]);																	strHeader += strTemp;
		strTemp.Format(",%.3f", GetMatching(algorithm).getFindInfo(i, 0).getScore());									strBody += strTemp;
	}


	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader)
	{
		WriteFile.WriteString(strHeader);
	}

	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);
	WriteFile.Close();

	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_align_data_1cam_2object(CString serialNum, BOOL bJudge, int algo)
{
	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algo];
	BOOL bWriteHeader = FALSE;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);
	CString algo_name = m_pAlgorithmInfo.getAlgorithmName(algo).c_str();
#else
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	CString algo_name = vt_job_info[algo].job_name.c_str();
#endif

	int cam_no[8] = { 0, };

	for (int i = 0; i < camCount; i++)
	{
		cam_no[i] = camBuf.at(i);
	}

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		Time_str = m_strResultTime[algo];
		Date_str = m_strResultDate[algo];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_Result_%s.csv", strFileDir, algo_name, Date_str);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}

	if (bWriteHeader)
	{
		//KJH 2021-08-14 Mark Find Method 분기(캘리퍼시 로그 방식 추가 ANGLE / ANGLE -> SCORE변환)
		if (vt_job_info[algo].model_info.getAlignInfo().getMarkFindMethod() == METHOD_CALIPER)
		{
			strTemp = "MODEL ID,CELL ID,TIME,MARK_X1,MARK_Y1,MARK_X2,MARK_Y2,MARK_X3,MARK_Y3,MARK_X3,MARK_Y3,X1,Y1,T1,X2,Y2,T2,POS1-ANGLE(˚),POS2-ANGLE(˚),POS3-ANGLE(˚),POS4-ANGLE(˚),ANGLE1-SCORE(%),ANGLE2-SCORE(%),ANGLE3-SCORE(%),ANGLE4-SCORE(%),JUDGE\n";
		}
		else
		{
			strTemp = "MODEL ID,CELL ID,TIME,MARK_X1,MARK_Y1,MARK_X2,MARK_Y2,MARK_X3,MARK_Y3,MARK_X3,MARK_Y3,X1,Y1,T1,X2,Y2,T2,MARK1-SCORE(%),MARK2-SCORE(%),MARK3-SCORE(%),MARK4-SCORE(%),JUDGE\n";
		}
		WriteFile.WriteString(strTemp);
	}

	WriteFile.SeekToEnd();

	//KJH 2021-08-14 Mark Find Method 분기(캘리퍼시 로그 방식 추가 ANGLE / ANGLE -> SCORE변환)
	if (vt_job_info[algo].model_info.getAlignInfo().getMarkFindMethod() == METHOD_CALIPER)
	{
		WriteFile.SeekToEnd();

		strTemp.Format(_T("%s,%s,%s,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f, %s\n"),
			m_strCurrentModelName,
			serialNum,
			Time_str,
			GetMatching(algo).getFindInfo(0, 0).GetXPos(),
			GetMatching(algo).getFindInfo(0, 0).GetYPos(),
			GetMatching(algo).getFindInfo(0, 1).GetXPos(),
			GetMatching(algo).getFindInfo(0, 1).GetYPos(),
			GetMatching(algo).getFindInfo(0, 2).GetXPos(),
			GetMatching(algo).getFindInfo(0, 2).GetYPos(),
			GetMatching(algo).getFindInfo(0, 3).GetXPos(),
			GetMatching(algo).getFindInfo(0, 3).GetYPos(),
			m_dbRevisionData_obejct[algo][AXIS_X][0],
			m_dbRevisionData_obejct[algo][AXIS_Y][0],
			m_dbRevisionData_obejct[algo][AXIS_T][0],
			m_dbRevisionData_obejct[algo][AXIS_X][1],
			m_dbRevisionData_obejct[algo][AXIS_Y][1],
			m_dbRevisionData_obejct[algo][AXIS_T][1],
			GetMatching(algo).getFindInfo(0, 0).getCaliperAngle(),
			GetMatching(algo).getFindInfo(0, 1).getCaliperAngle(),
			GetMatching(algo).getFindInfo(0, 2).getCaliperAngle(),
			GetMatching(algo).getFindInfo(0, 3).getCaliperAngle(),
			GetMatching(algo).getFindInfo(0, 0).getScore(),
			GetMatching(algo).getFindInfo(0, 1).getScore(),
			GetMatching(algo).getFindInfo(0, 2).getScore(),
			GetMatching(algo).getFindInfo(0, 3).getScore(),
			bJudge ? "OK" : "NG"
		);
	}
	else
	{
		WriteFile.SeekToEnd();

		strTemp.Format(_T("%s,%s,%s,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.1f,%.1f,%.1f,%.1f, %s\n"),
			m_strCurrentModelName,
			serialNum,
			Time_str,
			GetMatching(algo).getFindInfo(0, 0).GetXPos(),
			GetMatching(algo).getFindInfo(0, 0).GetYPos(),
			GetMatching(algo).getFindInfo(0, 1).GetXPos(),
			GetMatching(algo).getFindInfo(0, 1).GetYPos(),
			GetMatching(algo).getFindInfo(0, 2).GetXPos(),
			GetMatching(algo).getFindInfo(0, 2).GetYPos(),
			GetMatching(algo).getFindInfo(0, 3).GetXPos(),
			GetMatching(algo).getFindInfo(0, 3).GetYPos(),
			m_dbRevisionData_obejct[algo][AXIS_X][0],
			m_dbRevisionData_obejct[algo][AXIS_Y][0],
			m_dbRevisionData_obejct[algo][AXIS_T][0],
			m_dbRevisionData_obejct[algo][AXIS_X][1],
			m_dbRevisionData_obejct[algo][AXIS_Y][1],
			m_dbRevisionData_obejct[algo][AXIS_T][1],
			GetMatching(algo).getFindInfo(0, 0).getScore(),
			GetMatching(algo).getFindInfo(0, 1).getScore(),
			GetMatching(algo).getFindInfo(0, 2).getScore(),
			GetMatching(algo).getFindInfo(0, 3).getScore(),
			bJudge ? "OK" : "NG"
		);
	}

	WriteFile.WriteString(strTemp);
	WriteFile.Close();

	return TRUE;
}


//KJH2 2022-08-20 Rotate Data 생성
BOOL CLET_AlignClientDlg::write_result_rotate_data(CString strImageDirPath, BOOL bJudge, int algo, double xr, double xy)
{
	CString strTemp, Time_str, Date_str, Month_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algo];
	BOOL bWriteHeader = FALSE;

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	Time_str.Format("%02d:%02d:%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
	Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	Month_str.Format("%04d%02d", csTime.wYear, csTime.wMonth);

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%sRotate\\", strFileDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Month_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s_Rotate_Result_Data.csv", strFileDir, Month_str);
	if ((_access(strFileDir, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}


	CStdioFile WriteFile;
	if (WriteFile.Open(strFileDir, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strFileDir.Mid(strFileDir.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}

	if (bWriteHeader)
	{
		strTemp = "Stage,JUDGE,DATE,TIME,SPEC,X,Y,ImageDirPath\n";
		WriteFile.WriteString(strTemp);
	}

	WriteFile.SeekToEnd();

	strTemp.Format(_T("%s,%s,%s,%s,%.4f,%.4f,%.4f,%s\n"),
		m_strClientName,
		bJudge ? "OK" : "NG",
		Date_str,
		Time_str,
		vt_job_info[0].model_info.getInspSpecParaInfo().getRotateC_Spec(),
		xr,
		xy,
		strImageDirPath
	);

	WriteFile.WriteString(strTemp);
	WriteFile.Close();

	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_rotate_data_PC1(CString strImageDirPath, BOOL bJudge, int algo, double xr, double xy)
{
	CString strPC1Path;
	CString strTemp, Time_str, Date_str, Month_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algo];
	BOOL bWriteHeader = FALSE;

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	Time_str.Format("%02d:%02d:%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
	Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	Month_str.Format("%04d%02d", csTime.wYear, csTime.wMonth);
	
	strPC1Path.Format("\\\\192.168.0.100\\Share(PC1)\\99. Rotate\\");
	if (_access(strPC1Path, 0) != 0)	CreateDirectory(strPC1Path, NULL);
	strFileDir.Format("%s%s_Rotate_Result_Data.csv", strPC1Path, Month_str);
	if ((_access(strFileDir, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	strImageDirPath.Delete(0, 3);
	if (m_nClientID == 3) strImageDirPath.Format("\\\\192.168.0.120\\%s", strImageDirPath);
	else if (m_nClientID == 4) strImageDirPath.Format("\\\\192.168.0.130\\%s", strImageDirPath);
	else if (m_nClientID == 5) strImageDirPath.Format("\\\\192.168.0.140\\%s", strImageDirPath);
	else if (m_nClientID == 6) strImageDirPath.Format("\\\\192.168.0.150\\%s", strImageDirPath);

	if (m_nClientID == 3) Delay(100);
	else if (m_nClientID == 4) Delay(300);
	else if (m_nClientID == 5) Delay(200);
	else if (m_nClientID == 6) Delay(400);

	CStdioFile WriteFile;
	if (WriteFile.Open(strFileDir, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strFileDir.Mid(strFileDir.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}

	if (bWriteHeader)
	{
		strTemp = "Stage,JUDGE,DATE,TIME,SPEC,X,Y,ImageDirPath\n";
		WriteFile.WriteString(strTemp);
	}

	WriteFile.SeekToEnd();

	strTemp.Format(_T("%s,%s,%s,%s,%.4f,%.4f,%.4f,%s\n"),
		m_strClientName,
		bJudge ? "OK" : "NG",
		Date_str,
		Time_str,
		vt_job_info[0].model_info.getInspSpecParaInfo().getRotateC_Spec(),
		xr,
		xy,
		strImageDirPath
	);

	WriteFile.WriteString(strTemp);
	WriteFile.Close();


	return TRUE;
}

BOOL CLET_AlignClientDlg::write_result_align_data_1cam_2pos(CString serialNum, BOOL bJudge, int algo)
{
	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algo];
	BOOL bWriteHeader = FALSE;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);
	CString algo_name = m_pAlgorithmInfo.getAlgorithmName(algo).c_str();
#else
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	CString algo_name = vt_job_info[algo].job_name.c_str();
#endif

	int cam_no[8] = { 0, };

	for (int i = 0; i < camCount; i++)
	{
		cam_no[i] = camBuf.at(i);
	}

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		Time_str = m_strResultTime[algo];
		Date_str = m_strResultDate[algo];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_Result_%s.csv", strFileDir, algo_name, Date_str);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}

	if (bWriteHeader)
	{
		//KJH 2021-08-14 Mark Find Method 분기(캘리퍼시 로그 방식 추가 ANGLE / ANGLE -> SCORE변환)
		if (vt_job_info[algo].model_info.getAlignInfo().getMarkFindMethod() == METHOD_CALIPER)
		{
			strTemp = "MODEL ID,CELL ID,TIME,MARK_X1,MARK_Y1,MARK_X2,MARK_Y2,X,Y,T,POS1-ANGLE(˚),POS2-ANGLE(˚),ANGLE1-SCORE(%),ANGLE2-SCORE(%),JUDGE";
		}
		else
		{
			strTemp = "MODEL ID,CELL ID,TIME,MARK_X1,MARK_Y1,MARK_X2,MARK_Y2,X,Y,T,MARK1-SCORE(%),MARK2-SCORE(%),JUDGE";	
		}

		// JSY 2022-11-07 Scratch Judge 결과 저장 추가
		// Comment : Crack 검사를 할 경우에만 데이터 저장 수행
		//if (vt_job_info[algo].model_info.getAlignInfo().getUseCrackInsp())
		int algo_method = vt_job_info[algo].algo_method;
		if (vt_job_info[algo].model_info.getInspSpecParaInfo().getScratchCheck()) strTemp += ",SCRATCH INSP JUDGE";

		strTemp += "\n";

		// END JSY 2022-11-07 Scratch Judge 결과 저장 추가

		WriteFile.WriteString(strTemp);
	}

	WriteFile.SeekToEnd();

	//KJH 2021-08-14 Mark Find Method 분기(캘리퍼시 로그 방식 추가 ANGLE / ANGLE -> SCORE변환)
	if (vt_job_info[algo].model_info.getAlignInfo().getMarkFindMethod() == METHOD_CALIPER)
	{
		strTemp.Format(_T("%s,%s,%s,%.1f,%.1f,%.1f,%.1f,%.3f,%.3f,%.3f,%.1f,%.1f,%.1f,%.1f, %s"),
			m_strCurrentModelName,
			serialNum,
			Time_str,
			GetMatching(algo).getFindInfo(0, 0).GetXPos(),
			GetMatching(algo).getFindInfo(0, 0).GetYPos(),
			GetMatching(algo).getFindInfo(0, 1).GetXPos(),
			GetMatching(algo).getFindInfo(0, 1).GetYPos(),
			m_dbRevisionData[algo][AXIS_X],
			m_dbRevisionData[algo][AXIS_Y],
			m_dbRevisionData[algo][AXIS_T],
			GetMatching(algo).getFindInfo(0, 0).getCaliperAngle(),
			GetMatching(algo).getFindInfo(0, 1).getCaliperAngle(),
			GetMatching(algo).getFindInfo(0, 0).getScore(),
			GetMatching(algo).getFindInfo(0, 1).getScore(),
			bJudge ? "OK" : "NG"
		);
	}
	else
	{
		strTemp.Format(_T("%s,%s,%s,%.1f,%.1f,%.1f,%.1f,%.3f,%.3f,%.3f,%.1f,%.1f, %s"),
			m_strCurrentModelName,
			serialNum,
			Time_str,
			GetMatching(algo).getFindInfo(0, 0).GetXPos(),
			GetMatching(algo).getFindInfo(0, 0).GetYPos(),
			GetMatching(algo).getFindInfo(0, 1).GetXPos(),
			GetMatching(algo).getFindInfo(0, 1).GetYPos(),
			m_dbRevisionData[algo][AXIS_X],
			m_dbRevisionData[algo][AXIS_Y],
			m_dbRevisionData[algo][AXIS_T],
			GetMatching(algo).getFindInfo(0, 0).getScore(),
			GetMatching(algo).getFindInfo(0, 1).getScore(),
			bJudge ? "OK" : "NG"
		);

	}

	// JSY 2022-11-07 Scratch Judge 결과 저장 추가
	// Comment : Crack 검사를 할 경우에만 데이터 저장 수행
	int real_cam = camBuf.at(0);

	if (vt_job_info[algo].model_info.getInspSpecParaInfo().getScratchCheck())
		//if (vt_job_info[algo].model_info.getAlignInfo().getUseCrackInsp()) {
	{
		CString strScratch_Judge;
		strScratch_Judge.Format(",%s", m_bSubInspJudge[real_cam] ? "OK" : "NG");
		strTemp += strScratch_Judge;
	}
	else
	{
		CString strScratch_Judge;
		strScratch_Judge.Format(",%s","N/A");
		strTemp += strScratch_Judge;
	}
	strTemp += "\n";

	// END JSY 2022-11-07 Scratch Judge 결과 저장 추가

	WriteFile.WriteString(strTemp);
	WriteFile.Close();

	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_align_data_2cam_1pos(CString serialNum, BOOL bJudge,int algo)
{
	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algo];
	BOOL bWriteHeader = FALSE;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);
	CString algo_name = m_pAlgorithmInfo.getAlgorithmName(algo).c_str();
#else
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	CString algo_name = vt_job_info[algo].job_name.c_str();
#endif

	int cam_no[8] = { 0, };

	for (int i = 0; i < camCount; i++)
	{
		cam_no[i] = camBuf.at(i);
	}

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		Time_str = m_strResultTime[algo];
		Date_str = m_strResultDate[algo];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_Result_%s.csv", strFileDir, algo_name, Date_str);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}

	// 매번 불필요하게 header 부분에 대한 처리가 들어 가지만, 
	// Header<->Body 작성시 실수를 줄이기 위함.
	CString strHeader, strBody;

	strTemp.Format("TIME");																					strHeader += strTemp;
	strTemp.Format("%s", Time_str);																			strBody += strTemp;

	strTemp.Format(",MODEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);															strBody += strTemp;

	strTemp.Format(",PANEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", serialNum);																		strBody += strTemp;

	strTemp.Format(",JUDGE");																				strHeader += strTemp;
	strTemp.Format(",%s", bJudge ? "OK" : "NG");															strBody += strTemp;

	strTemp.Format(",X");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_X]);												strBody += strTemp;

	strTemp.Format(",Y");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_Y]);												strBody += strTemp;

	strTemp.Format(",T");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_T]);												strBody += strTemp;

	strTemp.Format(",MARK1-SCORE(%%)");																		strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).getScore());								strBody += strTemp;

	strTemp.Format(",MARK2-SCORE(%%)");																		strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).getScore());								strBody += strTemp;

	strTemp.Format(",MARK X1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).GetYPos());									strBody += strTemp;

	strTemp.Format(",MARK X2");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y2");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).GetYPos());									strBody += strTemp;

	strTemp.Format(",L-Check JUDGE");																		strHeader += strTemp;
	strTemp.Format(",L-Check");																				strHeader += strTemp;
	strTemp.Format(",L-Check Spec");																		strHeader += strTemp;

	if (vt_job_info[algo].model_info.getAlignInfo().getEnableLCheck() == TRUE)
	{
		double dist_tor = vt_job_info[algo].model_info.getAlignInfo().getLCheckTor();
		double dist_spec = 0;
		int target_dir = vt_job_info[algo].model_info.getAlignInfo().getAlignmentTargetDir();	// vertical or horizontal
		if (target_dir == 0)	dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecX();// horizontal
		else					dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecY();// vertical
		
		strTemp.Format(",%s", m_bLcheckNG[algo] ? "NG":"OK");												strBody += strTemp;
		strTemp.Format(",%.3f", m_dbLCheck[algo][0]);														strBody += strTemp;
		strTemp.Format(",%.3f ~ %.3f", dist_spec - dist_tor, dist_spec + dist_tor);							strBody += strTemp;
	}
	else
	{
		strTemp.Format(",NO USE");																			strBody += strTemp;
	}

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader)
	{
		WriteFile.WriteString(strHeader);
	}

	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);
	WriteFile.Close();

	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_align_data_4cam_1pos(CString serialNum, BOOL bJudge, int algo)
{
	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algo];
	BOOL bWriteHeader = FALSE;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);
	CString algo_name = m_pAlgorithmInfo.getAlgorithmName(algo).c_str();
#else
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	CString algo_name = vt_job_info[algo].job_name.c_str();
#endif

	int cam_no[8] = { 0, };

	for (int i = 0; i < camCount; i++)
	{
		cam_no[i] = camBuf.at(i);
	}

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		Time_str = m_strResultTime[algo];
		Date_str = m_strResultDate[algo];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_Result_%s.csv", strFileDir, algo_name, Date_str);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}

	CString strHeader, strBody;

	strTemp.Format("TIME");																					strHeader += strTemp;
	strTemp.Format("%s", Time_str);																			strBody += strTemp;

	strTemp.Format(",MODEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);															strBody += strTemp;

	strTemp.Format(",PANEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", serialNum);																		strBody += strTemp;

	strTemp.Format(",JUDGE");																				strHeader += strTemp;
	strTemp.Format(",%s", bJudge ? "OK" : "NG");															strBody += strTemp;

	strTemp.Format(",X");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_X]);												strBody += strTemp;

	strTemp.Format(",Y");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_Y]);												strBody += strTemp;

	strTemp.Format(",T");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_T]);												strBody += strTemp;

	strTemp.Format(",MARK1-SCORE(%%)");																		strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).getScore());								strBody += strTemp;

	strTemp.Format(",MARK2-SCORE(%%)");																		strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).getScore());								strBody += strTemp;

	strTemp.Format(",MARK3-SCORE(%%)");																		strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(2, 0).getScore());								strBody += strTemp;

	strTemp.Format(",MARK4-SCORE(%%)");																		strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(3, 0).getScore());								strBody += strTemp;

	strTemp.Format(",MARK X1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).GetYPos());									strBody += strTemp;

	strTemp.Format(",MARK X2");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y2");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).GetYPos());									strBody += strTemp;

	strTemp.Format(",MARK X3");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(2, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y3");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(2, 0).GetYPos());									strBody += strTemp;

	strTemp.Format(",MARK X4");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(3, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y4");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(3, 0).GetYPos());									strBody += strTemp;

	strTemp.Format(",L-Check JUDGE");																		strHeader += strTemp;
	strTemp.Format(",L-Check TOP");																			strHeader += strTemp;
	strTemp.Format(",L-Check LEFT");																		strHeader += strTemp;
	strTemp.Format(",L-Check RIGHT");																		strHeader += strTemp;
	strTemp.Format(",L-Check BOTTOM");																		strHeader += strTemp;
	strTemp.Format(",L-Check Spec X");																		strHeader += strTemp;
	strTemp.Format(",L-Check Spec Y");																		strHeader += strTemp;

	if (vt_job_info[algo].model_info.getAlignInfo().getEnableLCheck() == TRUE)
	{
		double dist_tor = vt_job_info[algo].model_info.getAlignInfo().getLCheckTor();
		double dist_spec_x = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecX();
		double dist_spec_y = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecY();

		strTemp.Format(",%s", m_bLcheckNG[algo] ? "NG" : "OK");												strBody += strTemp;
		strTemp.Format(",%.3f", m_dbLCheck[algo][0]);														strBody += strTemp;
		strTemp.Format(",%.3f", m_dbLCheck[algo][1]);														strBody += strTemp;
		strTemp.Format(",%.3f", m_dbLCheck[algo][2]);														strBody += strTemp;
		strTemp.Format(",%.3f", m_dbLCheck[algo][3]);														strBody += strTemp;
		strTemp.Format(",%.3f ~ %.3f", dist_spec_x - dist_tor, dist_spec_x + dist_tor);						strBody += strTemp;
		strTemp.Format(",%.3f ~ %.3f", dist_spec_y - dist_tor, dist_spec_y + dist_tor);						strBody += strTemp;
	}
	else
	{
		strTemp.Format(",NO USE");																			strBody += strTemp;
	}

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader)
	{
		WriteFile.WriteString(strHeader);
	}

	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);
	WriteFile.Close();

	return TRUE;
}
BOOL CLET_AlignClientDlg::write_result_align_data_2cam_2pos(CString serialNum, BOOL bJudge, int algo)
{
	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algo];
	BOOL bWriteHeader = FALSE;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);
	CString algo_name = m_pAlgorithmInfo.getAlgorithmName(algo).c_str();
#else
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	CString algo_name = vt_job_info[algo].job_name.c_str();
#endif

	int cam_no[8] = { 0, };

	for (int i = 0; i < camCount; i++)
	{
		cam_no[i] = camBuf.at(i);
	}

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	if (m_bSimulationStart)
	{
		Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
		Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	}
	else
	{
		Time_str = m_strResultTime[algo];
		Date_str = m_strResultDate[algo];
	}

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	if (m_bSimulationStart)	strFileDir.Format("%ssimulation_", strFileDir);
	strTemp.Format("%s%s_Result_%s.csv", strFileDir, algo_name, Date_str);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}

	CString strHeader, strBody;

	strTemp.Format("TIME");																					strHeader += strTemp;
	strTemp.Format("%s", Time_str);																			strBody += strTemp;

	strTemp.Format(",MODEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);															strBody += strTemp;

	strTemp.Format(",PANEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", serialNum);																		strBody += strTemp;

	strTemp.Format(",JUDGE");																				strHeader += strTemp;
	strTemp.Format(",%s", bJudge ? "OK" : "NG");															strBody += strTemp;

	strTemp.Format(",X");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_X]);												strBody += strTemp;

	strTemp.Format(",Y");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_Y]);												strBody += strTemp;

	strTemp.Format(",T");																					strHeader += strTemp;
	strTemp.Format(",%.3f", m_dbRevisionData[algo][AXIS_T]);												strBody += strTemp;

	strTemp.Format(",MARK1-SCORE(%%)");																		strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).getScore());								strBody += strTemp;

	strTemp.Format(",MARK2-SCORE(%%)");																		strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 1).getScore());								strBody += strTemp;

	strTemp.Format(",MARK3-SCORE(%%)");																		strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).getScore());								strBody += strTemp;

	strTemp.Format(",MARK4-SCORE(%%)");																		strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 1).getScore());								strBody += strTemp;

	strTemp.Format(",MARK X1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).GetYPos());									strBody += strTemp;

	strTemp.Format(",MARK X2");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 1).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y2");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 1).GetYPos());									strBody += strTemp;

	strTemp.Format(",MARK X3");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y3");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).GetYPos());									strBody += strTemp;

	strTemp.Format(",MARK X4");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 1).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y4");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 1).GetYPos());									strBody += strTemp;

	strTemp.Format(",L-Check JUDGE");																		strHeader += strTemp;
	strTemp.Format(",L-Check TOP");																			strHeader += strTemp;
	strTemp.Format(",L-Check LEFT");																		strHeader += strTemp;
	strTemp.Format(",L-Check RIGHT");																		strHeader += strTemp;
	strTemp.Format(",L-Check BOTTOM");																		strHeader += strTemp;
	strTemp.Format(",L-Check Spec X");																		strHeader += strTemp;
	strTemp.Format(",L-Check Spec Y");																		strHeader += strTemp;

	if (vt_job_info[algo].model_info.getAlignInfo().getEnableLCheck() == TRUE)
	{
		double dist_tor = vt_job_info[algo].model_info.getAlignInfo().getLCheckTor();
		double dist_spec_x = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecX();
		double dist_spec_y = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecY();

		strTemp.Format(",%s", m_bLcheckNG[algo] ? "NG" : "OK");												strBody += strTemp;
		strTemp.Format(",%.3f", m_dbLCheck[algo][0]);														strBody += strTemp;
		strTemp.Format(",%.3f", m_dbLCheck[algo][1]);														strBody += strTemp;
		strTemp.Format(",%.3f", m_dbLCheck[algo][2]);														strBody += strTemp;
		strTemp.Format(",%.3f", m_dbLCheck[algo][3]);														strBody += strTemp;
		strTemp.Format(",%.3f ~ %.3f", dist_spec_x - dist_tor, dist_spec_x + dist_tor);						strBody += strTemp;
		strTemp.Format(",%.3f ~ %.3f", dist_spec_y - dist_tor, dist_spec_y + dist_tor);						strBody += strTemp;
	}
	else
	{
		strTemp.Format(",NO USE");																			strBody += strTemp;
	}

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader)
	{
		WriteFile.WriteString(strHeader);
	}

	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);
	WriteFile.Close();

	return TRUE;
}

// hsj 2022-02-14 reference엑셀에 저장
BOOL CLET_AlignClientDlg::write_result_Reference(int nJob)
{
	EnterCriticalSection(&m_csScanWrite);

	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir;
	BOOL bWriteHeader = FALSE;

	CString algo_name = vt_job_info[nJob].job_name.c_str();

	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);

	Time_str.Format("%02d:%02d:%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
	Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	
	strFileDir.Format("%sReference_Result.csv", strFileDir);
	
	if ((_access(strFileDir, 0)) == -1)		bWriteHeader = TRUE;

	CStdioFile WriteFile;
	if (WriteFile.Open(strFileDir, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}
	

	CString strHeader, strBody;
	
	strTemp.Format("TIME");												strHeader += strTemp;
	strTemp.Format("%s", Time_str);										strBody += strTemp;

	
	for (int nPos = 0; nPos < vt_job_info[nJob].num_of_position; nPos++)
	{
		strTemp.Format(",POS%d_X", nPos + 1);							strHeader += strTemp;
		strTemp.Format(",%4.4f", GetMatching(nJob).getRefX(0, nPos));	strBody += strTemp;
		strTemp.Format(",POS%d_Y", nPos + 1);							strHeader += strTemp;
		strTemp.Format(",%4.4f", GetMatching(nJob).getRefY(0, nPos));	strBody += strTemp;
		strTemp.Format(",POS%d_T", nPos + 1);							strHeader += strTemp;
		strTemp.Format(",%4.4f", GetMatching(nJob).getRefT(0, nPos));	strBody += strTemp;
	}

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader == TRUE)
	{
		WriteFile.WriteString(strHeader);
	}
	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);


	WriteFile.Close();

	LeaveCriticalSection(&m_csScanWrite);
	return TRUE;
}
//KJH 2022-05-10 Fixture 엑셀에 저장
BOOL CLET_AlignClientDlg::write_result_Fixture(int nJob)
{
	EnterCriticalSection(&m_csScanWrite);

	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir;
	BOOL bWriteHeader = FALSE;

	CString algo_name = vt_job_info[nJob].job_name.c_str();

	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);

	Time_str.Format("%02d:%02d:%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
	Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, algo_name);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	strFileDir.Format("%sFixture_Result.csv", strFileDir);

	if ((_access(strFileDir, 0)) == -1)		bWriteHeader = TRUE;

	CStdioFile WriteFile;
	if (WriteFile.Open(strFileDir, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}


	CString strHeader, strBody;

	strTemp.Format("TIME");												strHeader += strTemp;
	strTemp.Format("%s", Time_str);										strBody += strTemp;


	for (int nPos = 0; nPos < vt_job_info[nJob].num_of_position; nPos++)
	{
		strTemp.Format(",POS%d_X", nPos + 1);									strHeader += strTemp;
		strTemp.Format(",%5.4f", GetMatching(nJob).getFixtureX(0, nPos));		strBody += strTemp;
		strTemp.Format(",POS%d_Y", nPos + 1);									strHeader += strTemp;
		strTemp.Format(",%5.4f", GetMatching(nJob).getFixtureY(0, nPos));		strBody += strTemp;
		strTemp.Format(",POS%d_T", nPos + 1);									strHeader += strTemp;
		strTemp.Format(",%5.4f", GetMatching(nJob).getFixtureT(0, nPos));		strBody += strTemp;
	}

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader == TRUE)
	{
		WriteFile.WriteString(strHeader);
	}
	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);


	WriteFile.Close();

	LeaveCriticalSection(&m_csScanWrite);
	return TRUE;
}

void CLET_AlignClientDlg::write_process_log(BOOL bJudge,int algo)
{
	CString str;

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int nMethod = vt_job_info[algo].algo_method;
	
	switch (nMethod)
	{
	case CLIENT_TYPE_ALIGN:						write_result_align_data_2cam_1pos(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);					break;
	case CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN:		write_result_align_data_2cam_2pos(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);					break;
	case CLIENT_TYPE_1CAM_1SHOT_FILM:
	case CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP:
	case CLIENT_TYPE_1CAM_1SHOT_ALIGN:			write_result_align_data_1cam_2pos(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);					break;
	case CLIENT_TYPE_4CAM_1SHOT_ALIGN:			write_result_align_data_4cam_1pos(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);					break;
	case CLIENT_TYPE_PANEL_EXIST_INSP:			write_result_exist_insp(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);							break;
	case CLIENT_TYPE_PCB_DISTANCE_INSP:			write_result_pcb_distance_insp(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);						break;
	case CLIENT_TYPE_ASSEMBLE_INSP:				write_result_assemble_insp(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);							break;
	case CLIENT_TYPE_SCAN_INSP:                 m_pSaperaInspWorker[algo].write_result_scan_insp(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);	break;
	case CLIENT_TYPE_FILM_INSP:                 write_result_Film_insp_new(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);							break;
	case CLIENT_TYPE_1CAM_4POS_ROBOT:
	case CLIENT_TYPE_1CAM_2POS_REFERENCE:       write_result_align_data_1cam_2object(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);				break;
		//write_result_scan_insp(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);								break;
		//KJH 2021-05-29 ELB CENTER ALIGN 로그 추가
	case CLIENT_TYPE_ELB_CENTER_ALIGN:          write_result_align_data_1cam_1shot_ELB(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);				break;
	case CLIENT_TYPE_CENTER_NOZZLE_ALIGN:       Write_Result_Align_Data_Center_Align_ELB(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);			break;
	default:
	{
		/*
		str.Format("[%s] X : %.4f Y : %.4f T : %.4f", vt_job_info[algo].job_name.c_str(), m_dbRevisionData[algo][AXIS_X], m_dbRevisionData[algo][AXIS_Y], m_dbRevisionData[algo][AXIS_T]);
		//::SendMessage(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, NULL);
		CString strTime;
		SYSTEMTIME time;
		GetLocalTime(&time);

		strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);

		::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_TIME, (LPARAM)&strTime);
		::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(algo));

		//::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);


		switch (nMethod) {
		case CLIENT_TYPE_ALIGN:					write_result_align_data_2cam_1pos(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);		break;
		case CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN:	write_result_align_data_2cam_2pos(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);		break;
		case CLIENT_TYPE_1CAM_1SHOT_ALIGN:		write_result_align_data_1cam_2pos(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);		break;
		case CLIENT_TYPE_4CAM_1SHOT_ALIGN:		write_result_align_data_4cam_1pos(vt_job_info[algo].main_object_id.c_str(), bJudge, algo);		break;
		}
		*/
	}
	break;
	}
	 
	//enum _CLIENT_TYPE {
	//	CLIENT_TYPE_ALIGN = 0,	// 일반 2캠 1Shot 얼라인	
	//	CLIENT_TYPE_1CAM_1SHOT_ALIGN = 1,	// 1Cam 1Shot 얼라인
	//	CLIENT_TYPE_1CAM_2SHOT_ALIGN = 2,	// 1Cam 2Shot 얼라인
	//	CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN = 3,	// 2Cam 개별적 2Shot 얼라인	
	//	CLIENT_TYPE_4CAM_1SHOT_ALIGN = 4,	// 2Cam 개별적 2Shot 얼라인	
	//	CLIENT_TYPE_Z_MEASURE = 5,	// 높이 측정..
	//	CLIENT_TYPE_EACH_2CAM_1SHOT_ALIGN = 6,	// 개별 1Cam 1Shot 얼라인
	//	CLIENT_TYPE_PANEL_EXIST_INSP = 7,	// Panel Exist
	//	CLIENT_TYPE_2CAM_1SHOT_DUST_INSP = 8,    // 2Cam 1 Shot 이물 검사
	//	CLIENT_TYPE_1CAM_1SHOT_DUST_INSP = 9,    // 1Cam 1 Shot 이물 검사
	//	CLIENT_TYPE_2CAM_1SHOT_NOZZLE_INSP = 10,   // Nozzle 검사
	//	CLIENT_TYPE_1CAM_2POS_REFERENCE = 11,
	//	CLIENT_TYPE_1CAM_1POS_REFERENCE = 12,
	//	CLIENT_TYPE_ALIGN_EXIST = 13,
	//	CLIENT_TYPE_COVER_ALIGN_INSP = 14,
	//	CLIENT_TYPE_STAGE_INSP = 15,
	//	CLIENT_TYPE_PCB_DISTANCE_INSP = 16,
	//	CLIENT_TYPE_ASSEMBLE_INSP = 17,
	//};

	//struct _stCameraInf

	//KJH 2022-03-16 Act,Seq Time Display 추가
	if (nMethod == CLIENT_TYPE_ALIGN || 
		nMethod == CLIENT_TYPE_1CAM_1SHOT_ALIGN || 
		nMethod == CLIENT_TYPE_1CAM_2POS_REFERENCE ||
		nMethod == CLIENT_TYPE_1CAM_4POS_ROBOT ||
		nMethod == CLIENT_TYPE_1CAM_1SHOT_FILM ||
		nMethod == CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP)
	{
		auto thisTime = clock();
		double nano = thisTime - m_clockStartTime[algo];

		m_clockStartTime[algo] = thisTime;
		m_dActTime[algo].Format("Act Time: %.4f(sec)", nano / CLOCKS_PER_SEC);
		draw_Calc_Time(algo, 2, m_dActTime[algo], -350, -0);
	}
}

void CLET_AlignClientDlg::writeLengthData(CString strID, double length, int nType,int algo)
{
	CString strTemp, Time_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algo];
	BOOL bWriteHeader = FALSE;

	strFileDir = m_strResultDir + "Files\\";
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir = m_strResultDir + "Files\\" + m_strResultDate[algo];
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%sFiles\\%s\\%s", m_strResultDir, m_strResultDate[algo], m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strTemp.Format("%s\\%s_Length.csv", strFileDir, m_strResultDate[algo]);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);
	Time_str.Format("%02d:%02d:%02d.%03d ", csTime.wHour, csTime.wMinute, csTime.wSecond, csTime.wMilliseconds);

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return ;
	}

	if (bWriteHeader)
	{
		strTemp = "MODEL ID,CELL ID,TIME,LENGTH\n";
		WriteFile.WriteString(strTemp);
	}

	WriteFile.SeekToEnd();

	strTemp.Format(_T("%s,%s,%s,%.4f\n"),	m_strCurrentModelName,	strID,	Time_str,	length	);

	WriteFile.WriteString(strTemp);
	WriteFile.Close();

	return;
}

void CLET_AlignClientDlg::fnProcessCheckOK(int nJobID)
{
	// kbj 2022-01-01 시뮬레이션 일때 OK 신호 살리지 않도록 수정.
	if (m_bSimulationStart == TRUE)
	{
		CString strTemp;
		strTemp.Format("[%s] Simulation Process is PLC OK Signal ingnoerd",vt_job_info[nJobID].get_job_name());
		::SendMessageA(m_pPane[PANE_MANUAL]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
		return;
	}
	
	CString str_temp;
	switch (vt_job_info[nJobID].algo_method) {
	case CLIENT_TYPE_ALIGN:	
	case CLIENT_TYPE_1CAM_1SHOT_FILM:
	case CLIENT_TYPE_1CAM_1SHOT_ALIGN: 
	case CLIENT_TYPE_1CAM_2SHOT_ALIGN: 
	case CLIENT_TYPE_4CAM_1SHOT_ALIGN:
	case CLIENT_TYPE_NOZZLE_ALIGN:
	case CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP:
	{
		g_CommPLC.SetBit(m_nAlignOkWrite[nJobID], TRUE);
	}
	break;
	case CLIENT_TYPE_CENTER_NOZZLE_ALIGN: // 20211205 Tkyuha 신규 노즐 얼라인
	{
		if (m_nSeqNozzleGrabCount == 100)
		{
			g_CommPLC.SetBit(m_nAlignOkWrite[nJobID] + 2, TRUE); //26
		}
		else
		{
			g_CommPLC.SetBit(m_nAlignOkWrite[nJobID], TRUE);
		}
		
	}
	break; 
	case CLIENT_TYPE_CENTER_SIDE_YGAP: // 20211205 Tkyuha 스테이지 와 노즐 높이 측정
	{
		g_CommPLC.SetBit(m_nAlignOkWrite[nJobID] + 4 , TRUE);
	}
	break;
	case CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN: 
	{
		g_CommPLC.SetBit(m_nAlignOkWrite[nJobID] + 2, TRUE);
	}
	break;
	case CLIENT_TYPE_1CAM_4POS_ROBOT:
	case CLIENT_TYPE_1CAM_2POS_REFERENCE:   // Reel Align용 카메라 하나로 두개 대상물 얼라인 Tkyuha 20211018
	{
		//HTK 2022-06-29 한 매 물류시 각 OK, NG Bit On 조건 활성화
		if (m_bFind_object[0] == TRUE)  g_CommPLC.SetBit(m_nAlignOkWrite[nJobID], TRUE);  ///  두개를 개별로 처리 해야됨 나중에 수정 Tkyuha 20211018
		else  g_CommPLC.SetBit(m_nAlignNgWrite[nJobID], TRUE);
		if (m_bFind_object[1] == TRUE)	g_CommPLC.SetBit(m_nAlignOkWrite[nJobID] + 20, TRUE);///  두개를 개별로 처리 해야됨 나중에 수정 Tkyuha 20211018
		else  g_CommPLC.SetBit(m_nAlignNgWrite[nJobID] + 20, TRUE);
	}
	break;
	case CLIENT_TYPE_PANEL_EXIST_INSP: 
	case CLIENT_TYPE_PCB_DISTANCE_INSP: 
	case CLIENT_TYPE_ASSEMBLE_INSP: 	
	case CLIENT_TYPE_SCAN_INSP:
	{
		g_CommPLC.SetBit(m_nInspOkWrite[nJobID], TRUE);
	}
	break;
	case CLIENT_TYPE_NOZZLE_SIDE_VIEW:
	{
		//KJH 2022-01-03 State Insp OK,NG 1:1 매칭
		g_CommPLC.SetBit(m_nInspOkWrite[nJobID] + m_nNozzleSideCamMode * 2, TRUE);
	}
	break;
	case CLIENT_TYPE_FILM_INSP: // Film 부착 검사용  Tkyuha 20211018
	{
		g_CommPLC.SetBit(m_nInspOkWrite[nJobID], TRUE);
	}
	break;
	case CLIENT_TYPE_ELB_CENTER_ALIGN:
	default:
	{
		g_CommPLC.SetBit(m_nAlignOkWrite[nJobID], TRUE);
	}
	break;
	}
}
void CLET_AlignClientDlg::fnProcessCheckNG(int nJobID)
{
	// kbj 2022-01-01 시뮬레이션 일때 NG 신호 살리지 않도록 수정.
	if (m_bSimulationStart == TRUE)
	{
		CString strTemp;
		strTemp.Format("[%s] Simulation Process is PLC OK Signal ingnoerd", vt_job_info[nJobID].get_job_name());
		::SendMessageA(m_pPane[PANE_MANUAL]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
		return;
	}

#ifndef JOB_INFO
	switch (m_pAlgorithmInfo.getAlgorithmMethod(nJobID))
#else
	switch (vt_job_info[nJobID].algo_method)
#endif
	{
	case CLIENT_TYPE_ALIGN: 
	case CLIENT_TYPE_1CAM_1SHOT_FILM:
	case CLIENT_TYPE_1CAM_1SHOT_ALIGN: 
	case CLIENT_TYPE_1CAM_2SHOT_ALIGN: 
	case CLIENT_TYPE_4CAM_1SHOT_ALIGN: 
	case CLIENT_TYPE_NOZZLE_ALIGN:
	case CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP:
	{
		g_CommPLC.SetBit(m_nAlignNgWrite[nJobID], TRUE);
	}
	break;
	case CLIENT_TYPE_CENTER_NOZZLE_ALIGN: // 20211205 Tkyuha 신규 노즐 얼라인
	{
		if (m_nSeqNozzleGrabCount == 100)
		{
			g_CommPLC.SetBit(m_nAlignNgWrite[nJobID] + 2, TRUE); //26
		}
		else
		{
			g_CommPLC.SetBit(m_nAlignNgWrite[nJobID], TRUE);
		}
	}
	break;
	case CLIENT_TYPE_CENTER_SIDE_YGAP: // 20211205 Tkyuha 스테이지 와 노즐 높이 측정
	{
		g_CommPLC.SetBit(m_nAlignNgWrite[nJobID] + 4, TRUE);
	}
	break;
	case CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN: 
	{
		g_CommPLC.SetBit(m_nAlignNgWrite[nJobID] + 2, TRUE);
	}
	break;
	case CLIENT_TYPE_1CAM_4POS_ROBOT:
	case CLIENT_TYPE_1CAM_2POS_REFERENCE: // Reel Align용 카메라 하나로 두개 대상물 얼라인 Tkyuha 20211018
	{
		//kmb 2022-11-19 REEL Revision Limit NG 구분 
		if (m_bFind_object[0] != TRUE && m_nErrorType[nJobID] == ERR_TYPE_REVISION_FAIL || m_nErrorType[nJobID] == ERR_TYPE_REVISION_LIMIT)
			g_CommPLC.SetBit(m_nAlignNgWrite[nJobID], TRUE);  ///  두개를 개별로 처리 해야됨 나중에 수정 Tkyuha 20211018
		else
			g_CommPLC.SetBit(m_nAlignOkWrite[nJobID], TRUE);
		
		if (m_bFind_object[1] != TRUE && m_nErrorType[nJobID] == ERR_TYPE_REVISION_FAIL || m_nErrorType[nJobID] == ERR_TYPE_REVISION_LIMIT)
			g_CommPLC.SetBit(m_nAlignNgWrite[nJobID] + 20, TRUE);///  두개를 개별로 처리 해야됨 나중에 수정 Tkyuha 20211018
		else
			g_CommPLC.SetBit(m_nAlignOkWrite[nJobID] + 20, TRUE);

		////HTK 2022-06-29 한 매 물류시 각 OK, NG Bit On 조건 활성화
		//if (m_bFind_object[0] != TRUE) g_CommPLC.SetBit(m_nAlignNgWrite[nJobID], TRUE);  ///  두개를 개별로 처리 해야됨 나중에 수정 Tkyuha 20211018
		//else g_CommPLC.SetBit(m_nAlignOkWrite[nJobID], TRUE);
		//if (m_bFind_object[1] != TRUE) g_CommPLC.SetBit(m_nAlignNgWrite[nJobID] + 20, TRUE);///  두개를 개별로 처리 해야됨 나중에 수정 Tkyuha 20211018
		//else g_CommPLC.SetBit(m_nAlignOkWrite[nJobID] + 20, TRUE);
	}
	break;
	case CLIENT_TYPE_PANEL_EXIST_INSP:
	case CLIENT_TYPE_PCB_DISTANCE_INSP: 
	case CLIENT_TYPE_ASSEMBLE_INSP:	
	{
		g_CommPLC.SetBit(m_nInspNgWrite[nJobID], TRUE);
	}
	break;
	case CLIENT_TYPE_NOZZLE_SIDE_VIEW:
	{
		//KJH 2022-01-03 State Insp OK,NG 1:1 매칭
		g_CommPLC.SetBit(m_nInspNgWrite[nJobID] + m_nNozzleSideCamMode * 2, TRUE);
	}
	break;
	case CLIENT_TYPE_FILM_INSP:  // Film 부착 검사용  Tkyuha 20211018
	{
		g_CommPLC.SetBit(m_nInspNgWrite[nJobID], TRUE);
	}
	break;
	case CLIENT_TYPE_ELB_CENTER_ALIGN:
	default:
	{
		g_CommPLC.SetBit(m_nAlignNgWrite[nJobID], TRUE);
	}
	break;
	}
}

void CLET_AlignClientDlg::sendRevisionOffsetData(double x, double y, double t)
{
	long calibData[SIZE_REVISION_DATA] = { 0, };

	if (fabs(x) < 0.0001)	x = 0.0001;
	if (fabs(y) < 0.0001)	y = 0.0001;
	if (fabs(t) < 0.0001)	t = 0.0001;

	calibData[0] = LOWORD((long)(x * MOTOR_SCALE));
	calibData[1] = HIWORD((long)(x * MOTOR_SCALE));
	calibData[2] = LOWORD((long)(y * MOTOR_SCALE));
	calibData[3] = HIWORD((long)(y * MOTOR_SCALE));
	calibData[4] = LOWORD((long)(t * THETA_SCALE));
	calibData[5] = HIWORD((long)(t * THETA_SCALE));

	SendServer(TCP_SEND_REVISION_OFFSET_DATA, 0, 0, calibData);
}
void CLET_AlignClientDlg::sendRevisionData( double x, double y, double t, int job_id)
{
	long calibData[SIZE_REVISION_DATA] = { 0, };
	double revisionData[3] = { x,y,t };
	CString str;

	//KJH 2021-12-21 revisiondata 0 전송 가능!
	if (fabs(revisionData[AXIS_X]) < 0.0001)	revisionData[AXIS_X] = 0.0000;
	if (fabs(revisionData[AXIS_Y]) < 0.0001)	revisionData[AXIS_Y] = 0.0000;
	if (fabs(revisionData[AXIS_T]) < 0.0001)	revisionData[AXIS_T] = 0.0000;

	calibData[0] = LOWORD((long)(revisionData[AXIS_X] * MOTOR_SCALE));
	calibData[1] = HIWORD((long)(revisionData[AXIS_X] * MOTOR_SCALE));
	calibData[2] = LOWORD((long)(revisionData[AXIS_Y] * MOTOR_SCALE));
	calibData[3] = HIWORD((long)(revisionData[AXIS_Y] * MOTOR_SCALE));
	calibData[4] = LOWORD((long)(revisionData[AXIS_T] * THETA_SCALE));
	calibData[5] = HIWORD((long)(revisionData[AXIS_T] * THETA_SCALE));

	int addr_wd_curr_calib_data = vt_job_info[job_id].plc_addr_info.write_word_start;
	g_CommPLC.SetWord(addr_wd_curr_calib_data, 6, calibData);
}
void CLET_AlignClientDlg::sendRevisionSecondData(double x, double y, double t, int job_id)
{
	long calibData[SIZE_REVISION_DATA] = { 0, };
	double revisionData[3] = { x,y,t };
	CString str;

	//KJH 2021-12-21 revisiondata 0 전송 가능!
	if (fabs(revisionData[AXIS_X]) < 0.0001)	revisionData[AXIS_X] = 0.0000;
	if (fabs(revisionData[AXIS_Y]) < 0.0001)	revisionData[AXIS_Y] = 0.0000;
	if (fabs(revisionData[AXIS_T]) < 0.0001)	revisionData[AXIS_T] = 0.0000;

	calibData[0] = LOWORD((long)(revisionData[AXIS_X] * MOTOR_SCALE));
	calibData[1] = HIWORD((long)(revisionData[AXIS_X] * MOTOR_SCALE));
	calibData[2] = LOWORD((long)(revisionData[AXIS_Y] * MOTOR_SCALE));
	calibData[3] = HIWORD((long)(revisionData[AXIS_Y] * MOTOR_SCALE));
	calibData[4] = LOWORD((long)(revisionData[AXIS_T] * THETA_SCALE));
	calibData[5] = HIWORD((long)(revisionData[AXIS_T] * THETA_SCALE));

	int addr_wd_curr_calib_data = vt_job_info[job_id].plc_addr_info.write_word_start+20; // 두번째 위치에 할당
	g_CommPLC.SetWord(addr_wd_curr_calib_data, 6, calibData);

}
void CLET_AlignClientDlg::sendRevisionNozzleData(double x, double y, double t,double z, int job_id)
{
	long calibData[8] = { 0, };
	double revisionData[4] = { x,y,t,z };
	CString str;

	//KJH 2021-12-21 revisiondata 0 전송 가능!
	if (fabs(revisionData[AXIS_X]) < 0.0001)	revisionData[AXIS_X] = 0.000;
	if (fabs(revisionData[AXIS_Y]) < 0.0001)	revisionData[AXIS_Y] = 0.000;
	if (fabs(revisionData[AXIS_T]) < 0.0001)	revisionData[AXIS_T] = 0.000;
	if (fabs(revisionData[AXIS_Z]) < 0.0001)	revisionData[AXIS_Z] = 0.000;

	calibData[0] = LOWORD((long)(revisionData[AXIS_X] * MOTOR_SCALE));
	calibData[1] = HIWORD((long)(revisionData[AXIS_X] * MOTOR_SCALE));
	calibData[2] = LOWORD((long)(revisionData[AXIS_Y] * MOTOR_SCALE));
	calibData[3] = HIWORD((long)(revisionData[AXIS_Y] * MOTOR_SCALE));
	calibData[4] = LOWORD((long)(revisionData[AXIS_T] * THETA_SCALE));
	calibData[5] = HIWORD((long)(revisionData[AXIS_T] * THETA_SCALE));
	calibData[6] = LOWORD((long)(revisionData[AXIS_Z] * MOTOR_SCALE));
	calibData[7] = HIWORD((long)(revisionData[AXIS_Z] * MOTOR_SCALE));

#ifndef JOB_INFO
	int addr_wd_curr_calib_data = m_pAlgorithmInfo.getAlgorithmWriteWordStart(job_id);
	g_CommPLC.SetWord(addr_wd_curr_calib_data, 6, calibData);
	SendServer(TCP_SEND_REVISION_DATA, job_id);
#else
	int addr_wd_curr_calib_data = vt_job_info[job_id].plc_addr_info.write_word_start;
	g_CommPLC.SetWord(addr_wd_curr_calib_data, 8, calibData);
#endif
}
void CLET_AlignClientDlg::sendLCheckData4Cam4Align(int nJob)
{
	//T, L, R, B
	const int TOP = 0;
	const int LEFT = 1;
	const int RIGHT = 2;
	const int BOTTOM = 3;

	long LcheckData[8] = { 0, };

	//KJH 2021-12-21 revisiondata 0 전송 가능!
	if (fabs(m_dbLCheck[nJob][TOP]) < 0.0001)		m_dbLCheck[nJob][TOP]		= 0.0000;
	if (fabs(m_dbLCheck[nJob][LEFT]) < 0.0001)		m_dbLCheck[nJob][LEFT]		= 0.0000;
	if (fabs(m_dbLCheck[nJob][RIGHT]) < 0.0001)		m_dbLCheck[nJob][RIGHT]		= 0.0000;
	if (fabs(m_dbLCheck[nJob][BOTTOM]) < 0.0001)	m_dbLCheck[nJob][BOTTOM]	= 0.0000;
	
	LcheckData[0] = LOWORD((long)(m_dbLCheck[nJob][TOP] * MOTOR_SCALE));
	LcheckData[1] = HIWORD((long)(m_dbLCheck[nJob][TOP] * MOTOR_SCALE));
	LcheckData[2] = LOWORD((long)(m_dbLCheck[nJob][LEFT] * MOTOR_SCALE));
	LcheckData[3] = HIWORD((long)(m_dbLCheck[nJob][LEFT] * MOTOR_SCALE));
	LcheckData[4] = LOWORD((long)(m_dbLCheck[nJob][RIGHT] * THETA_SCALE));
	LcheckData[5] = HIWORD((long)(m_dbLCheck[nJob][RIGHT] * THETA_SCALE));
	LcheckData[6] = LOWORD((long)(m_dbLCheck[nJob][BOTTOM] * MOTOR_SCALE));
	LcheckData[7] = HIWORD((long)(m_dbLCheck[nJob][BOTTOM] * MOTOR_SCALE));

	int addr_wd_curr_calib_data = vt_job_info[nJob].plc_addr_info.write_word_start;
	g_CommPLC.SetWord(addr_wd_curr_calib_data + 10, 8, LcheckData);
}
void CLET_AlignClientDlg::sendTraceProfileCircleData(int startAddress, int centerAddress, double pitch, int lineCount)
{
	long pDataCount[4] = { 0, };
	long* pDataSendX = NULL;
	long* pDataSendY = NULL;
	long* pDataSendT = NULL;

	if(lineCount==-1)	lineCount = int(m_ELB_TraceResult.m_vTraceProfile[0].size());

	double rotateX = m_ELB_TraceResult.m_vELB_RotateCenter.x;
	double rotateY = m_ELB_TraceResult.m_vELB_RotateCenter.y;
	double step = 0, x, y, t;

	pDataSendX = new long[lineCount * 4];
	pDataSendY = new long[lineCount * 4];
	pDataSendT = new long[lineCount * 4];

	for (int i = 0; i < lineCount; i++)
	{
		step = pitch * i * MOTOR_SCALE;
		x = m_ELB_TraceResult.m_vTraceProfile[0].at(i) * MOTOR_SCALE;
		y = m_ELB_TraceResult.m_vTraceProfile[1].at(i) * MOTOR_SCALE;
		t = -m_ELB_TraceResult.m_vTraceProfile[2].at(i) * MOTOR_SCALE;

		pDataSendX[i * 2 + 0] = LOWORD(x);
		pDataSendX[i * 2 + 1] = HIWORD(x);

		pDataSendY[i * 2 + 0] = LOWORD(y);
		pDataSendY[i * 2 + 1] = HIWORD(y);

		pDataSendT[i * 2 + 0] = LOWORD(t);
		pDataSendT[i * 2 + 1] = HIWORD(t);
	}
	////////////////////////////
	// 정방향 데이타 전송
	pDataCount[0] = LOWORD(lineCount);
	pDataCount[1] = HIWORD(lineCount);
	pDataCount[2] = LOWORD(pitch * MOTOR_SCALE);
	pDataCount[3] = HIWORD(pitch * MOTOR_SCALE);

	// 데이타 수량
	g_CommPLC.SetWordZR(startAddress,		 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 1600, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 3200, 2, pDataCount);
	// PITCH
	g_CommPLC.SetWordZR(startAddress + 2,	 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 1602, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 3202, 2, &pDataCount[2]);
	// 좌표값
	g_CommPLC.SetWordZR(startAddress + 4,	 lineCount * 2, pDataSendX);
	g_CommPLC.SetWordZR(startAddress + 1604, lineCount * 2, pDataSendY);
	g_CommPLC.SetWordZR(startAddress + 3204, lineCount * 2, pDataSendT);
	
	// 역방향 데이타 전송
	// 데이타 수량
	g_CommPLC.SetWordZR(startAddress + 100000, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 101600, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 103200, 2, pDataCount);
	// PITCH
	g_CommPLC.SetWordZR(startAddress + 100002, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 101602, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 103202, 2, &pDataCount[2]);

	// 좌표값 계산
	//KJH 2021-11-01 Circle Trace Data 역방향 계산 후 전송 추가
	double xoffset = m_ELB_TraceResult.m_vTraceProfile[0].at(lineCount - 1);
	double yoffset = m_ELB_TraceResult.m_vTraceProfile[1].at(lineCount - 1);
	double toffset = m_ELB_TraceResult.m_vTraceProfile[2].at(lineCount - 1);
	int id = 0;
	
	for (int i = 0; i < lineCount; i++)
	{
		id = lineCount - 1 - i;
		step = -pitch * i * MOTOR_SCALE;

		x = (m_ELB_TraceResult.m_vTraceProfile[0].at(id) - xoffset) * MOTOR_SCALE;
		y = (m_ELB_TraceResult.m_vTraceProfile[1].at(id) - yoffset) * MOTOR_SCALE;
		t = -(m_ELB_TraceResult.m_vTraceProfile[2].at(id) - toffset) * MOTOR_SCALE;

		pDataSendX[i * 2 + 0] = LOWORD(x);
		pDataSendX[i * 2 + 1] = HIWORD(x);

		pDataSendY[i * 2 + 0] = LOWORD(y);
		pDataSendY[i * 2 + 1] = HIWORD(y);

		pDataSendT[i * 2 + 0] = LOWORD(t);
		pDataSendT[i * 2 + 1] = HIWORD(t);
	}
	g_CommPLC.SetWordZR(startAddress + 100004, lineCount * 2, pDataSendX);
	g_CommPLC.SetWordZR(startAddress + 101604, lineCount * 2, pDataSendY);
	g_CommPLC.SetWordZR(startAddress + 103204, lineCount * 2, pDataSendT);
	////////////////////////////
	
	//도포 시작 위치 전송
	pDataCount[0] = LOWORD(rotateX * MOTOR_SCALE);
	pDataCount[1] = HIWORD(rotateX * MOTOR_SCALE);
	pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
	pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
	g_CommPLC.SetWord(centerAddress + 6, 4, pDataCount);

	// 역방향 시작 위치 전송
	pDataCount[0] = LOWORD(rotateX * MOTOR_SCALE);
	pDataCount[1] = HIWORD(rotateX * MOTOR_SCALE);
	pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
	pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
	g_CommPLC.SetWord(centerAddress + 10, 4, pDataCount);

	// 회전 중심 전송
	// KBJ 2022-10-27 PLC 에서 Manul(or Auto) Rotate 시 동일한 어드레스 사용하여 스킵
	int find_method = vt_job_info[0].model_info.getAlignInfo().getMarkFindMethod();
	if (find_method != METHOD_CIRCLE)
	{
		rotateX = GetMachine(0).getRotateX(0, 0);
		rotateY = GetMachine(0).getRotateY(0, 0);

		pDataCount[0] = LOWORD(rotateX * MOTOR_SCALE);
		pDataCount[1] = HIWORD(rotateX * MOTOR_SCALE);
		pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
		pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
		g_CommPLC.SetWord(centerAddress + 14, 4, pDataCount);
	}

	if (pDataSendX != NULL) delete pDataSendX;
	if (pDataSendY != NULL) delete pDataSendY;
	if (pDataSendT != NULL) delete pDataSendT;
}
void CLET_AlignClientDlg::sendTraceProfileTwo_CircleData(int startAddress, int centerAddress, double pitch)
{
	long pDataCount[4] = { 0, };
	long* pDataSendX = NULL;
	long* pDataSendY = NULL;
	long* pDataSendT = NULL;

	int lineCount = int(m_ELB_TraceResult.m_vTraceProfile[0].size());
	double rotateX = m_ELB_TraceResult.m_vELB_RotateCenter.x;
	double rotateY = m_ELB_TraceResult.m_vELB_RotateCenter.y;
	double step = 0, x, y, t;

	pDataSendX = new long[lineCount * 4];
	pDataSendY = new long[lineCount * 4];
	pDataSendT = new long[lineCount * 4];

	for (int i = 0; i < lineCount; i++)
	{
		step = pitch * i * MOTOR_SCALE;
		x = m_ELB_TraceResult.m_vTraceProfile[0].at(i) * MOTOR_SCALE;
		y = m_ELB_TraceResult.m_vTraceProfile[1].at(i) * MOTOR_SCALE;
		t = m_ELB_TraceResult.m_vTraceProfile[2].at(i) * MOTOR_SCALE;

		pDataSendX[i * 2 + 0] = LOWORD(x);
		pDataSendX[i * 2 + 1] = HIWORD(x);

		pDataSendY[i * 2 + 0] = LOWORD(y);
		pDataSendY[i * 2 + 1] = HIWORD(y);

		pDataSendT[i * 2 + 0] = LOWORD(t);
		pDataSendT[i * 2 + 1] = HIWORD(t);
	}
	////////////////////////////
	// 정방향 데이타 전송
	pDataCount[0] = LOWORD(lineCount);
	pDataCount[1] = HIWORD(lineCount);
	pDataCount[2] = LOWORD(pitch * MOTOR_SCALE);
	pDataCount[3] = HIWORD(pitch * MOTOR_SCALE);
	// 데이타 수량
	g_CommPLC.SetWordZR(startAddress, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 1600, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 3200, 2, pDataCount);
	// PITCH
	g_CommPLC.SetWordZR(startAddress + 2, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 1602, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 3202, 2, &pDataCount[2]);
	// 좌표값
	g_CommPLC.SetWordZR(startAddress + 4, lineCount * 2, pDataSendX);
	g_CommPLC.SetWordZR(startAddress + 1604, lineCount * 2, pDataSendY);
	g_CommPLC.SetWordZR(startAddress + 3204, lineCount * 2, pDataSendT);
	
	// 역방향 데이타 전송
	// 데이타 수량
	g_CommPLC.SetWordZR(startAddress + 100000, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 101600, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 103200, 2, pDataCount);
	// PITCH
	g_CommPLC.SetWordZR(startAddress + 100002, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 101602, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 103202, 2, &pDataCount[2]);
	// 좌표값 계산
	//KJH 2021-11-01 Circle Trace Data 역방향 계산 후 전송 추가
	double xoffset = m_ELB_TraceResult.m_vTraceProfile[0].at(lineCount - 1);
	double yoffset = m_ELB_TraceResult.m_vTraceProfile[1].at(lineCount - 1);
	double toffset = m_ELB_TraceResult.m_vTraceProfile[2].at(lineCount - 1);
	int id = 0;
	for (int i = 0; i < lineCount; i++)
	{
		id = lineCount - 1 - i;
		step = -pitch * i * MOTOR_SCALE;

		x = (m_ELB_TraceResult.m_vTraceProfile[0].at(id) - xoffset) * MOTOR_SCALE;
		y = (m_ELB_TraceResult.m_vTraceProfile[1].at(id) - yoffset) * MOTOR_SCALE;
		t = (m_ELB_TraceResult.m_vTraceProfile[2].at(id) - toffset) * MOTOR_SCALE;

		pDataSendX[i * 2 + 0] = LOWORD(x);
		pDataSendX[i * 2 + 1] = HIWORD(x);

		pDataSendY[i * 2 + 0] = LOWORD(y);
		pDataSendY[i * 2 + 1] = HIWORD(y);

		pDataSendT[i * 2 + 0] = LOWORD(t);
		pDataSendT[i * 2 + 1] = HIWORD(t);
	}
	g_CommPLC.SetWordZR(startAddress + 100004, lineCount * 2, pDataSendX);
	g_CommPLC.SetWordZR(startAddress + 101604, lineCount * 2, pDataSendY);
	g_CommPLC.SetWordZR(startAddress + 103204, lineCount * 2, pDataSendT);
	////////////////////////////
		//도포 시작 위치 전송
	pDataCount[0] = LOWORD((-rotateX) * MOTOR_SCALE);
	pDataCount[1] = HIWORD((-rotateX) * MOTOR_SCALE);
	pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
	pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
	g_CommPLC.SetWord(centerAddress + 6, 4, pDataCount);

	// 역방향 시작 위치 전송
	rotateX = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x;
	rotateY = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y;


	pDataCount[0] = LOWORD((-rotateX) * MOTOR_SCALE);
	pDataCount[1] = HIWORD((-rotateX) * MOTOR_SCALE);
	pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
	pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
	g_CommPLC.SetWord(centerAddress + 10, 4, pDataCount);

	// 회전 중심 전송
	// KBJ 2022-11-14 회전중심과 Rotate 시 동일한 어드레스 사용하여 예외처리 추가
	int find_method = vt_job_info[0].model_info.getAlignInfo().getMarkFindMethod();
	if (find_method != METHOD_CIRCLE)
	{
		rotateX = GetMachine(0).getRotateX(0, 0);
		rotateY = GetMachine(0).getRotateY(0, 0);

		pDataCount[0] = LOWORD(rotateX * MOTOR_SCALE);
		pDataCount[1] = HIWORD(rotateX * MOTOR_SCALE);
		pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
		pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
		g_CommPLC.SetWord(centerAddress + 14, 4, pDataCount);
	}

	if (pDataSendX != NULL) delete pDataSendX;
	if (pDataSendY != NULL) delete pDataSendY;
	if (pDataSendT != NULL) delete pDataSendT;
}
void CLET_AlignClientDlg::sendTraceProfileNotchData(int startAddress, int centerAddress, double pitch)
{
	std::vector<double> m_vTraceProfile_t[3];
	if (vt_job_info[0].model_info.getAlignInfo().getUseReverseOrder())
	{
		double tmp_Rx = m_ELB_TraceResult.m_vELB_RotateCenter.x;
		double tmp_Ry = m_ELB_TraceResult.m_vELB_RotateCenter.y;
		m_ELB_TraceResult.m_vELB_RotateCenter.x = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x;
		m_ELB_TraceResult.m_vELB_RotateCenter.y = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y;
		m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x = tmp_Rx;
		m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y = tmp_Ry;

		int lCount = int(m_ELB_TraceResult.m_vTraceProfile[0].size()),id_t = 0;
		double xoffset_t = m_ELB_TraceResult.m_vTraceProfile[0].at(lCount - 1);
		double yoffset_t = m_ELB_TraceResult.m_vTraceProfile[1].at(lCount - 1);
		double toffset_t = m_ELB_TraceResult.m_vTraceProfile[2].at(lCount - 1);
		
		for (int i = 0; i < lCount; i++)
		{
			id_t = lCount - 1 - i;
			m_vTraceProfile_t[0].push_back(m_ELB_TraceResult.m_vTraceProfile[0].at(id_t) - xoffset_t);
			m_vTraceProfile_t[1].push_back(m_ELB_TraceResult.m_vTraceProfile[1].at(id_t) - yoffset_t);
			m_vTraceProfile_t[2].push_back(m_ELB_TraceResult.m_vTraceProfile[2].at(id_t) - toffset_t);
		}
		
		for (int i = 0; i < lCount; i++)
		{
			m_ELB_TraceResult.m_vTraceProfile[0].at(i) = m_vTraceProfile_t[0].at(i);
			m_ELB_TraceResult.m_vTraceProfile[1].at(i) = m_vTraceProfile_t[1].at(i);
			m_ELB_TraceResult.m_vTraceProfile[2].at(i) = m_vTraceProfile_t[2].at(i);
		}		
	}

	long pDataCount[4] = { 0, };
	long* pDataSendX = NULL;
	long* pDataSendY = NULL;
	long* pDataSendT = NULL;

	int lineCount = int(m_ELB_TraceResult.m_vTraceProfile[0].size());
	double rotateX = m_ELB_TraceResult.m_vELB_RotateCenter.x;
	double rotateY = m_ELB_TraceResult.m_vELB_RotateCenter.y;
	double step = 0, x, y, t;

	double x_off = 0.0;
	int org_pos = vt_job_info[0].model_info.getMachineInfo().getAlignOrginPos(0);
	int real_cam = vt_job_info[0].camera_index[0];

	if (org_pos == _NOTCH_X85_Y50)
	{
		int w = m_stCamInfo[real_cam].w;
		int h = m_stCamInfo[real_cam].h;

		double robot_center_x = 0.0;
		double robot_center_y = 0.0;
		double robot_org_x = 0.0;
		double robot_org_y = 0.0;

		GetMachine(0).PixelToWorld(0, 0, w / 2, h / 2, &robot_center_x, &robot_center_y);
		GetMachine(0).PixelToWorld(0, 0, w * 0.85, h / 2, &robot_org_x, &robot_org_y);

		x_off = robot_org_x - robot_center_x;
	}

	pDataSendX = new long[lineCount * 4];
	pDataSendY = new long[lineCount * 4];
	pDataSendT = new long[lineCount * 4];

	for (int i = 0; i < lineCount; i++)
	{
		step = pitch * i * MOTOR_SCALE;
		x = m_ELB_TraceResult.m_vTraceProfile[0].at(i) * MOTOR_SCALE;
		y = m_ELB_TraceResult.m_vTraceProfile[1].at(i) * MOTOR_SCALE;
		t = m_ELB_TraceResult.m_vTraceProfile[2].at(i) * MOTOR_SCALE;

		pDataSendX[i * 2 + 0] = LOWORD(x);
		pDataSendX[i * 2 + 1] = HIWORD(x);

		pDataSendY[i * 2 + 0] = LOWORD(y);
		pDataSendY[i * 2 + 1] = HIWORD(y);

		pDataSendT[i * 2 + 0] = LOWORD(t);
		pDataSendT[i * 2 + 1] = HIWORD(t);
	}
	////////////////////////////
	// 정방향 데이타 전송
	pDataCount[0] = LOWORD(lineCount);
	pDataCount[1] = HIWORD(lineCount);
	pDataCount[2] = LOWORD(pitch * MOTOR_SCALE);
	pDataCount[3] = HIWORD(pitch * MOTOR_SCALE);
	// 데이타 수량
	g_CommPLC.SetWordZR(startAddress, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 1600, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 3200, 2, pDataCount);
	// PITCH
	g_CommPLC.SetWordZR(startAddress + 2, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 1602, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 3202, 2, &pDataCount[2]);
	// 좌표값
	g_CommPLC.SetWordZR(startAddress + 4, lineCount * 2, pDataSendX);
	g_CommPLC.SetWordZR(startAddress + 1604, lineCount * 2, pDataSendY);
	g_CommPLC.SetWordZR(startAddress + 3204, lineCount * 2, pDataSendT);
	
	// 역방향 데이타 전송
	// 데이타 수량
	g_CommPLC.SetWordZR(startAddress + 100000, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 101600, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 103200, 2, pDataCount);
	// PITCH
	g_CommPLC.SetWordZR(startAddress + 100002, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 101602, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 103202, 2, &pDataCount[2]);
	// 좌표값 계산
	double xoffset = m_ELB_TraceResult.m_vTraceProfile[0].at(lineCount - 1);
	double yoffset = m_ELB_TraceResult.m_vTraceProfile[1].at(lineCount - 1);
	double toffset = m_ELB_TraceResult.m_vTraceProfile[2].at(lineCount - 1);
	int id = 0;
	for (int i = 0; i < lineCount; i++)
	{
		id = lineCount - 1 - i;
		step = -pitch * i * MOTOR_SCALE;

		x = (m_ELB_TraceResult.m_vTraceProfile[0].at(id) - xoffset) * MOTOR_SCALE;
		y = (m_ELB_TraceResult.m_vTraceProfile[1].at(id) - yoffset) * MOTOR_SCALE;
		t = (m_ELB_TraceResult.m_vTraceProfile[2].at(id) - toffset) * MOTOR_SCALE;

		pDataSendX[i * 2 + 0] = LOWORD(x);
		pDataSendX[i * 2 + 1] = HIWORD(x);

		pDataSendY[i * 2 + 0] = LOWORD(y);
		pDataSendY[i * 2 + 1] = HIWORD(y);

		pDataSendT[i * 2 + 0] = LOWORD(t);
		pDataSendT[i * 2 + 1] = HIWORD(t);
	}
	g_CommPLC.SetWordZR(startAddress + 100004, lineCount * 2, pDataSendX);
	g_CommPLC.SetWordZR(startAddress + 101604, lineCount * 2, pDataSendY);
	g_CommPLC.SetWordZR(startAddress + 103204, lineCount * 2, pDataSendT);
	////////////////////////////
	//도포 시작 위치 전송
	pDataCount[0] = LOWORD((-rotateX ) * MOTOR_SCALE);
	pDataCount[1] = HIWORD((-rotateX ) * MOTOR_SCALE);
	pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
	pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
	g_CommPLC.SetWord(centerAddress + 6, 4, pDataCount);

	// 역방향 시작 위치 전송
	rotateX = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x;
	rotateY = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y;

	pDataCount[0] = LOWORD((-rotateX ) * MOTOR_SCALE);
	pDataCount[1] = HIWORD((-rotateX ) * MOTOR_SCALE);
	pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
	pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
	g_CommPLC.SetWord(centerAddress + 10, 4, pDataCount);

	// 회전 중심 전송
	// KBJ 2022-11-14 회전중심과 Rotate 시 동일한 어드레스 사용하여 예외처리 추가
	int find_method = vt_job_info[0].model_info.getAlignInfo().getMarkFindMethod();
	if (find_method != METHOD_CIRCLE)
	{
		rotateX = GetMachine(0).getRotateX(0, 0);
		rotateY = GetMachine(0).getRotateY(0, 0);

		pDataCount[0] = LOWORD(rotateX * MOTOR_SCALE);
		pDataCount[1] = HIWORD(rotateX * MOTOR_SCALE);
		pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
		pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
		g_CommPLC.SetWord(centerAddress + 14, 4, pDataCount);
	}
	if (pDataSendX != NULL) delete pDataSendX;
	if (pDataSendY != NULL) delete pDataSendY;
	if (pDataSendT != NULL) delete pDataSendT;

	if (vt_job_info[0].model_info.getAlignInfo().getUseReverseOrder())
	{
		double tmp_Rx = m_ELB_TraceResult.m_vELB_RotateCenter.x;
		double tmp_Ry = m_ELB_TraceResult.m_vELB_RotateCenter.y;
		m_ELB_TraceResult.m_vELB_RotateCenter.x = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x;
		m_ELB_TraceResult.m_vELB_RotateCenter.y = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y;
		m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x = tmp_Rx;
		m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y = tmp_Ry;

		int lCount = int(m_ELB_TraceResult.m_vTraceProfile[0].size()), id_t = 0;
		double xoffset_t = m_ELB_TraceResult.m_vTraceProfile[0].at(lCount - 1);
		double yoffset_t = m_ELB_TraceResult.m_vTraceProfile[1].at(lCount - 1);
		double toffset_t = m_ELB_TraceResult.m_vTraceProfile[2].at(lCount - 1);
		for (int i = 0; i < lCount; i++)
		{
			id_t = lCount - 1 - i;
			m_vTraceProfile_t[0].push_back(m_ELB_TraceResult.m_vTraceProfile[0].at(id_t) - xoffset_t);
			m_vTraceProfile_t[1].push_back(m_ELB_TraceResult.m_vTraceProfile[1].at(id_t) - yoffset_t);
			m_vTraceProfile_t[2].push_back(m_ELB_TraceResult.m_vTraceProfile[2].at(id_t) - toffset_t);
		}
		for (int i = 0; i < lCount; i++)
		{
			m_ELB_TraceResult.m_vTraceProfile[0].at(i) = m_vTraceProfile_t[0].at(i);
			m_ELB_TraceResult.m_vTraceProfile[1].at(i) = m_vTraceProfile_t[1].at(i);
			m_ELB_TraceResult.m_vTraceProfile[2].at(i) = m_vTraceProfile_t[2].at(i);
		}

		m_vTraceProfile_t[0].clear();
		m_vTraceProfile_t[1].clear();
		m_vTraceProfile_t[2].clear();
	}
}
void CLET_AlignClientDlg::sendTraceProfileData(int startAddress,int centerAddress,double pitch) 
{
	std::vector<double> m_vTraceProfile_t[3];
	if (vt_job_info[0].model_info.getAlignInfo().getUseReverseOrder())
	{
		double tmp_Rx = m_ELB_TraceResult.m_vELB_RotateCenter.x;
		double tmp_Ry = m_ELB_TraceResult.m_vELB_RotateCenter.y;
		m_ELB_TraceResult.m_vELB_RotateCenter.x = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x;
		m_ELB_TraceResult.m_vELB_RotateCenter.y = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y;
		m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x = tmp_Rx;
		m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y = tmp_Ry;

		int lCount = int(m_ELB_TraceResult.m_vTraceProfile[0].size()), id_t = 0;
		double xoffset_t = m_ELB_TraceResult.m_vTraceProfile[0].at(lCount - 1);
		double yoffset_t = m_ELB_TraceResult.m_vTraceProfile[1].at(lCount - 1);
		double toffset_t = m_ELB_TraceResult.m_vTraceProfile[2].at(lCount - 1);

		for (int i = 0; i < lCount; i++)
		{
			id_t = lCount - 1 - i;
			m_vTraceProfile_t[0].push_back(m_ELB_TraceResult.m_vTraceProfile[0].at(id_t) - xoffset_t);
			m_vTraceProfile_t[1].push_back(m_ELB_TraceResult.m_vTraceProfile[1].at(id_t) - yoffset_t);
			m_vTraceProfile_t[2].push_back(m_ELB_TraceResult.m_vTraceProfile[2].at(id_t) - toffset_t);
		}

		for (int i = 0; i < lCount; i++)
		{
			m_ELB_TraceResult.m_vTraceProfile[0].at(i) = m_vTraceProfile_t[0].at(i);
			m_ELB_TraceResult.m_vTraceProfile[1].at(i) = m_vTraceProfile_t[1].at(i);
			m_ELB_TraceResult.m_vTraceProfile[2].at(i) = m_vTraceProfile_t[2].at(i);
		}
	}
	long pDataCount[4] = { 0, };
	long* pDataSendX = NULL;
	long* pDataSendY = NULL;
	long* pDataSendT = NULL;

	int lineCount = int(m_ELB_TraceResult.m_vTraceProfile[0].size());
	double rotateX = m_ELB_TraceResult.m_vELB_RotateCenter.x;
	double rotateY = m_ELB_TraceResult.m_vELB_RotateCenter.y;
	double step = 0,x,y,t;

	pDataSendX = new long[lineCount * 4];
	pDataSendY = new long[lineCount * 4];
	pDataSendT = new long[lineCount * 4];

	for (int i = 0; i < lineCount; i++)
	{
		step = pitch* i * MOTOR_SCALE;
		x = -m_ELB_TraceResult.m_vTraceProfile[0].at(i) * MOTOR_SCALE;
		y = m_ELB_TraceResult.m_vTraceProfile[1].at(i) * MOTOR_SCALE;
		t = m_ELB_TraceResult.m_vTraceProfile[2].at(i)* MOTOR_SCALE;

		pDataSendX[i * 2 + 0] = LOWORD(x);
		pDataSendX[i * 2 + 1] = HIWORD(x);

		pDataSendY[i * 2 + 0] = LOWORD(y);
		pDataSendY[i * 2 + 1] = HIWORD(y);
		
		pDataSendT[i * 2 + 0] = LOWORD(t);
		pDataSendT[i * 2 + 1] = HIWORD(t);
	}

	////////////////////////////
	// 정방향 데이타 전송
	pDataCount[0] = LOWORD(lineCount);
	pDataCount[1] = HIWORD(lineCount);
	pDataCount[2] = LOWORD(pitch * MOTOR_SCALE);
	pDataCount[3] = HIWORD(pitch * MOTOR_SCALE);
	// 데이타 수량
	g_CommPLC.SetWordZR(startAddress			, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 1600		, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 3200		, 2, pDataCount);
	// PITCH
	g_CommPLC.SetWordZR(startAddress + 2		, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 1602		, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 3202		, 2, &pDataCount[2]);
	// 좌표값
	g_CommPLC.SetWordZR(startAddress + 4		, lineCount*2, pDataSendX);
	g_CommPLC.SetWordZR(startAddress + 1604		, lineCount * 2, pDataSendY);
	g_CommPLC.SetWordZR(startAddress + 3204		, lineCount * 2, pDataSendT);
	// 역방향 데이타 전송
	
	//데이타 수량
	g_CommPLC.SetWordZR(startAddress + 100000	, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 101600	, 2, pDataCount);
	g_CommPLC.SetWordZR(startAddress + 103200	, 2, pDataCount);
	
	// PITCH
	g_CommPLC.SetWordZR(startAddress + 100002	, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 101602	, 2, &pDataCount[2]);
	g_CommPLC.SetWordZR(startAddress + 103202	, 2, &pDataCount[2]);
	
	// 좌표값 계산
	double xoffset = m_ELB_TraceResult.m_vTraceProfile[0].at(lineCount - 1);
	double yoffset = m_ELB_TraceResult.m_vTraceProfile[1].at(lineCount - 1);
	double toffset = m_ELB_TraceResult.m_vTraceProfile[2].at(lineCount - 1);
	int id = 0;

	for (int i = 0; i < lineCount; i++)
	{
		id = lineCount - 1 - i;
		step = -pitch * i * MOTOR_SCALE;

		x = -(m_ELB_TraceResult.m_vTraceProfile[0].at(id)-xoffset) * MOTOR_SCALE;
		y = (m_ELB_TraceResult.m_vTraceProfile[1].at(id)-yoffset) * MOTOR_SCALE;
		t = (m_ELB_TraceResult.m_vTraceProfile[2].at(id)-toffset) * MOTOR_SCALE;

		pDataSendX[i * 2 + 0] = LOWORD(x);
		pDataSendX[i * 2 + 1] = HIWORD(x);

		pDataSendY[i * 2 + 0] = LOWORD(y);
		pDataSendY[i * 2 + 1] = HIWORD(y);

		pDataSendT[i * 2 + 0] = LOWORD(t);
		pDataSendT[i * 2 + 1] = HIWORD(t);
	}
	g_CommPLC.SetWordZR(startAddress + 100004	, lineCount * 2, pDataSendX);
	g_CommPLC.SetWordZR(startAddress + 101604	, lineCount * 2, pDataSendY);
	g_CommPLC.SetWordZR(startAddress + 103204	, lineCount * 2, pDataSendT);

	////////////////////////////
	//도포 시작 위치 전송
	pDataCount[0] = LOWORD(-rotateX * MOTOR_SCALE);
	pDataCount[1] = HIWORD(-rotateX * MOTOR_SCALE);
	pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
	pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
	g_CommPLC.SetWord(centerAddress + 6, 4, pDataCount);

	// 역방향 시작 위치 전송
	rotateX = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x;
	rotateY = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y;
	pDataCount[0] = LOWORD(-rotateX * MOTOR_SCALE);
	pDataCount[1] = HIWORD(-rotateX * MOTOR_SCALE);
	pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
	pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
	g_CommPLC.SetWord(centerAddress + 10, 4, pDataCount);
    
	// 회전 중심 전송
	// KBJ 2022-11-14 회전중심과 Rotate 시 동일한 어드레스 사용하여 예외처리 추가
	int find_method = vt_job_info[0].model_info.getAlignInfo().getMarkFindMethod();
	if (find_method != METHOD_CIRCLE)
	{
		rotateX = GetMachine(0).getRotateX(0, 0);
		rotateY = GetMachine(0).getRotateY(0, 0);

		pDataCount[0] = LOWORD(rotateX * MOTOR_SCALE);
		pDataCount[1] = HIWORD(rotateX * MOTOR_SCALE);
		pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
		pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
		g_CommPLC.SetWord(centerAddress + 14, 4, pDataCount);
	}
	if (pDataSendX != NULL) delete pDataSendX;
	if (pDataSendY != NULL) delete pDataSendY;
	if (pDataSendT != NULL) delete pDataSendT;

	if (vt_job_info[0].model_info.getAlignInfo().getUseReverseOrder())
	{		
		double tmp_Rx = m_ELB_TraceResult.m_vELB_RotateCenter.x;
		double tmp_Ry = m_ELB_TraceResult.m_vELB_RotateCenter.y;
		m_ELB_TraceResult.m_vELB_RotateCenter.x = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x;
		m_ELB_TraceResult.m_vELB_RotateCenter.y = m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y;
		m_ELB_TraceResult.m_vELB_ReverseRotateCenter.x = tmp_Rx;
		m_ELB_TraceResult.m_vELB_ReverseRotateCenter.y = tmp_Ry;

		int lCount = int(m_ELB_TraceResult.m_vTraceProfile[0].size()), id_t = 0;
		double xoffset_t = m_ELB_TraceResult.m_vTraceProfile[0].at(lCount - 1);
		double yoffset_t = m_ELB_TraceResult.m_vTraceProfile[1].at(lCount - 1);
		double toffset_t = m_ELB_TraceResult.m_vTraceProfile[2].at(lCount - 1);
		for (int i = 0; i < lCount; i++)
		{
			id_t = lCount - 1 - i;
			m_vTraceProfile_t[0].push_back(m_ELB_TraceResult.m_vTraceProfile[0].at(id_t) - xoffset_t);
			m_vTraceProfile_t[1].push_back(m_ELB_TraceResult.m_vTraceProfile[1].at(id_t) - yoffset_t);
			m_vTraceProfile_t[2].push_back(m_ELB_TraceResult.m_vTraceProfile[2].at(id_t) - toffset_t);
		}
		for (int i = 0; i < lCount; i++)
		{
			m_ELB_TraceResult.m_vTraceProfile[0].at(i) = m_vTraceProfile_t[0].at(i);
			m_ELB_TraceResult.m_vTraceProfile[1].at(i) = m_vTraceProfile_t[1].at(i);
			m_ELB_TraceResult.m_vTraceProfile[2].at(i) = m_vTraceProfile_t[2].at(i);
		}

		m_vTraceProfile_t[0].clear();
		m_vTraceProfile_t[1].clear();
		m_vTraceProfile_t[2].clear();
	}
}

//KJH 2022-06-28 Film Feeding 검사를 이용한 Auto Feeding Time Offset 계산
void CLET_AlignClientDlg::sendFilmFeedingOffsetData(double sdata,double tdate, int job_id,int id)
{
	int addr_wd_curr_offset_data = vt_job_info[job_id].plc_addr_info.write_word_start + 16 + 20 * id;
	long pOffsetData[8] = { 0, };

	double _V0, _T1, _T2, _T3, _X1, _X2, _X3;

	//V0 피딩속도										ex ) 5
	//T1 등속도시간										ex ) 0.7
	//T2 등가속도시간										ex ) 0.3
	
	//X1 현재계산값 (화면 계산값이랑 반대 [피딩된 총량])	ex ) 4.25
	//X2 계산타겟값 (화면 계산값이랑 반대 [피딩된 총량])	ex ) 4.25 - (-1) = 5.25
	//X3 offset Value  = Target - Vision Calc Value		ex ) -1	[2 - 3]

	//T3 변경할등속도시간									ex) Calc = 0.9

	//PLC 인터페이스 추가해서 현재 설정값을 읽어와야 한다. 우선은 예시값으로 계산시 4.25 -> 변수로 변경작업필요

	_V0 = 5;
	_T1 = 0.7;
	_T2 = 0.3;

	// 현재 설정값에 대한 계산
	// X1 = V0 * T1 + (0.5) * V0 * T2
	// 
	// 변경 설정값에 대한 계산
	// T3 = X2 / V0 - (0.5) * T2
	// 
	// Offset = T3 - T1

	_X1 = (_V0 * _T1) + (0.5) * _V0 * _T2;

	_X3 = tdate - sdata;

	_X2 = _X1 - _X3;

	_T3 = (_X2 / _V0) - (0.5) * _T2;

	double calcOffset = _T3 - _T1;

	pOffsetData[0] = LOWORD(long(calcOffset * MOTOR_SCALE));
	pOffsetData[1] = HIWORD(long(calcOffset * MOTOR_SCALE));

	g_CommPLC.SetWord(addr_wd_curr_offset_data, 2, pOffsetData);
}

void CLET_AlignClientDlg::sendMatchingRateData(int job_id)
{
	//PLC Interface 4Cam 기준
	// 
	//KJH 2022-03-12 MatchingRate Setting Value FDC 보고 추가
	
	int nCamCount = vt_job_info[job_id].num_of_camera;
	int nPosCount = vt_job_info[job_id].num_of_position;
	//nCam * nPos -> Matching Rate		(2Word)
	//nCam * nPos -> Matching Setting	(1Word)

	int nTotalSize			= nCamCount * nPosCount * SIZE_MATCHING_RATE_DATA;
	int nSettingTotalSize	= nCamCount * nPosCount * SIZE_MATCHING_SETTING_DATA;

	int arrycount = 0;

	long pMatchingData[8] = { 0, };
	long pMatchingSettingData[4] = { 0, };

	CString str;
	str.Format("[%s] Rate ", vt_job_info[job_id].job_name.c_str());

	int nMethod = vt_job_info[job_id].algo_method;
	switch (nMethod)
	{
	case CLIENT_TYPE_ALIGN:
	case CLIENT_TYPE_1CAM_1SHOT_FILM:
	case CLIENT_TYPE_1CAM_1SHOT_ALIGN:
	case CLIENT_TYPE_4CAM_1SHOT_ALIGN:
	case CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP:
	{
		// 정수로 1word만 전송 21.03.08
		// 정수로 2Word로 전송 ELB 2021-09-02		????
		for (int nCam = 0; nCam < nCamCount; nCam++)
		{
			for (int nPos = 0; nPos < nPosCount; nPos++)
			{
				//pMatchingData[nCam * 2]				= long(GetMatching(job_id).getFindInfo(nCam, nPos).getScore() * 100);
				pMatchingData[arrycount * 2]			= LOWORD(long(GetMatching(job_id).getFindInfo(nCam, nPos).getScore() * 100));
				pMatchingData[arrycount * 2 + 1]		= HIWORD(long(GetMatching(job_id).getFindInfo(nCam, nPos).getScore() * 100));
				pMatchingSettingData[arrycount]			= long(GetMatching(job_id).getFindInfo(nCam, nPos).GetFindIndex());

				arrycount++;

				str.Format("%s (%f) Cam %d - %d", str, GetMatching(job_id).getFindInfo(nCam, nPos).getScore(), nCam + 1 , nPos + 1);
			}
		}
	}
	break;
	case CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN:
	{
		// 정수로 1word만 전송 21.03.08
		for (int nPos = 0; nPos < 2; nPos++)
		{
			for (int nCam = 0; nCam < nCamCount; nCam++)
			{
				//배열 입력시 POS 고려는 없는데...???
				pMatchingData[nCam * 2]		= long(GetMatching(job_id).getFindInfo(nCam, nPos).getScore() * 100);
				pMatchingSettingData[nCam]	= long(GetMatching(job_id).getFindInfo(nCam, 0).GetFindIndex());
				str.Format("%s (%f)Cam %d - %d", str, GetMatching(job_id).getFindInfo(nCam, nPos).getScore(), nCam + 1, nPos + 1);
			}
		}
	}
	break;
	}
	
	int addr_wd_curr_matching_data = vt_job_info[job_id].plc_addr_info.write_word_start + 6;
	int addr_wd_curr_matching_setting = vt_job_info[job_id].plc_addr_info.write_word_start + 14;

	g_CommPLC.SetWord(addr_wd_curr_matching_data, nTotalSize, pMatchingData);
	g_CommPLC.SetWord(addr_wd_curr_matching_setting, nSettingTotalSize, pMatchingSettingData);

	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
}

//Default 2CAM에서 패턴매칭 2개
//Default 4CAM에서 패턴매칭 각 1개씩 4개

//Process
int CLET_AlignClientDlg::ProcessPrealignINFRA(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {	// processPrealignINFRA()
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		int grabdelay = vt_job_info[nJob].model_info.getAlignInfo().getGrabDelay();  // Grab Dealy 추가 항목 22.07.06 Tkyuha
		Delay(grabdelay);

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif
			
			
			LightControllerTurnOnOff(nJob, nCam, 0);

			////KJH 2021-05-29 Grab전 조명 ON
			//for (int nLight = 0; nLight < vt_job_info[nJob].light_info[nCam].num_of_using_light; nLight++)
			//{
			//	int ctrl = vt_job_info[nJob].light_info[nCam].controller_id[nLight] - 1;
			//	int ch = vt_job_info[nJob].light_info[nCam].channel_id[nLight];
			//	int value = vt_job_info[nJob].model_info.getLightInfo().getLightBright(nCam, nLight, 0);
			//	if (m_stLightCtrlInfo.nType[0] == LTYPE_LLIGHT_LPC_COT_232)
			//	{
			//		SetLightBright(ctrl, ch, value == 0 ? 0 : value * 10);   // dh.jung 2021-07-12
			//	}
			//	else
			//	{
			//		SetLightBright(ctrl, ch, value);
			//	}
			//	Delay(50);
			//}

			str.Format("[%s] Cam %d - Light On", vt_job_info[nJob].job_name.c_str(), nCam + 1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
#ifdef _DAHUHA
			if (m_pDahuhaCam[real_cam].isconnected())
#else
			if (m_pBaslerCam[real_cam] || m_pSaperaCam[real_cam].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[nJob].job_name.c_str(), nCam + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				Camera_Grab(real_cam);
				//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, real_cam);
			}
		}

		m_nGrabTimeOutCount[nJob] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bGrabEnd[real_cam] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);

			str.Format("[%s] Grab Complete", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			m_pPattern[real_cam].pDlg = this;
			m_pPattern[real_cam].nPos = 0;
			m_pPattern[real_cam].nCam = nCam;
			m_pPattern[real_cam].nSearchCount = 1;
			m_pPattern[real_cam].nJob = nJob;
			m_bFindPatternEnd[real_cam] = FALSE;
			m_bFindPattern[real_cam] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);
		}
	}
	break;
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPatternEnd[real_cam] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPattern[real_cam] != TRUE)
				bFind = FALSE;
			else
			{
				vt_result_info[nJob].each_Judge[nCam][0] = TRUE;
			}
		}

		if (bFind != TRUE)
		{
			m_nManualInputMarkCount[nJob]++;

			//KJH 2022-03-10 L-Check Error일 경우에도 Manual Mark 가능하게 변경
			//JSH 2022-03-16 진입 조건에서 L-Check 삭제
			// YCS 2022-11-08 Pre Align 매뉴얼 마크 진입 조건에 마크 카운트 파라미터 추가
			if (vt_job_info[nJob].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge() &&
				m_nManualInputMarkCount[nJob] > vt_job_info[nJob].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudgeCount())
			{
				// KBJ 2022-10-11 Manual Mark Bit 추가
				g_CommPLC.SetBit(vt_job_info[nJob].plc_addr_info.write_bit_start + 8, TRUE);

				str.Format("[%s][%s]Manual Mark Input - %d - %d", vt_job_info[nJob].job_name.c_str(), vt_job_info[nJob].main_object_id.c_str(),m_bFindPattern[camBuf.at(0)], m_bFindPattern[camBuf.at(1)]);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK, MAKELPARAM(nJob, TRUE));
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 400;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			else
			{
				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				str.Format("Mark Search Error - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
				write_NGresult_SummaryFile(vt_job_info[nJob].main_object_id.c_str(), str, FALSE, nJob);
			}

			break;
		}
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 350;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 350:
	{
		m_nErrorType[nJob] = 0;

	jumpLabel2:

		// 보정량 계산
		int nCamL = 0;
		int nCamR = 1;

		int cam_pos = vt_job_info[nJob].model_info.getAlignInfo().getAlignmentTargetDir();
		// sub mark offset 보상을 해주자.
		//if (camCount == 1)		calc_sub_mark_offset_1cam_2pos(algorithm);
		//else if (camCount == 2)	calc_sub_mark_offset_2cam_1pos(algorithm, cam_pos);

		CString strTemp;
		double posX = 0.0;
		double posY = 0.0;
		double worldX, worldY;
		int nPos = 0;
		// 이미지 좌표계 → 실 좌표계
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			CFindInfo pFindInfo = GetMatching(nJob).getFindInfo(nCam, nPos);
			real_cam = camBuf.at(nCam);
			posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
			posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

			int bMethod = vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod();

			//kmb 230112 Method MarkEdge 추가
			if (bMethod == METHOD_MARK_EDGE) {
				find_panel_mark_edge_line(getProcBuffer(nCam, 0), nJob, nCam, &posX, &posY);


				pFindInfo.SetXPos(posX);
				pFindInfo.SetYPos(posY);
				GetMatching(nJob).setFindInfo(nCam, nPos, pFindInfo);
			}

			GetMachine(nJob).PixelToWorld(nCam, nPos, posX, posY, &worldX, &worldY);

			GetPrealign(nJob).setPosX(nCam, worldX);
			GetPrealign(nJob).setPosY(nCam, worldY);
		}

		GetPrealign(nJob).setAlignmentType(vt_job_info[nJob].model_info.getMachineInfo().getAlignmentType());

		BOOL _second_Align=FALSE;
		_second_Align = g_CommPLC.GetBit(m_nAlignRequestRead[nJob]+11); //두번째 얼라이 요청
		if (_second_Align)
		{
			GetPrealign(nJob).setRotateX(nCamL, GetMachine(nJob).getRotateX(nCamL, 1));
			GetPrealign(nJob).setRotateY(nCamL, GetMachine(nJob).getRotateY(nCamL, 1));
			GetPrealign(nJob).setRotateX(nCamR, GetMachine(nJob).getRotateX(nCamR, 1));
			GetPrealign(nJob).setRotateY(nCamR, GetMachine(nJob).getRotateY(nCamR, 1));
		}
		else
		{

			GetPrealign(nJob).setRotateX(nCamL, GetMachine(nJob).getRotateX(nCamL, nPos));
			GetPrealign(nJob).setRotateY(nCamL, GetMachine(nJob).getRotateY(nCamL, nPos));
			GetPrealign(nJob).setRotateX(nCamR, GetMachine(nJob).getRotateX(nCamR, nPos));
			GetPrealign(nJob).setRotateY(nCamR, GetMachine(nJob).getRotateY(nCamR, nPos));
		}
			
			
		switch (vt_job_info[nJob].model_info.getAlignInfo().getAngleCalcMethod()) {
			case 1:			// Glass Size
			{
				GetPrealign(nJob).setPatternPitchX(vt_job_info[nJob].model_info.getGlassInfo().getGlassWidth());
				GetPrealign(nJob).setPatternPitchY(vt_job_info[nJob].model_info.getGlassInfo().getGlassHeight());
			}
			break;
			case 2:			// Frame Size
			{
				GetPrealign(nJob).setPatternPitchX(vt_job_info[nJob].model_info.getGlassInfo().getFrameWidth());
				GetPrealign(nJob).setPatternPitchY(vt_job_info[nJob].model_info.getGlassInfo().getFrameHeight());
			}
			break;
			case 3:			// Rotate Center
			{
				double pitch_x = fabs(GetMachine(nJob).getRotateX(nCamL, nPos) - GetMachine(nJob).getRotateX(nCamR, nPos));
				double pitch_y = fabs(GetMachine(nJob).getRotateY(nCamL, nPos) - GetMachine(nJob).getRotateY(nCamR, nPos));
					
				GetPrealign(nJob).setPatternPitchX(pitch_x);
				GetPrealign(nJob).setPatternPitchY(pitch_y);
			}
			break;
			default:		//	Align Key
			{
				if(vt_job_info[nJob].model_info.getAlignInfo().getAlignmentTargetDir() == CAM_HORI )
					GetPrealign(nJob).setPatternPitchX(vt_job_info[nJob].model_info.getAlignInfo().getFiducialMarkPitchX());
				else 
					GetPrealign(nJob).setPatternPitchY(vt_job_info[nJob].model_info.getAlignInfo().getFiducialMarkPitchX());

				if (_second_Align)
				{
					GetPrealign(nJob).setPatternPitchX(vt_job_info[nJob].model_info.getGlassInfo().getFrameWidth());
					GetPrealign(nJob).setPatternPitchY(vt_job_info[nJob].model_info.getGlassInfo().getFrameHeight());
				}
			}
			break;
		}

		// mm로 Offset 적용
		GetPrealign(nJob).setRevisionOffset(0, vt_job_info[nJob].model_info.getMachineInfo().getRevisionOffset(0));
		GetPrealign(nJob).setRevisionOffset(1, vt_job_info[nJob].model_info.getMachineInfo().getRevisionOffset(1));
		GetPrealign(nJob).setRevisionOffset(2, vt_job_info[nJob].model_info.getMachineInfo().getRevisionOffset(2));
		GetPrealign(nJob).pDlg = this;

		// 방향 결정
		GetPrealign(nJob).setReverseAxisX(vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseX());
		GetPrealign(nJob).setReverseAxisY(vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseY());
		GetPrealign(nJob).setReverseAxisT(vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseT());
		GetPrealign(nJob).setReverseAxisXY(vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseXY());

		BOOL breverse = vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverse();

		if (GetPrealign(nJob).calcRevision(nCamL, nCamR, cam_pos, breverse, FALSE) != 0)
		{
			str.Format("[%s] Calc Revision Failed", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			nRet = 2;
			m_nErrorType[nJob] = ERR_TYPE_REVISION_FAIL;

			m_dbRevisionData[nJob][AXIS_X] = 0;
			m_dbRevisionData[nJob][AXIS_Y] = 0;
			m_dbRevisionData[nJob][AXIS_T] = 0;
			break;
		}

		// 보정량 전송
		if (fabs(GetPrealign(nJob).getRevisionX()) > vt_job_info[nJob].model_info.getMachineInfo().getRevisionLimit(AXIS_X) ||
			fabs(GetPrealign(nJob).getRevisionY()) > vt_job_info[nJob].model_info.getMachineInfo().getRevisionLimit(AXIS_Y) ||
			fabs(GetPrealign(nJob).getRevisionT()) > vt_job_info[nJob].model_info.getMachineInfo().getRevisionLimit(AXIS_T))
		{
			//KJH 2021-07-26 Limit일때... 보정값 디스플레이 이상한거 수정
			m_dbRevisionData[nJob][AXIS_X] = GetPrealign(nJob).getRevisionX();
			m_dbRevisionData[nJob][AXIS_Y] = GetPrealign(nJob).getRevisionY();
			m_dbRevisionData[nJob][AXIS_T] = GetPrealign(nJob).getRevisionT();

			m_nErrorType[nJob] = ERR_TYPE_REVISION_LIMIT;

			nRet = 2;
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s][Limit NG] X : %.4f Y : %.4f T : %.4f", vt_job_info[nJob].job_name.c_str(), m_dbRevisionData[nJob][AXIS_X], m_dbRevisionData[nJob][AXIS_Y], m_dbRevisionData[nJob][AXIS_T]);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			// KBJ 2022-07-06 Align Revision Limit NG Error Message 추가
			CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
			str.Format("[Revision Limit NG] X : %.4f Y : %.4f T : %.4f", m_dbRevisionData[nJob][AXIS_X], m_dbRevisionData[nJob][AXIS_Y], m_dbRevisionData[nJob][AXIS_T]);
			pFormMain->ShowErrorMessageBlink(str);
			break;
		}
		// L_Check 검사 위치 변동 20.02.20
		///////// L Check 검사
		if (vt_job_info[nJob].model_info.getAlignInfo().getEnableLCheck())
		{
			BOOL bError = FALSE;

			if( camCount == 2 )			bError = calc_lcheck_2cam_1pos(nJob);
			else if( camCount == 4 )	bError = calc_lcheck_4cam_1pos(nJob);
				
			if (bError)
			{
				//JSH 2022-03-16 L-Check Error일 경우에도 Manual Mark 가능하게 변경 => 현재 매뉴얼 마크 기능 OFF LCHECK  에러 인경우
				if (vt_job_info[nJob].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge())
				{
					// KBJ 2022-10-11 Manual Mark Bit 추가
					g_CommPLC.SetBit(vt_job_info[nJob].plc_addr_info.write_bit_start + 8, TRUE);

					str.Format("[%s][%s]Manual Mark Input - %d - %d", vt_job_info[nJob].job_name.c_str(), vt_job_info[nJob].main_object_id.c_str(), m_bFindPattern[camBuf.at(0)], m_bFindPattern[camBuf.at(1)]);
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

					::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK, MAKELPARAM(nJob, TRUE));
					AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
					m_nSeqProcess[nJob] = 400;
					ReleaseSRWLockExclusive(&g_srwlock);
				}
				else
				{
					//SendServer(TCP_SEND_ALIGN_L_CHECK_NG, algorithm);
					//nRet = 2;
					//m_nSeqProcess[algorithm] = 0;
					m_nErrorType[nJob] = ERR_TYPE_L_CHECK;
					m_bLcheckNG[nJob] = TRUE;
					AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
					m_nSeqProcess[nJob] = 0;
					ReleaseSRWLockExclusive(&g_srwlock);
					nRet = 2;						
				}

				// KBJ 2022-07-06 Align Revision Limit NG Error Message 추가
				CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
				strTemp.Format("[L-Check Error !] \n L: %.3f, Spec: %.3f ~ %.3f", m_dbLCheck[nJob][0], m_dbLCheckSpec[nJob][0] - vt_job_info[nJob].model_info.getAlignInfo().getLCheckTor(), m_dbLCheckSpec[nJob][0] + vt_job_info[nJob].model_info.getAlignInfo().getLCheckTor());
				pFormMain->ShowErrorMessageBlink(strTemp);

				break;
			}
			else
			{
				m_bLcheckNG[nJob] = FALSE;
			}
			/*
			double camDist = getModel().getAlignInfo().getLCheckScale(camBuf.at(0));
			int W = m_pViewDisplayInfo[nCamL].getViewImageWidth();
			int H = m_pViewDisplayInfo[nCamL].getViewImageHeight();

			double posX1 = GetPrealign(algorithm).getPosX(0);
			double posY1 = GetPrealign(algorithm).getPosY(0);
			double posX2 = GetPrealign(algorithm).getPosX(1);
			double posY2 = GetPrealign(algorithm).getPosY(1);

			int nCam = 0;
			double world[2][2] = { 0, };
			GetMachine().PixelToWorld(nCam, 0, 0, &world[0][0], &world[0][1]);
			GetMachine().PixelToWorld(nCam, W, H, &world[1][0], &world[1][1]);

			// Robot 좌표계의 방향에 따라 거리 값을 반영.
			if (getModel().getAlignInfo().getAlignmentTargetDir(camBuf.at(0)) == 0)		// Horizontal
			{
				if (world[1][0] > world[0][0])	posX2 += camDist;
				else							posX2 -= camDist;
			}
			else															// Vertical
			{
				if (world[1][1] > world[0][1])	posY2 += camDist;
				else							posY2 -= camDist;
			}

			double dx = posX1 - posX2;
			double dy = posY1 - posY2;
			double diagonal = sqrt(dx * dx + dy * dy);
			double limit = getModel().getAlignInfo().getLCheckLimit(algorithm);
			double pitch = getModel().getAlignInfo().getFiducialMarkPitchX(algorithm);

			str.Format("L : %.3f", diagonal);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			ncamera = camBuf.at(0);				
			writeLengthData(m_pViewDisplayInfo[ncamera].getPanelID(), diagonal, 2, algorithm);

			if (fabs(pitch - diagonal) > limit)
			{
				SendServer(TCP_SEND_ALIGN_L_CHECK_NG, algorithm);
				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			    m_nSeqProcess[algorithm] = 0;
			    ReleaseSRWLockExclusive(&g_srwlock);
				m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
				str.Format("L Check Error!! \r\nLength : %.3f, Pitch : %.3f, Limit : %.3f", diagonal, pitch, limit);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				m_dbLcheckLength[algorithm] = diagonal;
				m_bLcheckNG[algorithm] = TRUE;
				break;
			}
			*/
		}

		// 보정량 전송
		double xMove = 0, yMove = 0;
		GetPrealign(nJob).calcRotateOffset(GetPrealign(nJob).getRevisionOffset(2), xMove, yMove);

		// 시뮬레이션이면 보정량 보내지 않도록 추가.
		if (m_bSimulationStart != TRUE)
		{
			// 보정량 전송
			sendRevisionOffsetData(xMove, yMove, GetPrealign(nJob).getRevisionOffset(2));
			sendRevisionData(GetPrealign(nJob).getRevisionX(), GetPrealign(nJob).getRevisionY(), GetPrealign(nJob).getRevisionT(), nJob);
			// Matching Rate 전송
			sendMatchingRateData(nJob);
		}
		m_dbRevisionData[nJob][AXIS_X] = GetPrealign(nJob).getRevisionX();
		m_dbRevisionData[nJob][AXIS_Y] = GetPrealign(nJob).getRevisionY();
		m_dbRevisionData[nJob][AXIS_T] = GetPrealign(nJob).getRevisionT();

		str.Format("[%s] X: %.4f Y : %.4f T : %.4f", vt_job_info[nJob].job_name.c_str(), m_dbRevisionData[nJob][AXIS_X], m_dbRevisionData[nJob][AXIS_Y], m_dbRevisionData[nJob][AXIS_T]);
		
		//시간 전달

		CString strTime;
		SYSTEMTIME time;
		GetLocalTime(&time);
		
		/*if (m_strResultTime[nJob].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
		else										strTime.Format("%s:%s:%s", m_strResultTime[nJob].Left(2), m_strResultTime[nJob].Mid(3,2), m_strResultTime[nJob].Right(2));*/

		if (m_strResultTime[nJob].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
		else											strTime.Format("%s:%s:%s", m_strResultTime[nJob].Left(2), m_strResultTime[nJob].Mid(3, 2), m_strResultTime[nJob].Right(2));

		// HSJ 2022-02-14 thread_process로 위치변경
		//Align 결과값 띄우기
		/*::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)nJob);
		::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(bResult, nJob));
		::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(nJob));*/
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);

		nRet = 1;
	}
	break;
	case 400:
	{
		if (m_nManualInputMarkResult[nJob] == 1)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[nJob].plc_addr_info.write_bit_start + 8, FALSE);

			m_pManualInputMark[nJob]->KillTimer(TIMER_MANUAL_MARK);
			goto jumpLabel2;
		}
		else if (m_nManualInputMarkResult[nJob] == 2)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[nJob].plc_addr_info.write_bit_start + 8, FALSE);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			return 2;
		}
	}
	break;
#pragma region 시뮬레이션
	case 1000:
	{
		BOOL bFindPatternEnd = simulration_2cam_1shot_align(nJob);
		if(bFindPatternEnd == TRUE)	m_nSeqProcess[nJob] = 350;
		else
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;
		}
	}
	break;
#pragma endregion
	}
	return nRet;
}
BOOL CLET_AlignClientDlg::simulration_2cam_1shot_align(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	// 알고리즘 시작.

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		m_pPattern[real_cam].pDlg = this;
		m_pPattern[real_cam].nPos = 0;
		m_pPattern[real_cam].nCam = nCam;
		m_pPattern[real_cam].nSearchCount = 1;  //2point search
		m_pPattern[real_cam].nJob = nJob;

		m_bFindPattern[real_cam] = FALSE;
		m_bFindPatternEnd[real_cam] = FALSE;

		AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);

		Delay(50);
	}

	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	int MS_TIMEOUT = 10000;

	BOOL all_insp_end = TRUE;
	while (nEtick - nStick <= MS_TIMEOUT) {
		Sleep(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_insp_end = TRUE;
		
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];

			if (m_bFindPatternEnd[real_cam] != TRUE)
				all_insp_end = FALSE;
		}

		if (all_insp_end == TRUE) break;

		if (nEtick - nStick == MS_TIMEOUT)
		{
			str.Format("TimeOut(ms : %d) ", MS_TIMEOUT);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	if (all_insp_end != TRUE) return FALSE;


	BOOL bAllFind = TRUE;

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		int real_cam = vt_job_info[nJob].camera_index[nCam];

		if (m_bFindPattern[real_cam] != TRUE)
			bAllFind = FALSE;
	}

	return bAllFind;
}
int CLET_AlignClientDlg::process1Cam1ShotPrealign(int algorithm)
{
	if (each_job_method)
	{
		return g_Job_1Cam1ShotAlign[algorithm].do_auto_seq();
	}

	CString str;
	int nRet = 0, ncamera = 0;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;
#endif
	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[algorithm];
	ReleaseSRWLockExclusive(&g_srwlock);

	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	switch (_sequence) {	// processPrealignINFRA()
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		//KJH 2022-03-16 Act,Seq Time Display 추가
		m_clockStartTime[algorithm] = clock();

		int grabdelay = vt_job_info[algorithm].model_info.getAlignInfo().getGrabDelay();  // Grab Dealy 추가 항목 22.07.06 Tkyuha
		Delay(grabdelay);

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

			LightControllerTurnOnOff(algorithm, nCam, 0, TRUE);

			str.Format("[%s] Cam %d - Light On", vt_job_info[algorithm].job_name.c_str(), nCam + 1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[algorithm].job_name.c_str(), ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				Camera_Grab(ncamera);
				//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, ncamera);// Tkyuha 20211201 Thread로 변경				
			}
		}

		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);

		pFormMain->HideErrorMessageBlink();
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 0;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 2;  //2point search
			m_pPattern[ncamera].nJob = algorithm;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
		}
		
	}
	break;
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE)
		{
			// hsj 2022-02-12
			m_dbRevisionData[algorithm][AXIS_X] = 0;
			m_dbRevisionData[algorithm][AXIS_Y] = 0;
			m_dbRevisionData[algorithm][AXIS_T] = 0;

			break;
		}
		
		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPattern[ncamera] != TRUE)
				bFind = FALSE;
		}

		if (bFind != TRUE)
		{
			m_nManualInputMarkCount[algorithm]++;
#ifndef JOB_INFO
			if (getModel().getAlignInfo().getEnableAlignMeasureSpecOutJudge(camBuf.at(0)))
#else
			//KJH 2022-03-10 L-Check Error일 경우에도 Manual Mark 가능하게 변경
			//JSH 2022-03-16 진입 조건에서 L-Check 삭제
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge() &&
				m_nManualInputMarkCount[algorithm] > vt_job_info[algorithm].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudgeCount())
#endif
			{
				// KBJ 2022-10-11 Manual Mark Bit 추가
				g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, TRUE);

				str.Format("Manual Mark Input - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
				//::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK, MAKELPARAM(algorithm, TRUE));
				::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK_1CAM, MAKELPARAM(algorithm, TRUE));
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 400;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			else
			{
				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);

				// hsj 2022-02-12
				m_dbRevisionData[algorithm][AXIS_X] = 0;
				m_dbRevisionData[algorithm][AXIS_Y] = 0;
				m_dbRevisionData[algorithm][AXIS_T] = 0;

				str.Format("Mark Search Error - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
				write_NGresult_SummaryFile(vt_job_info[algorithm].main_object_id.c_str(), str, FALSE, algorithm);
			}
			break;
		}
		else
		{
		jumpLabel2:
			m_nErrorType[algorithm] = 0;

			double posX = 0.0, refX;
			double posY = 0.0, refY;
			double worldX, worldY, refworldX, refworldY;
			CString strTemp;

			// 이미지 좌표계 → 실 좌표계
			ncamera = camBuf.at(0);
			int nCam = 0;
			for (int nPos = 0; nPos < 2; nPos++)
			{
				//posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				//posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();


				//// 일단은 같은 좌표계에서 불러 오도록
				//GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);
				//GetPrealign(algorithm).setPosX(nPos, worldX);
				//GetPrealign(algorithm).setPosY(nPos, worldY);

				
				/*refX = GetMatching(algorithm).getRefX(nCam, nPos);
				refY = GetMatching(algorithm).getRefY(nCam, nPos);

				posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();

				GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);
				GetMachine(algorithm).PixelToWorld(nCam, nCam, refX, refY, &refworldX, &refworldY);

				if (refX != 0 && refY != 0)
				{
					worldX -= refworldX;
					worldY -= refworldY;
				}*/

				// hsj 2022-01-31 reference 사용유무 ----- start
				posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();

				GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);

				if (vt_job_info[algorithm].model_info.getAlignInfo().getUseReferenceMark())
				{
					refX = GetMatching(algorithm).getRefX(nCam, nPos);
					refY = GetMatching(algorithm).getRefY(nCam, nPos);

					GetMachine(algorithm).PixelToWorld(nCam, nCam, refX, refY, &refworldX, &refworldY);

					worldX -= refworldX;
					worldY -= refworldY;
				}

				// ----- end

				GetPrealign(algorithm).setPosX(nPos, worldX);
				GetPrealign(algorithm).setPosY(nPos, worldY);

				strTemp.Format("[Cam %d] Pos %d - x : %.1f y : %.1f", ncamera + 1, nPos, posX, posY);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
			}

			// 보정량 계산
			int nCamL = 0;
			int nCamR = 1;

			GetPrealign(algorithm).setRotateX(nCamL, GetMachine(algorithm).getRotateX(nCamL, 0));
			GetPrealign(algorithm).setRotateY(nCamL, GetMachine(algorithm).getRotateY(nCamL, 0));
			GetPrealign(algorithm).setRotateX(nCamR, GetMachine(algorithm).getRotateX(nCamR, 0));
			GetPrealign(algorithm).setRotateY(nCamR, GetMachine(algorithm).getRotateY(nCamR, 0));

			// mm로 Offset 적용
			GetPrealign(algorithm).setRevisionOffset(0, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(0));
			GetPrealign(algorithm).setRevisionOffset(1, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(1));
			GetPrealign(algorithm).setRevisionOffset(2, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(2));
			GetPrealign(algorithm).pDlg = this;

			// 방향 결정
			GetPrealign(algorithm).setReverseAxisX(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX());
			GetPrealign(algorithm).setReverseAxisY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY());
			GetPrealign(algorithm).setReverseAxisT(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT());
			GetPrealign(algorithm).setReverseAxisXY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseXY());
			int target_dir = vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir();


			switch (vt_job_info[algorithm].model_info.getAlignInfo().getAngleCalcMethod()) {
			case 1:			// Glass Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getGlassWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getGlassHeight());
			}
			break;
			case 2:			// Frame Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getFrameWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getFrameHeight());
			}
			break;
			case 3:			// Rotate Center
			{
				double pitch_x = fabs(GetMachine(algorithm).getRotateX(nCamL, 0) - GetMachine(algorithm).getRotateX(nCamR, 0));
				double pitch_y = fabs(GetMachine(algorithm).getRotateY(nCamL, 0) - GetMachine(algorithm).getRotateY(nCamR, 0));

				GetPrealign(algorithm).setPatternPitchX(pitch_x);
				GetPrealign(algorithm).setPatternPitchY(pitch_y);
			}
			break;
			default:		//	Align Key
			{
				if (vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir() == CAM_HORI)
					GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
				else
					// GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
					GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchY());		// dh.jung 2021-07-21  change

			}
			break;
			}

			BOOL bUse = vt_job_info[algorithm].model_info.getMachineInfo().getUseImageTheta();
			GetPrealign(algorithm).set_use_image_theta(bUse);

			if (bUse)
			{
				double posX[2], posY[2];
				double theta = 0.0;
				posX[0] = GetMatching(algorithm).getFindInfo(0, 0).GetXPos();
				posY[0] = GetMatching(algorithm).getFindInfo(0, 0).GetYPos();
				posX[1] = GetMatching(algorithm).getFindInfo(0, 1).GetXPos();
				posY[1] = GetMatching(algorithm).getFindInfo(0, 1).GetYPos();

				double dx = posX[1] - posX[0];
				double dy = posY[1] - posY[0];

				if(target_dir == 0 )	theta = atan(dy / dx);
				else					theta = atan(dx / dy);
				GetPrealign(algorithm).set_image_theta(theta);
			}
			
			int type = vt_job_info[algorithm].model_info.getMachineInfo().getAlignmentType();


			GetPrealign(algorithm).setAlignmentType(type);

			if (vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING_LINE_THETA)
			{
				int real_cam = vt_job_info[algorithm].camera_index[0];

				sLine line_info[2];
				line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][0][0].m_lineInfo;
				line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][1][0].m_lineInfo;

				double robot_x[2];
				double robot_y[2];

				double theta = 0.0;

				if (0)
				{
					GetMachine(algorithm).PixelToWorld(0, 0, line_info[0].sx, line_info[0].sy, &robot_x[0], &robot_y[0]);
					GetMachine(algorithm).PixelToWorld(0, 0, line_info[1].sx, line_info[1].sy, &robot_x[1], &robot_y[1]);

					double dx = robot_x[0] - robot_x[1];
					double dy = robot_y[0] - robot_y[1];

					theta = -atan(dy / dx) / 3.141592 * 180.0;
				}
				else
				{
					double dx = line_info[0].sx - line_info[1].sx;
					double dy = line_info[0].sy - line_info[1].sy;

					theta = atan(dy / dx) / 3.141592 * 180.0;
				}

				//double dx = line_info[0].sx - line_info[1].sx;
				//double dy = line_info[0].sy - line_info[1].sy;

				//double theta = atan(dy / dx) / 3.141592 * 360.0;

				if (GetPrealign(algorithm).calcRevision(0, 1, theta) != 0)
				{
					str = "Calc Revision Failed";
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					nRet = 2;
					m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

					m_dbRevisionData[algorithm][AXIS_X] = 0;
					m_dbRevisionData[algorithm][AXIS_Y] = 0;
					m_dbRevisionData[algorithm][AXIS_T] = 0;
					break;
				}
			}
			else
			{
				// kbj 2022-01-05 add Rotate(1) = Rotate(0)
				double RotateX, RotateY = 0;
				RotateX = vt_job_info[algorithm].model_info.getMachineInfo().getRotateCenterX(0, 0);
				RotateY = vt_job_info[algorithm].model_info.getMachineInfo().getRotateCenterY(0, 0);
				GetPrealign(algorithm).setRotateX(1,RotateX);
				GetPrealign(algorithm).setRotateY(1,RotateY);

				if (GetPrealign(algorithm).calcRevision(0, 1, target_dir) != 0)
				{
					str = "Calc Revision Failed";
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					nRet = 2;
					m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

					m_dbRevisionData[algorithm][AXIS_X] = 0;
					m_dbRevisionData[algorithm][AXIS_Y] = 0;
					m_dbRevisionData[algorithm][AXIS_T] = 0;
					break;
				}
			}

			// 보정량 전송
			if (fabs(GetPrealign(algorithm).getRevisionX()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_X) ||
				fabs(GetPrealign(algorithm).getRevisionY()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_Y) ||
				fabs(GetPrealign(algorithm).getRevisionT()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_T))
			{
				m_nErrorType[algorithm] = ERR_TYPE_REVISION_LIMIT;

				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);

				// hsj 2022-02-12
				m_dbRevisionData[algorithm][AXIS_X] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData[algorithm][AXIS_Y] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData[algorithm][AXIS_T] = GetPrealign(algorithm).getRevisionT();

				str.Format("[%s] X : %.4f Y : %.4f T : %.4f NG Limit", vt_job_info[algorithm].job_name.c_str(), GetPrealign(algorithm).getRevisionX(),
					GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// KBJ 2022-07-06 Align Revision Limit NG Error Message 추가
				str.Format("[Revision Limit NG] X : %.4f Y : %.4f T : %.4f", GetPrealign(algorithm).getRevisionX(),
					GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
				pFormMain->ShowErrorMessageBlink(str);

				break;
			}

			// 20220410 Tkyuha 필름 부착된 패널 재투입 방지를 위한 검사 진행 
			// => 켈리퍼에 원으로 위치 지정 하고 왼쪽 마크 Fixture 등록 해서 사용 할것
			if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFilmReAttachCheckEnable())
			{
				int real_cam = camBuf.at(0);
				int _thresh = vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFilmReAttachCheckThresh();
				int W = m_stCamInfo[real_cam].w;
				int H = m_stCamInfo[real_cam].h;
				double _posX = GetMatching(algorithm).getFindInfo(0, 0).GetXPos();
				double _posY = GetMatching(algorithm).getFindInfo(0, 0).GetYPos();

				double fixtureX = 0, fixtureY = 0;

				BOOL bFixtureUse = vt_job_info[algorithm].model_info.getAlignInfo().getUseFixtureMark();
				if (bFixtureUse)
				{
					fixtureX = _posX - GetMatching(algorithm).getFixtureX(0, 0);
					fixtureY = _posY - GetMatching(algorithm).getFixtureY(0, 0);

					// 2022-05-10 KBJ
					m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].setFixtureX(fixtureX);
					m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].setFixtureY(fixtureY);
					m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].calcPointsByFixture();
				}

				if (m_pDlgCaliper->m_Caliper[real_cam][0][0].getCircleCaliper())
				{
					_st32fPoint spt = m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].getStartPt();
					_st32fPoint ept = m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].getEndPt();
					//cv::Rect _inspRoi = cv::Rect(MIN(spt.x, ept.x), MIN(spt.y, ept.y), int(fabs(ept.x - spt.x)), int(fabs(ept.y - spt.y)));
					cv::Rect _inspRoi = cv::Rect(MIN(spt.x, ept.x), MIN(spt.y, ept.y), int(MAX(spt.x, ept.x) - MIN(spt.x, ept.x)), int(MAX(spt.y, ept.y) - MIN(spt.y, ept.y)));

					// 2022-05-10 KBJ
					//_inspRoi.x = MAX(0,_inspRoi.x + fixtureX);
					//_inspRoi.y = MAX(0,_inspRoi.y + fixtureY);
					_inspRoi.x = MAX(0, _inspRoi.x);
					_inspRoi.y = MAX(0, _inspRoi.y);

					cv::Mat img(H, W, CV_8UC1, getProcBuffer(real_cam, 0));
					double _mean = (cv::mean(img(_inspRoi))).val[0];
					img.release();

					BOOL bRevserse = vt_job_info[algorithm].model_info.getInspSpecParaInfo().getUseReverseThresh();
	
					if (bRevserse != TRUE && _thresh < _mean)
					{
						strTemp.Format("[Film White Finded !] B: %.3f, Spec: %d Gray ", _mean, _thresh);
						pFormMain->ShowErrorMessageBlink(strTemp);

						AcquireSRWLockExclusive(&g_srwlock);
						m_nSeqProcess[algorithm] = 0;
						ReleaseSRWLockExclusive(&g_srwlock);
						nRet = 2;
						break;
					}
					else if (bRevserse == TRUE && _thresh > _mean)
					{
						strTemp.Format("[Film Balck Finded !] B: %.3f, Spec: %d Gray ", _mean, _thresh);
						pFormMain->ShowErrorMessageBlink(strTemp);

						AcquireSRWLockExclusive(&g_srwlock);
						m_nSeqProcess[algorithm] = 0;
						ReleaseSRWLockExclusive(&g_srwlock);
						nRet = 2;
						break;
					}
					else strTemp.Format("[%s] Bright : %.3f, Spec: %d Gray", vt_job_info[algorithm].get_job_name(), _mean, _thresh);

					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
				}
			}

			// L_Check 검사 위치 변동 20.02.20
			///////// L Check 검사

#ifndef JOB_INFO
			if (getModel().getAlignInfo().getEnableLCheck(camBuf.at(0)))
#else
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableLCheck())
#endif
			{
				// kbj 2022-01-06 save lcheck NG
				m_bLcheckNG[algorithm] = calc_lcheck_1cam_1shot(algorithm);	// yeol 20210602

				if (m_bLcheckNG[algorithm] == TRUE)
				{
					// KBJ 2022-07-06 Align Revision Limit NG Error Message 추가
					CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
					strTemp.Format("[L-Check Error !] \n L: %.3f, Spec: %.3f ~ %.3f", m_dbLCheck[algorithm][0], m_dbLCheckSpec[algorithm][0] - vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor(), m_dbLCheckSpec[algorithm][0] + vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor());
					pFormMain->ShowErrorMessageBlink(strTemp);

					m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
					nRet = 2;
					break;
				}

				//double camDist = getModel().getAlignInfo().getLCheckScale(camBuf.at(0));

				//double posX1 = GetPrealign(algorithm).getPosX(0);
				//double posY1 = GetPrealign(algorithm).getPosY(0);
				//double posX2 = GetPrealign(algorithm).getPosX(1);
				//double posY2 = GetPrealign(algorithm).getPosY(1);

				//int nCam = ncamera;
				//double world[2][2] = { 0, };
				//int W = m_pViewDisplayInfo[nCam].getViewImageWidth();
				//int H = m_pViewDisplayInfo[nCam].getViewImageHeight();

				//GetMachine().PixelToWorld(nCam, 0, 0, &world[0][0], &world[0][1]);
				//GetMachine().PixelToWorld(nCam, W, H, &world[1][0], &world[1][1]);

				//// Robot 좌표계의 방향에 따라 거리 값을 반영.
				//if (getModel().getAlignInfo().getAlignmentTargetDir(ncamera) == 0)		// Horizontal
				//{
				//	if (world[1][0] > world[0][0])	posX2 += camDist;
				//	else							posX2 -= camDist;
				//}
				//else															// Vertical
				//{
				//	if (world[1][1] > world[0][1])	posY2 += camDist;
				//	else							posY2 -= camDist;
				//}

				//double dx = posX1 - posX2;
				//double dy = posY1 - posY2;
				//double diagonal = sqrt(dx * dx + dy * dy);
				//double limit = getModel().getAlignInfo().getLCheckLimit(nCam);
				//double pitch = getModel().getAlignInfo().getFiducialMarkPitchX(algorithm);

				//str.Format("L : %.3f", diagonal);
				//::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				//ncamera = camBuf.at(0);
				//writeLengthData(m_pViewDisplayInfo[ncamera].getPanelID(), diagonal, 2, algorithm);

				//if (fabs(pitch - diagonal) > limit)
				//{
				//	nRet = 2;
				//	m_nSeqProcess[algorithm] = 0;
				//	m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
				//	str.Format("L Check Error!! \r\nLength : %.3f, Pitch : %.3f, Limit : %.3f", diagonal, pitch, limit);
				//	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				//	m_dbLcheckLength[algorithm] = diagonal;
				//	m_bLcheckNG[algorithm] = TRUE;
				//	break;
				//}
			}

			// 보정량 전송
			double xMove = 0, yMove = 0;
			GetPrealign(algorithm).calcRotateOffset(GetPrealign(algorithm).getRevisionOffset(2), xMove, yMove);
			//sendRevisionOffsetData(xMove, yMove, GetPrealign(algorithm).getRevisionOffset(2));

			// kbj 2021-12-25 1cam1shot prcoess 시뮬레이션이면 보정량 보내지 않도록 추가.
			if (m_bSimulationStart != TRUE)
			{
				sendRevisionOffsetData(xMove, yMove, GetPrealign(algorithm).getRevisionOffset(2));

				sendRevisionData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);

				sendMatchingRateData(algorithm);
			}
			m_dbRevisionData[algorithm][AXIS_X] = GetPrealign(algorithm).getRevisionX();
			m_dbRevisionData[algorithm][AXIS_Y] = GetPrealign(algorithm).getRevisionY();
			m_dbRevisionData[algorithm][AXIS_T] = GetPrealign(algorithm).getRevisionT();

			//str.Format("X : %.4f Y : %.4f T : %.4f", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);
			str.Format("[%s] X : %.4f Y : %.4f T : %.4f", vt_job_info[algorithm].get_job_name(), m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);  // dh.jung 2021-07-21  change
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			//시간 전달

			CString strTime;
			SYSTEMTIME time;
			GetLocalTime(&time);

			/*if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else									strTime.Format("%s", m_strResultTime[algorithm]);*/

			if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else												strTime.Format("%s:%s:%s", m_strResultTime[algorithm].Left(2), m_strResultTime[algorithm].Mid(3, 2), m_strResultTime[algorithm].Right(2));

			// HSJ 2022-02-14 thread_process로 위치변경
			//Align 결과값 띄우기
			//::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)algorithm);
			//::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(bResult, algorithm));
			//::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(algorithm));*/
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);

			nRet = 1;
		}
	}
	break;
	case 400:
		if (m_nManualInputMarkResult[algorithm] == 1)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
			//m_pManualInputMark[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			m_pManualInputMark1Cam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			goto jumpLabel2;
		}
		else if (m_nManualInputMarkResult[algorithm] == 2)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			return 2;
		}
		break;
//2021-12-27 1cam 1shot 시뮬레이션 추가.
	case 1000:
		//KJH 2022-03-16 Act,Seq Time Display 추가
		m_clockStartTime[algorithm] = clock();

		BOOL bFindPatternEnd = simulration_1cam_1shot_align(algorithm);
		if (bFindPatternEnd == TRUE) m_nSeqProcess[algorithm] = 300;
		else
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;
		}
		break;
	}
	return nRet;
}
BOOL CLET_AlignClientDlg::simulration_1cam_1shot_align(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	// 알고리즘 시작.

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		m_pPattern[real_cam].pDlg = this;
		m_pPattern[real_cam].nPos = 0;
		m_pPattern[real_cam].nCam = nCam;
		m_pPattern[real_cam].nSearchCount = 2;  //2point search
		m_pPattern[real_cam].nJob = nJob;

		m_bFindPattern[real_cam] = FALSE;
		m_bFindPatternEnd[real_cam] = FALSE;

		AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);

		Delay(50);
	}

	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	int MS_TIMEOUT = 10000;

	BOOL all_insp_end = TRUE;
	while (nEtick - nStick <= MS_TIMEOUT) {
		Sleep(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_insp_end = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];

			if (m_bFindPatternEnd[real_cam] != TRUE)
				all_insp_end = FALSE;
		}

		if (all_insp_end == TRUE) break;

		if (nEtick - nStick == MS_TIMEOUT)
		{
			str.Format("TimeOut(ms : %d) ", MS_TIMEOUT);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	if (all_insp_end != TRUE) return FALSE;


	BOOL bAllFind = TRUE;

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		int real_cam = vt_job_info[nJob].camera_index[nCam];

		if (m_bFindPattern[real_cam] != TRUE)
			bAllFind = FALSE;
	}

	return bAllFind;
}

int CLET_AlignClientDlg::process1Cam1ShotPrealignWithScratchInsp(int algorithm)
{
	if (each_job_method)
	{
		return g_Job_1Cam1ShotAlign[algorithm].do_auto_seq();
	}

	CString str;
	int nRet = 0, ncamera = 0;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;
#endif
	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[algorithm];
	ReleaseSRWLockExclusive(&g_srwlock);

	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	switch (_sequence) {	// processPrealignINFRA()
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		//KJH 2022-03-16 Act,Seq Time Display 추가
		m_clockStartTime[algorithm] = clock();

		int grabdelay = vt_job_info[algorithm].model_info.getAlignInfo().getGrabDelay();  // Grab Dealy 추가 항목 22.07.06 Tkyuha
		Delay(grabdelay);

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);

#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

			LightControllerTurnOnOff(algorithm, nCam, 0, TRUE);

			str.Format("[%s] Cam %d - Light On", vt_job_info[algorithm].job_name.c_str(), nCam + 1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[algorithm].job_name.c_str(), ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				Camera_Grab(ncamera);
				//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, ncamera);// Tkyuha 20211201 Thread로 변경				
			}
		}

		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);

		pFormMain->HideErrorMessageBlink();
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 0;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 2;  //2point search
			m_pPattern[ncamera].nJob = algorithm;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
		}

		if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getScratchCheck())
		//if (g_CommPLC.GetBit(m_nAlignRequestRead[algorithm] + 2))
		{
			ResetEvent(m_hInspEndEvent[ncamera]);
			m_bSubInspJudge[ncamera] = TRUE;
			ScratchInsp(algorithm);
		}
	}
	break;
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE)
		{
			// hsj 2022-02-12
			m_dbRevisionData[algorithm][AXIS_X] = 0;
			m_dbRevisionData[algorithm][AXIS_Y] = 0;
			m_dbRevisionData[algorithm][AXIS_T] = 0;

			break;
		}

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPattern[ncamera] != TRUE)
				bFind = FALSE;
		}

		if (bFind != TRUE)
		{
#ifndef JOB_INFO
			if (getModel().getAlignInfo().getEnableAlignMeasureSpecOutJudge(camBuf.at(0)))
#else
			//KJH 2022-03-10 L-Check Error일 경우에도 Manual Mark 가능하게 변경
			//JSH 2022-03-16 진입 조건에서 L-Check 삭제
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge())
#endif
			{
				// KBJ 2022-10-11 Manual Mark Bit 추가
				g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, TRUE);

				str.Format("Manual Mark Input - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
				//::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK, MAKELPARAM(algorithm, TRUE));
				::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK_1CAM, MAKELPARAM(algorithm, TRUE));
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 400;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			else
			{
				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);

				// hsj 2022-02-12
				m_dbRevisionData[algorithm][AXIS_X] = 0;
				m_dbRevisionData[algorithm][AXIS_Y] = 0;
				m_dbRevisionData[algorithm][AXIS_T] = 0;

				str.Format("Mark Search Error - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
				write_NGresult_SummaryFile(vt_job_info[algorithm].main_object_id.c_str(), str, FALSE, algorithm);
			}
			break;
		}
		else
		{
		jumpLabel2:
			m_nErrorType[algorithm] = 0;

			double posX = 0.0, refX;
			double posY = 0.0, refY;
			double worldX, worldY, refworldX, refworldY;
			CString strTemp;

			// 이미지 좌표계 → 실 좌표계
			ncamera = camBuf.at(0);
			int nCam = 0;
			for (int nPos = 0; nPos < 2; nPos++)
			{
				//posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				//posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();


				//// 일단은 같은 좌표계에서 불러 오도록
				//GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);
				//GetPrealign(algorithm).setPosX(nPos, worldX);
				//GetPrealign(algorithm).setPosY(nPos, worldY);


				/*refX = GetMatching(algorithm).getRefX(nCam, nPos);
				refY = GetMatching(algorithm).getRefY(nCam, nPos);

				posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();

				GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);
				GetMachine(algorithm).PixelToWorld(nCam, nCam, refX, refY, &refworldX, &refworldY);

				if (refX != 0 && refY != 0)
				{
					worldX -= refworldX;
					worldY -= refworldY;
				}*/

				// hsj 2022-01-31 reference 사용유무 ----- start
				posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();

				GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);

				if (vt_job_info[algorithm].model_info.getAlignInfo().getUseReferenceMark())
				{
					refX = GetMatching(algorithm).getRefX(nCam, nPos);
					refY = GetMatching(algorithm).getRefY(nCam, nPos);

					GetMachine(algorithm).PixelToWorld(nCam, nCam, refX, refY, &refworldX, &refworldY);

					worldX -= refworldX;
					worldY -= refworldY;
				}

				// ----- end

				GetPrealign(algorithm).setPosX(nPos, worldX);
				GetPrealign(algorithm).setPosY(nPos, worldY);

				strTemp.Format("[Cam %d] Pos %d - x : %.1f y : %.1f", ncamera + 1, nPos, posX, posY);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
			}

			// 보정량 계산
			int nCamL = 0;
			int nCamR = 1;

			GetPrealign(algorithm).setRotateX(nCamL, GetMachine(algorithm).getRotateX(nCamL, 0));
			GetPrealign(algorithm).setRotateY(nCamL, GetMachine(algorithm).getRotateY(nCamL, 0));
			GetPrealign(algorithm).setRotateX(nCamR, GetMachine(algorithm).getRotateX(nCamR, 0));
			GetPrealign(algorithm).setRotateY(nCamR, GetMachine(algorithm).getRotateY(nCamR, 0));

			// mm로 Offset 적용
			GetPrealign(algorithm).setRevisionOffset(0, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(0));
			GetPrealign(algorithm).setRevisionOffset(1, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(1));
			GetPrealign(algorithm).setRevisionOffset(2, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(2));
			GetPrealign(algorithm).pDlg = this;

			// 방향 결정
			GetPrealign(algorithm).setReverseAxisX(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX());
			GetPrealign(algorithm).setReverseAxisY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY());
			GetPrealign(algorithm).setReverseAxisT(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT());
			GetPrealign(algorithm).setReverseAxisXY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseXY());
			int target_dir = vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir();


			switch (vt_job_info[algorithm].model_info.getAlignInfo().getAngleCalcMethod()) {
			case 1:			// Glass Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getGlassWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getGlassHeight());
			}
			break;
			case 2:			// Frame Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getFrameWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getFrameHeight());
			}
			break;
			case 3:			// Rotate Center
			{
				double pitch_x = fabs(GetMachine(algorithm).getRotateX(nCamL, 0) - GetMachine(algorithm).getRotateX(nCamR, 0));
				double pitch_y = fabs(GetMachine(algorithm).getRotateY(nCamL, 0) - GetMachine(algorithm).getRotateY(nCamR, 0));

				GetPrealign(algorithm).setPatternPitchX(pitch_x);
				GetPrealign(algorithm).setPatternPitchY(pitch_y);
			}
			break;
			default:		//	Align Key
			{
				if (vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir() == CAM_HORI)
					GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
				else
					// GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
					GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchY());		// dh.jung 2021-07-21  change

			}
			break;
			}

			BOOL bUse = vt_job_info[algorithm].model_info.getMachineInfo().getUseImageTheta();
			GetPrealign(algorithm).set_use_image_theta(bUse);

			if (bUse)
			{
				double posX[2], posY[2];
				double theta = 0.0;
				posX[0] = GetMatching(algorithm).getFindInfo(0, 0).GetXPos();
				posY[0] = GetMatching(algorithm).getFindInfo(0, 0).GetYPos();
				posX[1] = GetMatching(algorithm).getFindInfo(0, 1).GetXPos();
				posY[1] = GetMatching(algorithm).getFindInfo(0, 1).GetYPos();

				double dx = posX[1] - posX[0];
				double dy = posY[1] - posY[0];

				if (target_dir == 0)	theta = atan(dy / dx);
				else					theta = atan(dx / dy);
				GetPrealign(algorithm).set_image_theta(theta);
			}

			int type = vt_job_info[algorithm].model_info.getMachineInfo().getAlignmentType();


			GetPrealign(algorithm).setAlignmentType(type);

			if (vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING_LINE_THETA)
			{
				int real_cam = vt_job_info[algorithm].camera_index[0];

				sLine line_info[2];
				line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][0][0].m_lineInfo;
				line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][1][0].m_lineInfo;

				double robot_x[2];
				double robot_y[2];

				double theta = 0.0;

				if (0)
				{
					GetMachine(algorithm).PixelToWorld(0, 0, line_info[0].sx, line_info[0].sy, &robot_x[0], &robot_y[0]);
					GetMachine(algorithm).PixelToWorld(0, 0, line_info[1].sx, line_info[1].sy, &robot_x[1], &robot_y[1]);

					double dx = robot_x[0] - robot_x[1];
					double dy = robot_y[0] - robot_y[1];

					theta = -atan(dy / dx) / 3.141592 * 180.0;
				}
				else
				{
					double dx = line_info[0].sx - line_info[1].sx;
					double dy = line_info[0].sy - line_info[1].sy;

					theta = atan(dy / dx) / 3.141592 * 180.0;
				}

				//double dx = line_info[0].sx - line_info[1].sx;
				//double dy = line_info[0].sy - line_info[1].sy;

				//double theta = atan(dy / dx) / 3.141592 * 360.0;

				if (GetPrealign(algorithm).calcRevision(0, 1, theta) != 0)
				{
					str = "Calc Revision Failed";
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					nRet = 2;
					m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

					m_dbRevisionData[algorithm][AXIS_X] = 0;
					m_dbRevisionData[algorithm][AXIS_Y] = 0;
					m_dbRevisionData[algorithm][AXIS_T] = 0;
					break;
				}
			}
			else
			{
				// kbj 2022-01-05 add Rotate(1) = Rotate(0)
				double RotateX, RotateY = 0;
				RotateX = vt_job_info[algorithm].model_info.getMachineInfo().getRotateCenterX(0, 0);
				RotateY = vt_job_info[algorithm].model_info.getMachineInfo().getRotateCenterY(0, 0);
				GetPrealign(algorithm).setRotateX(1, RotateX);
				GetPrealign(algorithm).setRotateY(1, RotateY);

				if (GetPrealign(algorithm).calcRevision(0, 1, target_dir) != 0)
				{
					str = "Calc Revision Failed";
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					nRet = 2;
					m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

					m_dbRevisionData[algorithm][AXIS_X] = 0;
					m_dbRevisionData[algorithm][AXIS_Y] = 0;
					m_dbRevisionData[algorithm][AXIS_T] = 0;
					break;
				}
			}

			// 보정량 전송
			if (fabs(GetPrealign(algorithm).getRevisionX()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_X) ||
				fabs(GetPrealign(algorithm).getRevisionY()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_Y) ||
				fabs(GetPrealign(algorithm).getRevisionT()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_T))
			{
				m_nErrorType[algorithm] = ERR_TYPE_REVISION_LIMIT;

				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);

				// hsj 2022-02-12
				m_dbRevisionData[algorithm][AXIS_X] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData[algorithm][AXIS_Y] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData[algorithm][AXIS_T] = GetPrealign(algorithm).getRevisionT();

				str.Format("[%s] X : %.4f Y : %.4f T : %.4f NG Limit", vt_job_info[algorithm].job_name.c_str(), GetPrealign(algorithm).getRevisionX(),
					GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// KBJ 2022-07-06 Align Revision Limit NG Error Message 추가
				str.Format("[Revision Limit NG] X : %.4f Y : %.4f T : %.4f", GetPrealign(algorithm).getRevisionX(),
					GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
				pFormMain->ShowErrorMessageBlink(str);

				break;
			}

			// 20220410 Tkyuha 필름 부착된 패널 재투입 방지를 위한 검사 진행 
			// => 켈리퍼에 원으로 위치 지정 하고 왼쪽 마크 Fixture 등록 해서 사용 할것
			if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFilmReAttachCheckEnable())
			{
				int real_cam = camBuf.at(0);
				int _thresh = vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFilmReAttachCheckThresh();
				int W = m_stCamInfo[real_cam].w;
				int H = m_stCamInfo[real_cam].h;
				double _posX = GetMatching(algorithm).getFindInfo(0, 0).GetXPos();
				double _posY = GetMatching(algorithm).getFindInfo(0, 0).GetYPos();

				double fixtureX = 0, fixtureY = 0;

				BOOL bFixtureUse = vt_job_info[algorithm].model_info.getAlignInfo().getUseFixtureMark();
				if (bFixtureUse)
				{
					fixtureX = _posX - GetMatching(algorithm).getFixtureX(0, 0);
					fixtureY = _posY - GetMatching(algorithm).getFixtureY(0, 0);

					// 2022-05-10 KBJ
					m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].setFixtureX(fixtureX);
					m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].setFixtureY(fixtureY);
					m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].calcPointsByFixture();
				}

				if (m_pDlgCaliper->m_Caliper[real_cam][0][0].getCircleCaliper())
				{
					_st32fPoint spt = m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].getStartPt();
					_st32fPoint ept = m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].getEndPt();
					//cv::Rect _inspRoi = cv::Rect(MIN(spt.x, ept.x), MIN(spt.y, ept.y), int(fabs(ept.x - spt.x)), int(fabs(ept.y - spt.y)));
					cv::Rect _inspRoi = cv::Rect(MIN(spt.x, ept.x), MIN(spt.y, ept.y), int(MAX(spt.x, ept.x) - MIN(spt.x, ept.x)), int(MAX(spt.y, ept.y) - MIN(spt.y, ept.y)));

					// 2022-05-10 KBJ
					//_inspRoi.x = MAX(0,_inspRoi.x + fixtureX);
					//_inspRoi.y = MAX(0,_inspRoi.y + fixtureY);
					_inspRoi.x = MAX(0, _inspRoi.x);
					_inspRoi.y = MAX(0, _inspRoi.y);

					cv::Mat img(H, W, CV_8UC1, getProcBuffer(real_cam, 0));
					double _mean = (cv::mean(img(_inspRoi))).val[0];
					img.release();

					BOOL bRevserse = vt_job_info[algorithm].model_info.getInspSpecParaInfo().getUseReverseThresh();

					if (bRevserse != TRUE && _thresh < _mean)
					{
						strTemp.Format("[Film White Finded !] B: %.3f, Spec: %d Gray ", _mean, _thresh);
						pFormMain->ShowErrorMessageBlink(strTemp);

						AcquireSRWLockExclusive(&g_srwlock);
						m_nSeqProcess[algorithm] = 0;
						ReleaseSRWLockExclusive(&g_srwlock);
						nRet = 2;
						break;
					}
					else if (bRevserse == TRUE && _thresh > _mean)
					{
						strTemp.Format("[Film Balck Finded !] B: %.3f, Spec: %d Gray ", _mean, _thresh);
						pFormMain->ShowErrorMessageBlink(strTemp);

						AcquireSRWLockExclusive(&g_srwlock);
						m_nSeqProcess[algorithm] = 0;
						ReleaseSRWLockExclusive(&g_srwlock);
						nRet = 2;
						break;
					}
					else strTemp.Format("[%s] Bright : %.3f, Spec: %d Gray", vt_job_info[algorithm].get_job_name(), _mean, _thresh);

					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
				}
			}
			
			// L_Check 검사 위치 변동 20.02.20
			///////// L Check 검사

#ifndef JOB_INFO
			if (getModel().getAlignInfo().getEnableLCheck(camBuf.at(0)))
#else
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableLCheck())
#endif
			{
				// kbj 2022-01-06 save lcheck NG
				m_bLcheckNG[algorithm] = calc_lcheck_1cam_1shot(algorithm);	// yeol 20210602

				if (m_bLcheckNG[algorithm] == TRUE)
				{
					// KBJ 2022-07-06 Align Revision Limit NG Error Message 추가
					CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
					strTemp.Format("[L-Check Error !] \n L: %.3f, Spec: %.3f ~ %.3f", m_dbLCheck[algorithm][0], m_dbLCheckSpec[algorithm][0] - vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor(), m_dbLCheckSpec[algorithm][0] + vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor());
					pFormMain->ShowErrorMessageBlink(strTemp);

					m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
					nRet = 2;
					break;
				}

				//double camDist = getModel().getAlignInfo().getLCheckScale(camBuf.at(0));

				//double posX1 = GetPrealign(algorithm).getPosX(0);
				//double posY1 = GetPrealign(algorithm).getPosY(0);
				//double posX2 = GetPrealign(algorithm).getPosX(1);
				//double posY2 = GetPrealign(algorithm).getPosY(1);

				//int nCam = ncamera;
				//double world[2][2] = { 0, };
				//int W = m_pViewDisplayInfo[nCam].getViewImageWidth();
				//int H = m_pViewDisplayInfo[nCam].getViewImageHeight();

				//GetMachine().PixelToWorld(nCam, 0, 0, &world[0][0], &world[0][1]);
				//GetMachine().PixelToWorld(nCam, W, H, &world[1][0], &world[1][1]);

				//// Robot 좌표계의 방향에 따라 거리 값을 반영.
				//if (getModel().getAlignInfo().getAlignmentTargetDir(ncamera) == 0)		// Horizontal
				//{
				//	if (world[1][0] > world[0][0])	posX2 += camDist;
				//	else							posX2 -= camDist;
				//}
				//else															// Vertical
				//{
				//	if (world[1][1] > world[0][1])	posY2 += camDist;
				//	else							posY2 -= camDist;
				//}

				//double dx = posX1 - posX2;
				//double dy = posY1 - posY2;
				//double diagonal = sqrt(dx * dx + dy * dy);
				//double limit = getModel().getAlignInfo().getLCheckLimit(nCam);
				//double pitch = getModel().getAlignInfo().getFiducialMarkPitchX(algorithm);

				//str.Format("L : %.3f", diagonal);
				//::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				//ncamera = camBuf.at(0);
				//writeLengthData(m_pViewDisplayInfo[ncamera].getPanelID(), diagonal, 2, algorithm);

				//if (fabs(pitch - diagonal) > limit)
				//{
				//	nRet = 2;
				//	m_nSeqProcess[algorithm] = 0;
				//	m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
				//	str.Format("L Check Error!! \r\nLength : %.3f, Pitch : %.3f, Limit : %.3f", diagonal, pitch, limit);
				//	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				//	m_dbLcheckLength[algorithm] = diagonal;
				//	m_bLcheckNG[algorithm] = TRUE;
				//	break;
				//}
			}

			// 보정량 전송
			double xMove = 0, yMove = 0;
			GetPrealign(algorithm).calcRotateOffset(GetPrealign(algorithm).getRevisionOffset(2), xMove, yMove);
			//sendRevisionOffsetData(xMove, yMove, GetPrealign(algorithm).getRevisionOffset(2));

			// kbj 2021-12-25 1cam1shot prcoess 시뮬레이션이면 보정량 보내지 않도록 추가.
			if (m_bSimulationStart != TRUE)
			{
				sendRevisionOffsetData(xMove, yMove, GetPrealign(algorithm).getRevisionOffset(2));

				sendRevisionData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);

				//sendMatchingRateData(algorithm);
			}
			m_dbRevisionData[algorithm][AXIS_X] = GetPrealign(algorithm).getRevisionX();
			m_dbRevisionData[algorithm][AXIS_Y] = GetPrealign(algorithm).getRevisionY();
			m_dbRevisionData[algorithm][AXIS_T] = GetPrealign(algorithm).getRevisionT();

			//str.Format("X : %.4f Y : %.4f T : %.4f", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);
			str.Format("[%s] X : %.4f Y : %.4f T : %.4f", vt_job_info[algorithm].get_job_name(), m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);  // dh.jung 2021-07-21  change
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			//if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getScratchCheck())  //20220927 Scratch 검사 추가 Tkyuha
			if (g_CommPLC.GetBit(m_nAlignRequestRead[algorithm] + 2) && vt_job_info[algorithm].model_info.getInspSpecParaInfo().getScratchCheck())
			{
				int real_cam = camBuf.at(0);
				::WaitForSingleObject(m_hInspEndEvent[real_cam], 1000); // 1초 기다린후 정상 진행

				if (m_bSubInspJudge[real_cam] == FALSE)
				{
					AcquireSRWLockExclusive(&g_srwlock);
					m_nSeqProcess[algorithm] = 0;
					ReleaseSRWLockExclusive(&g_srwlock);
					//nRet = 2;
					//break;
				}
			}
			else
			{
				if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getScratchCheck() == TRUE && m_bSimulationStart == TRUE)
				{
					int real_cam = camBuf.at(0);
					::WaitForSingleObject(m_hInspEndEvent[real_cam], 1000); // 1초 기다린후 정상 진행

					if (m_bSubInspJudge[real_cam] == FALSE)
					{
						AcquireSRWLockExclusive(&g_srwlock);
						m_nSeqProcess[algorithm] = 0;
						ReleaseSRWLockExclusive(&g_srwlock);
						nRet = 2;
						break;
					}
				}
			}

			//시간 전달

			CString strTime;
			SYSTEMTIME time;
			GetLocalTime(&time);

			/*if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else									strTime.Format("%s", m_strResultTime[algorithm]);*/

			if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else												strTime.Format("%s:%s:%s", m_strResultTime[algorithm].Left(2), m_strResultTime[algorithm].Mid(3, 2), m_strResultTime[algorithm].Right(2));

			// HSJ 2022-02-14 thread_process로 위치변경
			//Align 결과값 띄우기
			//::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)algorithm);
			//::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(bResult, algorithm));
			//::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(algorithm));*/
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);

			nRet = 1;
		}
	}
	break;
	case 400:
		if (m_nManualInputMarkResult[algorithm] == 1)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
			//m_pManualInputMark[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			m_pManualInputMark1Cam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			goto jumpLabel2;
		}
		else if (m_nManualInputMarkResult[algorithm] == 2)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			return 2;
		}
		break;
		//2021-12-27 1cam 1shot 시뮬레이션 추가.
	case 1000:
		//KJH 2022-03-16 Act,Seq Time Display 추가
		m_clockStartTime[algorithm] = clock();

		BOOL bFindPatternEnd = simulration_1cam_1shot_align_with_scratch_insp(algorithm);
		if (bFindPatternEnd == TRUE) m_nSeqProcess[algorithm] = 300;
		else
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;
		}
		break;
	}
	return nRet;
}
BOOL CLET_AlignClientDlg::simulration_1cam_1shot_align_with_scratch_insp(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	// 알고리즘 시작.

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		m_pPattern[real_cam].pDlg = this;
		m_pPattern[real_cam].nPos = 0;
		m_pPattern[real_cam].nCam = nCam;
		m_pPattern[real_cam].nSearchCount = 2;  //2point search
		m_pPattern[real_cam].nJob = nJob;

		m_bFindPattern[real_cam] = FALSE;
		m_bFindPatternEnd[real_cam] = FALSE;

		AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);

		Delay(50);
	}

	if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getScratchCheck()) // 20220929 스크레치 검사 Tkyuha
	{
		ResetEvent(m_hInspEndEvent[real_cam]);
		m_bSubInspJudge[real_cam] = TRUE;
		ScratchInsp(nJob);
	}

	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	int MS_TIMEOUT = 10000;

	BOOL all_insp_end = TRUE;
	while (nEtick - nStick <= MS_TIMEOUT) {
		Sleep(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_insp_end = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];

			if (m_bFindPatternEnd[real_cam] != TRUE)
				all_insp_end = FALSE;
		}

		if (all_insp_end == TRUE) break;

		if (nEtick - nStick == MS_TIMEOUT)
		{
			str.Format("TimeOut(ms : %d) ", MS_TIMEOUT);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	if (all_insp_end != TRUE) return FALSE;


	BOOL bAllFind = TRUE;

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		int real_cam = vt_job_info[nJob].camera_index[nCam];

		if (m_bFindPattern[real_cam] != TRUE)
			bAllFind = FALSE;
	}
	return bAllFind;
}

//KJH 2022-05-11 Film Align Grab bit 관련 Process추가
int CLET_AlignClientDlg::process1Cam1ShotFilmalign(int algorithm)
{
	if (each_job_method)
	{
		return g_Job_1Cam1ShotAlign[algorithm].do_auto_seq();
	}

	CString str;
	int nRet = 0, ncamera = 0;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;
#endif
	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[algorithm];
	ReleaseSRWLockExclusive(&g_srwlock);

	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	switch (_sequence) {	// processPrealignINFRA()
	case 0:
		break;
	case 100:
	{
		//KJH 2022-03-16 Act,Seq Time Display 추가
		m_clockStartTime[algorithm] = clock();

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

			LightControllerTurnOnOff(algorithm, nCam, 0, TRUE);

			str.Format("[%s] Cam %d - Light On", vt_job_info[algorithm].job_name.c_str(), nCam + 1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			int grabdelay = vt_job_info[algorithm].model_info.getAlignInfo().getGrabDelay();  // Grab Dealy 추가 항목 22.07.06 Tkyuha

#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[algorithm].job_name.c_str(), ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				Camera_Grab(ncamera);
				//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, ncamera);// Tkyuha 20211201 Thread로 변경				
			}
		}

		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);

		pFormMain->HideErrorMessageBlink();
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);
			//KJH 2022-05-11 Film Align Grab bit 추가
			g_CommPLC.SetBit(m_nAlignOkWrite[algorithm] + 2, TRUE);
			str.Format("[%s] Grab Complete / Grab Bit On", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 0;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 2;  //2point search
			m_pPattern[ncamera].nJob = algorithm;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
		}

	}
	break;
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE)
		{
			// hsj 2022-02-12
			m_dbRevisionData[algorithm][AXIS_X] = 0;
			m_dbRevisionData[algorithm][AXIS_Y] = 0;
			m_dbRevisionData[algorithm][AXIS_T] = 0;

			break;
		}

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPattern[ncamera] != TRUE)
				bFind = FALSE;
		}

		if (bFind != TRUE)
		{
			m_nManualInputMarkCount[algorithm]++;
#ifndef JOB_INFO
			if (getModel().getAlignInfo().getEnableAlignMeasureSpecOutJudge(camBuf.at(0)))
#else
			//KJH 2022-03-10 L-Check Error일 경우에도 Manual Mark 가능하게 변경
			//JSH 2022-03-16 진입 조건에서 L-Check 삭제
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge() && 
				m_nManualInputMarkCount[algorithm] > vt_job_info[algorithm].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudgeCount())
#endif
			{
				// KBJ 2022-10-11 Manual Mark Bit 추가
				g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, TRUE);

				m_nManualInputMarkCount[algorithm] = 0;

				str.Format("Manual Mark Input - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				
				// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
				//::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK, MAKELPARAM(algorithm, TRUE));
				::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK_1CAM, MAKELPARAM(algorithm, TRUE));
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 400;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			else
			{
				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);

				// hsj 2022-02-12
				m_dbRevisionData[algorithm][AXIS_X] = 0;
				m_dbRevisionData[algorithm][AXIS_Y] = 0;
				m_dbRevisionData[algorithm][AXIS_T] = 0;

				str.Format("Mark Search Error - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
				write_NGresult_SummaryFile(vt_job_info[algorithm].main_object_id.c_str(), str, FALSE, algorithm);
			}
			break;
		}
		else
		{
			m_nManualInputMarkCount[algorithm] = 0;

		jumpLabel2:
			m_nErrorType[algorithm] = 0;

			double posX = 0.0, refX;
			double posY = 0.0, refY;
			double worldX, worldY, refworldX, refworldY;
			CString strTemp;

			// 이미지 좌표계 → 실 좌표계
			ncamera = camBuf.at(0);
			int nCam = 0;
			for (int nPos = 0; nPos < 2; nPos++)
			{
				//posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				//posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();


				//// 일단은 같은 좌표계에서 불러 오도록
				//GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);
				//GetPrealign(algorithm).setPosX(nPos, worldX);
				//GetPrealign(algorithm).setPosY(nPos, worldY);


				/*refX = GetMatching(algorithm).getRefX(nCam, nPos);
				refY = GetMatching(algorithm).getRefY(nCam, nPos);

				posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();

				GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);
				GetMachine(algorithm).PixelToWorld(nCam, nCam, refX, refY, &refworldX, &refworldY);

				if (refX != 0 && refY != 0)
				{
					worldX -= refworldX;
					worldY -= refworldY;
				}*/

				// hsj 2022-01-31 reference 사용유무 ----- start
				posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();

				GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);

				if (vt_job_info[algorithm].model_info.getAlignInfo().getUseReferenceMark())
				{
					refX = GetMatching(algorithm).getRefX(nCam, nPos);
					refY = GetMatching(algorithm).getRefY(nCam, nPos);

					GetMachine(algorithm).PixelToWorld(nCam, nCam, refX, refY, &refworldX, &refworldY);

					worldX -= refworldX;
					worldY -= refworldY;
				}

				// ----- end

				GetPrealign(algorithm).setPosX(nPos, worldX);
				GetPrealign(algorithm).setPosY(nPos, worldY);

				strTemp.Format("[Cam %d] Pos %d - x : %.1f y : %.1f", ncamera + 1, nPos, posX, posY);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
			}

			// 보정량 계산
			int nCamL = 0;
			int nCamR = 1;

			GetPrealign(algorithm).setRotateX(nCamL, GetMachine(algorithm).getRotateX(nCamL, 0));
			GetPrealign(algorithm).setRotateY(nCamL, GetMachine(algorithm).getRotateY(nCamL, 0));
			GetPrealign(algorithm).setRotateX(nCamR, GetMachine(algorithm).getRotateX(nCamR, 0));
			GetPrealign(algorithm).setRotateY(nCamR, GetMachine(algorithm).getRotateY(nCamR, 0));

			// mm로 Offset 적용
			GetPrealign(algorithm).setRevisionOffset(0, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(0));
			GetPrealign(algorithm).setRevisionOffset(1, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(1));
			GetPrealign(algorithm).setRevisionOffset(2, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(2));
			GetPrealign(algorithm).pDlg = this;

			// 방향 결정
			GetPrealign(algorithm).setReverseAxisX(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX());
			GetPrealign(algorithm).setReverseAxisY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY());
			GetPrealign(algorithm).setReverseAxisT(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT());
			GetPrealign(algorithm).setReverseAxisXY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseXY());
			int target_dir = vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir();


			switch (vt_job_info[algorithm].model_info.getAlignInfo().getAngleCalcMethod()) {
			case 1:			// Glass Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getGlassWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getGlassHeight());
			}
			break;
			case 2:			// Frame Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getFrameWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getFrameHeight());
			}
			break;
			case 3:			// Rotate Center
			{
				double pitch_x = fabs(GetMachine(algorithm).getRotateX(nCamL, 0) - GetMachine(algorithm).getRotateX(nCamR, 0));
				double pitch_y = fabs(GetMachine(algorithm).getRotateY(nCamL, 0) - GetMachine(algorithm).getRotateY(nCamR, 0));

				GetPrealign(algorithm).setPatternPitchX(pitch_x);
				GetPrealign(algorithm).setPatternPitchY(pitch_y);
			}
			break;
			default:		//	Align Key
			{
				if (vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir() == CAM_HORI)
					GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
				else
					// GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
					GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchY());		// dh.jung 2021-07-21  change

			}
			break;
			}

			BOOL bUse = vt_job_info[algorithm].model_info.getMachineInfo().getUseImageTheta();
			GetPrealign(algorithm).set_use_image_theta(bUse);

			if (bUse)
			{
				double posX[2], posY[2];
				double theta = 0.0;
				posX[0] = GetMatching(algorithm).getFindInfo(0, 0).GetXPos();
				posY[0] = GetMatching(algorithm).getFindInfo(0, 0).GetYPos();
				posX[1] = GetMatching(algorithm).getFindInfo(0, 1).GetXPos();
				posY[1] = GetMatching(algorithm).getFindInfo(0, 1).GetYPos();

				double dx = posX[1] - posX[0];
				double dy = posY[1] - posY[0];

				if (target_dir == 0)	theta = atan(dy / dx);
				else					theta = atan(dx / dy);
				GetPrealign(algorithm).set_image_theta(theta);
			}

			int type = vt_job_info[algorithm].model_info.getMachineInfo().getAlignmentType();


			GetPrealign(algorithm).setAlignmentType(type);

			if (vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING_LINE_THETA)
			{
				int real_cam = vt_job_info[algorithm].camera_index[0];

				sLine line_info[2];
				line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][0][0].m_lineInfo;
				line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][1][0].m_lineInfo;

				double robot_x[2];
				double robot_y[2];

				double theta = 0.0;

				if (0)
				{
					GetMachine(algorithm).PixelToWorld(0, 0, line_info[0].sx, line_info[0].sy, &robot_x[0], &robot_y[0]);
					GetMachine(algorithm).PixelToWorld(0, 0, line_info[1].sx, line_info[1].sy, &robot_x[1], &robot_y[1]);

					double dx = robot_x[0] - robot_x[1];
					double dy = robot_y[0] - robot_y[1];

					theta = -atan(dy / dx) / 3.141592 * 180.0;
				}
				else
				{
					double dx = line_info[0].sx - line_info[1].sx;
					double dy = line_info[0].sy - line_info[1].sy;

					theta = atan(dy / dx) / 3.141592 * 180.0;
				}

				//double dx = line_info[0].sx - line_info[1].sx;
				//double dy = line_info[0].sy - line_info[1].sy;

				//double theta = atan(dy / dx) / 3.141592 * 360.0;

				if (GetPrealign(algorithm).calcRevision(0, 1, theta) != 0)
				{
					str = "Calc Revision Failed";
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					nRet = 2;
					m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

					m_dbRevisionData[algorithm][AXIS_X] = 0;
					m_dbRevisionData[algorithm][AXIS_Y] = 0;
					m_dbRevisionData[algorithm][AXIS_T] = 0;
					break;
				}
			}
			else
			{
				// kbj 2022-01-05 add Rotate(1) = Rotate(0)
				double RotateX, RotateY = 0;
				RotateX = vt_job_info[algorithm].model_info.getMachineInfo().getRotateCenterX(0, 0);
				RotateY = vt_job_info[algorithm].model_info.getMachineInfo().getRotateCenterY(0, 0);
				GetPrealign(algorithm).setRotateX(1, RotateX);
				GetPrealign(algorithm).setRotateY(1, RotateY);

				if (GetPrealign(algorithm).calcRevision(0, 1, target_dir) != 0)
				{
					str = "Calc Revision Failed";
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					nRet = 2;
					m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

					m_dbRevisionData[algorithm][AXIS_X] = 0;
					m_dbRevisionData[algorithm][AXIS_Y] = 0;
					m_dbRevisionData[algorithm][AXIS_T] = 0;
					break;
				}
			}

			// 보정량 전송
			if (fabs(GetPrealign(algorithm).getRevisionX()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_X) ||
				fabs(GetPrealign(algorithm).getRevisionY()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_Y) ||
				fabs(GetPrealign(algorithm).getRevisionT()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_T))
			{
				m_nErrorType[algorithm] = ERR_TYPE_REVISION_LIMIT;

				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);

				// hsj 2022-02-12
				m_dbRevisionData[algorithm][AXIS_X] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData[algorithm][AXIS_Y] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData[algorithm][AXIS_T] = GetPrealign(algorithm).getRevisionT();

				str.Format("[%s] X : %.4f Y : %.4f T : %.4f NG Limit", vt_job_info[algorithm].job_name.c_str(), GetPrealign(algorithm).getRevisionX(),
					GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// KBJ 2022-07-06 Align Revision Limit NG Error Message 추가
				CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
				str.Format("[Revision Limit NG] X : %.4f Y : %.4f T : %.4f", GetPrealign(algorithm).getRevisionX(),
					GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
				pFormMain->ShowErrorMessageBlink(str);

				break;
			}

			// 20220410 Tkyuha 필름 부착된 패널 재투입 방지를 위한 검사 진행 
			// => 켈리퍼에 원으로 위치 지정 하고 왼쪽 마크 Fixture 등록 해서 사용 할것
			if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFilmReAttachCheckEnable())
			{
				int real_cam = camBuf.at(0);
				int _thresh = vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFilmReAttachCheckThresh();
				int W = m_stCamInfo[real_cam].w;
				int H = m_stCamInfo[real_cam].h;
				double _posX = GetMatching(algorithm).getFindInfo(0, 0).GetXPos();
				double _posY = GetMatching(algorithm).getFindInfo(0, 0).GetYPos();

				double fixtureX = 0, fixtureY = 0;

				BOOL bFixtureUse = vt_job_info[algorithm].model_info.getAlignInfo().getUseFixtureMark();
				if (bFixtureUse)
				{
					fixtureX = _posX - GetMatching(algorithm).getFixtureX(real_cam, 0);
					fixtureY = _posY - GetMatching(algorithm).getFixtureY(real_cam, 0);

					// 2022-05-10 KBJ
					m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].setFixtureX(fixtureX);
					m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].setFixtureY(fixtureY);
					m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].calcPointsByFixture();
				}

				if (m_pDlgCaliper->m_Caliper[real_cam][0][0].getCircleCaliper())
				{
					_st32fPoint spt = m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].getStartPt();
					_st32fPoint ept = m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].getEndPt();
					cv::Rect _inspRoi = cv::Rect(MIN(spt.x, ept.x), MIN(spt.y, ept.y), int(fabs(ept.x - spt.x)), int(fabs(ept.y - spt.y)));

					// 2022-05-10 KBJ
					//_inspRoi.x = MAX(0,_inspRoi.x + fixtureX);
					//_inspRoi.y = MAX(0,_inspRoi.y + fixtureY);
					_inspRoi.x = MAX(0, _inspRoi.x);
					_inspRoi.y = MAX(0, _inspRoi.y);

					cv::Mat img(H, W, CV_8UC1, getProcBuffer(real_cam, 0));
					double _mean = (cv::mean(img(_inspRoi))).val[0];
					img.release();

					if (_thresh < _mean)
					{
						strTemp.Format("[Film Finded !] B: %.3f, Spec: %d Gray ", _mean, _thresh);
						pFormMain->ShowErrorMessageBlink(strTemp);

						AcquireSRWLockExclusive(&g_srwlock);
						m_nSeqProcess[algorithm] = 0;
						ReleaseSRWLockExclusive(&g_srwlock);
						nRet = 2;
						break;
					}
					else strTemp.Format("[%s] Bright : %.3f, Spec: %d Gray", vt_job_info[algorithm].get_job_name(), _mean, _thresh);

					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
				}
			}
			if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFilmUVCheckEnable())
			{
				int real_cam = vt_job_info[algorithm].camera_index[0];
				m_pPattern[real_cam].pDlg = this;
				m_pPattern[real_cam].nPos = 0;
				m_pPattern[real_cam].nJob = algorithm;

				AfxBeginThread(Thread_Ink_UVInspection, &m_pPattern[real_cam]);
			}

			// L_Check 검사 위치 변동 20.02.20
			///////// L Check 검사

#ifndef JOB_INFO
			if (getModel().getAlignInfo().getEnableLCheck(camBuf.at(0)))
#else
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableLCheck())
#endif
			{
				// kbj 2022-01-06 save lcheck NG
				m_bLcheckNG[algorithm] = calc_lcheck_1cam_1shot(algorithm);	// yeol 20210602

				if (m_bLcheckNG[algorithm] == TRUE)
				{
					// KBJ 2022-07-06 Align Revision Limit NG Error Message 추가
					CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
					strTemp.Format("[L-Check Error !] \n L: %.3f, Spec: %.3f ~ %.3f", m_dbLCheck[algorithm][0], m_dbLCheckSpec[algorithm][0] - vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor(), m_dbLCheckSpec[algorithm][0] + vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor());
					pFormMain->ShowErrorMessageBlink(strTemp);

					m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
					nRet = 2;
					break;
				}

				//double camDist = getModel().getAlignInfo().getLCheckScale(camBuf.at(0));

				//double posX1 = GetPrealign(algorithm).getPosX(0);
				//double posY1 = GetPrealign(algorithm).getPosY(0);
				//double posX2 = GetPrealign(algorithm).getPosX(1);
				//double posY2 = GetPrealign(algorithm).getPosY(1);

				//int nCam = ncamera;
				//double world[2][2] = { 0, };
				//int W = m_pViewDisplayInfo[nCam].getViewImageWidth();
				//int H = m_pViewDisplayInfo[nCam].getViewImageHeight();

				//GetMachine().PixelToWorld(nCam, 0, 0, &world[0][0], &world[0][1]);
				//GetMachine().PixelToWorld(nCam, W, H, &world[1][0], &world[1][1]);

				//// Robot 좌표계의 방향에 따라 거리 값을 반영.
				//if (getModel().getAlignInfo().getAlignmentTargetDir(ncamera) == 0)		// Horizontal
				//{
				//	if (world[1][0] > world[0][0])	posX2 += camDist;
				//	else							posX2 -= camDist;
				//}
				//else															// Vertical
				//{
				//	if (world[1][1] > world[0][1])	posY2 += camDist;
				//	else							posY2 -= camDist;
				//}

				//double dx = posX1 - posX2;
				//double dy = posY1 - posY2;
				//double diagonal = sqrt(dx * dx + dy * dy);
				//double limit = getModel().getAlignInfo().getLCheckLimit(nCam);
				//double pitch = getModel().getAlignInfo().getFiducialMarkPitchX(algorithm);

				//str.Format("L : %.3f", diagonal);
				//::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				//ncamera = camBuf.at(0);
				//writeLengthData(m_pViewDisplayInfo[ncamera].getPanelID(), diagonal, 2, algorithm);

				//if (fabs(pitch - diagonal) > limit)
				//{
				//	nRet = 2;
				//	m_nSeqProcess[algorithm] = 0;
				//	m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
				//	str.Format("L Check Error!! \r\nLength : %.3f, Pitch : %.3f, Limit : %.3f", diagonal, pitch, limit);
				//	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				//	m_dbLcheckLength[algorithm] = diagonal;
				//	m_bLcheckNG[algorithm] = TRUE;
				//	break;
				//}
			}

			// 보정량 전송
			double xMove = 0, yMove = 0;
			GetPrealign(algorithm).calcRotateOffset(GetPrealign(algorithm).getRevisionOffset(2), xMove, yMove);
			//sendRevisionOffsetData(xMove, yMove, GetPrealign(algorithm).getRevisionOffset(2));

			// kbj 2021-12-25 1cam1shot prcoess 시뮬레이션이면 보정량 보내지 않도록 추가.
			if (m_bSimulationStart != TRUE)
			{
				sendRevisionOffsetData(xMove, yMove, GetPrealign(algorithm).getRevisionOffset(2));

				sendRevisionData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);

				sendMatchingRateData(algorithm);
			}
			m_dbRevisionData[algorithm][AXIS_X] = GetPrealign(algorithm).getRevisionX();
			m_dbRevisionData[algorithm][AXIS_Y] = GetPrealign(algorithm).getRevisionY();
			m_dbRevisionData[algorithm][AXIS_T] = GetPrealign(algorithm).getRevisionT();

			//str.Format("X : %.4f Y : %.4f T : %.4f", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);
			str.Format("[%s] X : %.4f Y : %.4f T : %.4f", vt_job_info[algorithm].get_job_name(), m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);  // dh.jung 2021-07-21  change
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			//시간 전달

			CString strTime;
			SYSTEMTIME time;
			GetLocalTime(&time);

			/*if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else									strTime.Format("%s", m_strResultTime[algorithm]);*/

			if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else												strTime.Format("%s:%s:%s", m_strResultTime[algorithm].Left(2), m_strResultTime[algorithm].Mid(3, 2), m_strResultTime[algorithm].Right(2));

			// HSJ 2022-02-14 thread_process로 위치변경
			//Align 결과값 띄우기
			//::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)algorithm);
			//::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(bResult, algorithm));
			//::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(algorithm));*/
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

#pragma region 필름 & 패턴 각도 비교
			int real_cam = vt_job_info[algorithm].camera_index[nCam];
			if (Film_Align_Compare_Angle(getProcBuffer(real_cam, 0), algorithm, nCam) != TRUE)
			{
				if (vt_job_info[algorithm].model_info.getInspSpecParaInfo().getFilmAngleInspectionUse())
				{
					m_nErrorType[algorithm] = MAX_ERR_TYPE;
					pFormMain->HideErrorMessageBlink();
					str.Format("[%s] Film Pattern Theta Compare NG", vt_job_info[algorithm].job_name.c_str());
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					pFormMain->ShowErrorMessageBlink(str);
					nRet = 2;
					break;
				}
			}
#pragma endregion

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);

			//KJH 2022-05-11 Film Align Grab bit Reset추가
			g_CommPLC.SetBit(m_nAlignOkWrite[algorithm] + 2, FALSE);

			nRet = 1;
		}
	}
	break;
	case 400:
		if (m_nManualInputMarkResult[algorithm] == 1)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
			//m_pManualInputMark[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			m_pManualInputMark1Cam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			goto jumpLabel2;
		}
		else if (m_nManualInputMarkResult[algorithm] == 2)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			return 2;
		}
		break;
		//2021-12-27 1cam 1shot 시뮬레이션 추가.
	case 1000:
		//KJH 2022-03-16 Act,Seq Time Display 추가
		m_clockStartTime[algorithm] = clock();

		BOOL bFindPatternEnd = simulration_1cam_1shot_film_align(algorithm);
		if (bFindPatternEnd == TRUE) m_nSeqProcess[algorithm] = 300;
		else
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;
		}
		break;
	}
	return nRet;
}
BOOL CLET_AlignClientDlg::simulration_1cam_1shot_film_align(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	// 알고리즘 시작.

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		m_pPattern[real_cam].pDlg = this;
		m_pPattern[real_cam].nPos = 0;
		m_pPattern[real_cam].nCam = nCam;
		m_pPattern[real_cam].nSearchCount = 2;  //2point search
		m_pPattern[real_cam].nJob = nJob;

		m_bFindPattern[real_cam] = FALSE;
		m_bFindPatternEnd[real_cam] = FALSE;

		AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);

		Delay(50);
	}

	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	int MS_TIMEOUT = 10000;

	BOOL all_insp_end = TRUE;
	while (nEtick - nStick <= MS_TIMEOUT) {
		Sleep(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_insp_end = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];

			if (m_bFindPatternEnd[real_cam] != TRUE)
				all_insp_end = FALSE;
		}

		if (all_insp_end == TRUE) break;

		if (nEtick - nStick == MS_TIMEOUT)
		{
			str.Format("TimeOut(ms : %d) ", MS_TIMEOUT);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	if (all_insp_end != TRUE) return FALSE;


	BOOL bAllFind = TRUE;

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		int real_cam = vt_job_info[nJob].camera_index[nCam];

		if (m_bFindPattern[real_cam] != TRUE)
			bAllFind = FALSE;
	}

	return bAllFind;
}

#pragma region 필름 검사부 한카메라 사용 해서 두개 필름 얼라인 방법 Tkyuha 20211015 
int CLET_AlignClientDlg::processAlign1Cam2PosPreAlign(int algorithm)  //1CAM 2Align   Mark 4개 Search
{
	//HTK 2022-06-29 Convyer Align 분기작업
	if (vt_job_info[algorithm].job_name=="CONV_ALIGN")
	{
		return processAlign1Cam4PosRobotAlign_Conveyer(algorithm);
	}

	CString str;
	int nRet = 0, ncamera = 0;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;
#endif

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[algorithm];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {	// processAlign1Cam2PosPreAlign()
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

			LightControllerTurnOnOff(algorithm, nCam, 0);

			////KJH 2021-05-29 Grab전 조명 ON
			//for (int n = 0; n < vt_job_info[algorithm].light_info.size(); n++)
			//{
			//	for (int nLight = 0; nLight < vt_job_info[algorithm].light_info[n].num_of_using_light; nLight++)
			//	{
			//		int ctrl = vt_job_info[algorithm].light_info[n].controller_id[nLight] - 1;
			//		int ch = vt_job_info[algorithm].light_info[n].channel_id[nLight];
			//		int value = vt_job_info[algorithm].model_info.getLightInfo().getLightBright(nCam, nLight, 0);
			//		if (m_stLightCtrlInfo.nType[0] == LTYPE_LLIGHT_LPC_COT_232)		SetLightBright(ctrl, ch, value == 0 ? 0 : value * 10);   // dh.jung 2021-07-12
			//		else															SetLightBright(ctrl, ch, value);
			//		Delay(50);
			//	}
			//}

			str.Format("[%s] Cam %d - Light On", vt_job_info[algorithm].job_name.c_str(), nCam + 1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[algorithm].job_name.c_str(), ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				Camera_Grab(ncamera);
				//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, ncamera);// Tkyuha 20211201 Thread로 변경
			}
		}

		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 0;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 4;  //4point search 2개의 대상물 찾기 ,왼쪽 2개, 오른쪽2개
			m_pPattern[ncamera].nJob = algorithm;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
		}
	}
	break;
	case 300:
	{
		m_nErrorType[algorithm] = 0;

		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPattern[ncamera] != TRUE)
				bFind = FALSE;
		}

		CPaneAuto* pPane = (CPaneAuto*)m_pPane[PANE_AUTO];
		pPane->m_nObject = 0;
		int _2ObjectAlign = 0;
		m_bFind_object[0] = TRUE;
		m_bFind_object[1] = TRUE;

		if (bFind != TRUE)
		{
			// 1 object
			if (GetMatching(algorithm).getFindInfo(0, 0).GetFound() != FIND_OK ||
				GetMatching(algorithm).getFindInfo(0, 1).GetFound() != FIND_OK)
			{
				m_bFind_object[0] = FALSE;

				// hsj 2022-02-14 확인중
				m_dbRevisionData_obejct[algorithm][AXIS_X][0] = 0;
				m_dbRevisionData_obejct[algorithm][AXIS_Y][0] = 0;
				m_dbRevisionData_obejct[algorithm][AXIS_T][0] = 0;

				m_dReeltoStageDistance[0] = 0;
				
			}
			else m_bFind_object[0] = TRUE;

			// 2 object
			if (GetMatching(algorithm).getFindInfo(0, 2).GetFound() != FIND_OK ||
				GetMatching(algorithm).getFindInfo(0, 3).GetFound() != FIND_OK)
			{
				m_bFind_object[1] = FALSE;

				// hsj 2022-02-14 확인중
				m_dbRevisionData_obejct[algorithm][AXIS_X][1] = 0;
				m_dbRevisionData_obejct[algorithm][AXIS_Y][1] = 0;
				m_dbRevisionData_obejct[algorithm][AXIS_T][1] = 0;

				m_dReeltoStageDistance[1] = 0;
			}
			else m_bFind_object[1] = TRUE;

			if (m_bFind_object[0] == TRUE) { _2ObjectAlign = 0; bFind = TRUE; pPane->m_nObject = 0; }
			if (m_bFind_object[1] == TRUE) { _2ObjectAlign = 2; bFind = TRUE; pPane->m_nObject = 1; }

			if (vt_job_info[algorithm].model_info.getAlignInfo().getUseRevisionReset())
			{
				m_dbRevisionData_obejct[algorithm][AXIS_X][0] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData_obejct[algorithm][AXIS_Y][0] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData_obejct[algorithm][AXIS_T][0] = GetPrealign(algorithm).getRevisionT();
				m_dbRevisionData_obejct[algorithm][AXIS_X][1] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData_obejct[algorithm][AXIS_Y][1] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData_obejct[algorithm][AXIS_T][1] = GetPrealign(algorithm).getRevisionT();
				if (m_bSimulationStart != TRUE)
				{
					if (m_bFind_object[0] != TRUE) sendRevisionData(0, 0, 0, algorithm);
					if (m_bFind_object[1] != TRUE) sendRevisionSecondData(0, 0, 0, algorithm);
				}
			}
		}
		
		// HSJ 2022-02-14
		//if(m_bFind_object[0]!=TRUE|| m_bFind_object[1]!=TRUE)
		if (bFind != TRUE)
		{
			nRet = 2;
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);

			str.Format("Mark Search Error - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
			write_NGresult_SummaryFile(vt_job_info[algorithm].main_object_id.c_str(), str, FALSE, algorithm);

			break;
		}
		else
		{
			// 2022-01-20 Reel Align Offset revision From PLC
			// lData = [ X1, X1, Y1, Y1, T1, T1 ... X2, X2, Y2, Y2, T2, T2]
			long lData[40] = { 0, };
			g_CommPLC.GetWord(vt_job_info[algorithm].plc_addr_info.read_word_start, 40, lData);

			double X1, Y1, T1, X2, Y2, T2 = 0.0;
			X1 = MAKELONG(lData[0], lData[1]) / MOTOR_SCALE;
			Y1 = MAKELONG(lData[2], lData[3]) / MOTOR_SCALE;
			T1 = MAKELONG(lData[4], lData[5]) / MOTOR_SCALE;
			X2 = MAKELONG(lData[20], lData[21]) / MOTOR_SCALE;
			Y2 = MAKELONG(lData[22], lData[23]) / MOTOR_SCALE;
			T2 = MAKELONG(lData[24], lData[25]) / MOTOR_SCALE;

			str.Format("[%s] RevisionOffset Object1(X:%.3f Y:%.3f T:%.3f)", vt_job_info[algorithm].job_name.c_str(), X1, Y1, T1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			str.Format("[%s] RevisionOffset Object2(X:%.3f Y:%.3f T:%.3f)", vt_job_info[algorithm].job_name.c_str(), X2, Y2, T2);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

jumpLabel2:
			double posX = 0.0, refX, refworldX;
			double posY = 0.0, refY, refworldY;
			double worldX, worldY;
			CString strTemp;

			// 이미지 좌표계 → 실 좌표계
			ncamera = camBuf.at(0);
			int nCam = 0;
			int nSubPos = _2ObjectAlign / 2;

			for (int nPos = 0; nPos < 2; nPos++)
			{
				refX = GetMatching(algorithm).getRefX(nCam, nPos + _2ObjectAlign);
				refY = GetMatching(algorithm).getRefY(nCam, nPos + _2ObjectAlign);
				posX = GetMatching(algorithm).getFindInfo(nCam, nPos + _2ObjectAlign).GetXPos();
				posY = GetMatching(algorithm).getFindInfo(nCam, nPos + _2ObjectAlign).GetYPos();

				str.Format("[Cam %d] Pos %d - x: %.1f y: %.1f - x: %.1f y: %.1f", ncamera + 1, nPos + _2ObjectAlign, posX, posY, refX, refY);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// 일단은 같은 좌표계에서 불러 오도록 // 개별로 확인 해야 하는지 체크 Tkyuha 20211018 ?????
				GetMachine(algorithm).PixelToWorld(nCam, nSubPos, posX, posY, &worldX, &worldY);
				GetMachine(algorithm).PixelToWorld(nCam, nSubPos, refX, refY, &refworldX, &refworldY);
				worldX -= refworldX;
				worldY -= refworldY;

				GetPrealign(algorithm).setPosX(nPos, worldX);
				GetPrealign(algorithm).setPosY(nPos, worldY);
			}

			double _a, _b,_distance = 0,_cx,_cy;
			double _px = GetMatching(algorithm).getFindInfo(nCam, _2ObjectAlign).GetXPos();
			double _py = GetMatching(algorithm).getFindInfo(nCam, _2ObjectAlign).GetYPos();

			_cx = (_px+ posX)/2., _cy = (_py + posY) / 2.;

			GetLineCoef(_px, _py, posX, posY,_a, _b);
			find_pf_film_stagedge(getProcBuffer(ncamera, 0), algorithm, 0,_cx,_cy,_a,_b, _distance); // 결과 표시 해줄것  //220311 
			
			//KJH 2022-06-28 Film Feeding 검사를 이용한 Auto Feeding Time Offset 계산
			int Target_Distance = 2;		//KJH 2022-06-28 나중에 파라미터 작업 진행
			sendFilmFeedingOffsetData(_distance, Target_Distance, algorithm, nSubPos);// Auto APC기능 활성화 Reel 검사시 사용 Tkyuha 2022.06.17
			
			if (_2ObjectAlign == 0)
			{
				m_dReeltoStageDistance[0] = _distance;
			}
			else
			{
				m_dReeltoStageDistance[1] = _distance;
			}


			// 보정량 계산
			int nCamL = 0;
			int nCamR = 1;

			GetPrealign(algorithm).setRotateX(nCamL, GetMachine(algorithm).getRotateX(nCam, nSubPos));
			GetPrealign(algorithm).setRotateY(nCamL, GetMachine(algorithm).getRotateY(nCam, nSubPos));
			GetPrealign(algorithm).setRotateX(nCamR, GetMachine(algorithm).getRotateX(nCam, nSubPos));
			GetPrealign(algorithm).setRotateY(nCamR, GetMachine(algorithm).getRotateY(nCam, nSubPos));

			// 2022-01-20 Reel Align Offset revision From PLC
			// lData = [ X1, X1, Y1, Y1, T1, T1, X2, X2, Y2, Y2, T2, T2]
			/*
			// mm로 Offset 적용
			GetPrealign(algorithm).setRevisionOffset(0, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(0));
			GetPrealign(algorithm).setRevisionOffset(1, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(1));
			GetPrealign(algorithm).setRevisionOffset(2, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(2));
			GetPrealign(algorithm).pDlg = this;
			*/
			if (_2ObjectAlign == 0) // 첫번째 얼라인 
			{
				GetPrealign(algorithm).setRevisionOffset(AXIS_X, X1);
				GetPrealign(algorithm).setRevisionOffset(AXIS_Y, Y1);
				GetPrealign(algorithm).setRevisionOffset(AXIS_T, T1);
			}
			else
			{
				GetPrealign(algorithm).setRevisionOffset(AXIS_X, X2);
				GetPrealign(algorithm).setRevisionOffset(AXIS_Y, Y2);
				GetPrealign(algorithm).setRevisionOffset(AXIS_T, T2);
			}

			// 방향 결정
			GetPrealign(algorithm).setReverseAxisX(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX());
			GetPrealign(algorithm).setReverseAxisY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY());
			GetPrealign(algorithm).setReverseAxisT(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT());
			GetPrealign(algorithm).setReverseAxisXY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseXY());
			int target_dir = vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir();

			switch (vt_job_info[algorithm].model_info.getAlignInfo().getAngleCalcMethod()) {
			case 1:			// Glass Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getGlassWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getGlassHeight());
			}
			break;
			case 2:			// Frame Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getFrameWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getFrameHeight());
			}
			break;
			case 3:			// Rotate Center
			{
				double pitch_x = fabs(GetMachine(algorithm).getRotateX(nCamL, 0) - GetMachine(algorithm).getRotateX(nCamR, 0));
				double pitch_y = fabs(GetMachine(algorithm).getRotateY(nCamL, 0) - GetMachine(algorithm).getRotateY(nCamR, 0));

				GetPrealign(algorithm).setPatternPitchX(pitch_x);
				GetPrealign(algorithm).setPatternPitchY(pitch_y);
			}
			break;
			default:		//	Align Key
			{
				if (vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir() == CAM_HORI)
					GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
				else
					GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchY());		// dh.jung 2021-07-21  change

			}
			break;
			}

			BOOL bUse = vt_job_info[algorithm].model_info.getMachineInfo().getUseImageTheta();
			GetPrealign(algorithm).set_use_image_theta(bUse);

			if (bUse)
			{
				double posX[2], posY[2];
				double theta = 0.0;
				posX[0] = GetMatching(algorithm).getFindInfo(0, 0).GetXPos();
				posY[0] = GetMatching(algorithm).getFindInfo(0, 0).GetYPos();
				posX[1] = GetMatching(algorithm).getFindInfo(0, 1).GetXPos();
				posY[1] = GetMatching(algorithm).getFindInfo(0, 1).GetYPos();

				double dx = posX[1] - posX[0];
				double dy = posY[1] - posY[0];

				if (target_dir == 0)	theta = atan(dy / dx);
				else					theta = atan(dx / dy);
				GetPrealign(algorithm).set_image_theta(theta);
			}

			int type = vt_job_info[algorithm].model_info.getMachineInfo().getAlignmentType();

			GetPrealign(algorithm).setAlignmentType(type);
			if (GetPrealign(algorithm).calcRevision(0, 1, target_dir) != 0)
			{
				str = "Calc Revision Failed";
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				nRet = 2;
				m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

				m_dbRevisionData[algorithm][AXIS_X] = 0;
				m_dbRevisionData[algorithm][AXIS_Y] = 0;
				m_dbRevisionData[algorithm][AXIS_T] = 0;
				break;
			}

			// 보정량 전송
			if (fabs(GetPrealign(algorithm).getRevisionX()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_X) ||
				fabs(GetPrealign(algorithm).getRevisionY()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_Y) ||
				fabs(GetPrealign(algorithm).getRevisionT()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_T))
			{
				m_nErrorType[algorithm] = ERR_TYPE_REVISION_LIMIT;

				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				str.Format("[%s] X : %.4f Y : %.4f T : %.4f NG Limit", vt_job_info[algorithm].job_name.c_str(), GetPrealign(algorithm).getRevisionX(),
					GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// KBJ 2022-07-06 Align L Check NG Error Message 추가
				CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
				str.Format("[ %d Revision Limit NG] X : %.4f Y : %.4f T : %.4f ", _2ObjectAlign / 2 +1,GetPrealign(algorithm).getRevisionX(),
					GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
				pFormMain->ShowErrorMessageBlink(str);

				break;
			}

			// 보정량 전송  // 왜 있는지 모르겠네 ?????? Tkyuha
	/*		double xMove = 0, yMove = 0;
			GetPrealign(algorithm).calcRotateOffset(GetPrealign(algorithm).getRevisionOffset(2), xMove, yMove);
			sendRevisionOffsetData(xMove, yMove, GetPrealign(algorithm).getRevisionOffset(2));*/

			// prcoess 시뮬레이션이면 보정량 보내지 않도록 추가.
			if (m_bSimulationStart != TRUE)
			{
				if (_2ObjectAlign == 0) // 첫번째 얼라인 데이타 전송
					sendRevisionData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);
				else  //// 두번째 얼라인 데이타 전송
					sendRevisionSecondData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);
			}
			m_dbRevisionData[algorithm][AXIS_X] = GetPrealign(algorithm).getRevisionX();
			m_dbRevisionData[algorithm][AXIS_Y] = GetPrealign(algorithm).getRevisionY();
			m_dbRevisionData[algorithm][AXIS_T] = GetPrealign(algorithm).getRevisionT();

			// kbj 2022-01-09 add revisiondata from object
			if (_2ObjectAlign == 0) // 첫번째 얼라인 데이타 전송
			{
				m_dbRevisionData_obejct[algorithm][AXIS_X][0] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData_obejct[algorithm][AXIS_Y][0] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData_obejct[algorithm][AXIS_T][0] = GetPrealign(algorithm).getRevisionT();
			}
			else
			{
				m_dbRevisionData_obejct[algorithm][AXIS_X][1] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData_obejct[algorithm][AXIS_Y][1] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData_obejct[algorithm][AXIS_T][1] = GetPrealign(algorithm).getRevisionT();
			}
			//str.Format("X : %.4f Y : %.4f T : %.4f", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);
			str.Format("RevisionData (X : %.4f Y : %.4f T : %.4f)", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);  // dh.jung 2021-07-21  change

			//시간 전달

			CString strTime;
			SYSTEMTIME time;
			GetLocalTime(&time);

			/*if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else												strTime.Format("%s", m_strResultTime[algorithm]);*/

			if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else												strTime.Format("%s:%s:%s", m_strResultTime[algorithm].Left(2), m_strResultTime[algorithm].Mid(3, 2), m_strResultTime[algorithm].Right(2));

			BOOL bResult = FALSE;
			if (nRet == 2) bResult = FALSE;
			else bResult = TRUE;

			// HSJ 2022-02-14 thread_process로 위치변경
			//Align 결과값 띄우기
			/*::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)algorithm);
			if(_2ObjectAlign == 0)	::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(m_bJudge_object[0], algorithm));
			if(_2ObjectAlign == 2)	::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(m_bJudge_object[1], algorithm));
			::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(algorithm));*/
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			
			if (_2ObjectAlign == 0)
			{
				_2ObjectAlign+=2;
				
				if (m_bFind_object[1] == TRUE)	goto jumpLabel2; // 두번째 대상물 계산
			}

			// L-Check
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableLCheck())
			{
				// kbj 2022-01-06 save lcheck NG
				m_bLcheckNG[algorithm] = calc_lcheck_1cam_1shot_2object(algorithm);	// yeol 20210602

				if (m_bLcheckNG[algorithm] == TRUE)
				{
					// KBJ 2022-07-06 Align L Check NG Error Message 추가
					CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
					if (fabs(m_dbLCheckSpec[algorithm][0] - m_dbLCheck[algorithm][0]) > vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor())
						strTemp.Format("[L-Check 1 Error !] \n L: %.3f, Spec: %.3f ~ %.3f", m_dbLCheck[algorithm][0], m_dbLCheckSpec[algorithm][0] - vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor(), m_dbLCheckSpec[algorithm][0] + vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor());
					else
						strTemp.Format("[L-Check 2 Error !] \n L: %.3f, Spec: %.3f ~ %.3f", m_dbLCheck[algorithm][1], m_dbLCheckSpec[algorithm][1] - vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor(), m_dbLCheckSpec[algorithm][1] + vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor());
					pFormMain->ShowErrorMessageBlink(strTemp);

					m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
					nRet = 2;
					break;
				}
			}

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 1;
		}
	}
	break;
	case 400:
		if (m_nManualInputMarkResult[algorithm] == 1)
		{
			// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
			//m_pManualInputMarkCam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			m_pManualInputMark1Cam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			goto jumpLabel2;
		}
		else if (m_nManualInputMarkResult[algorithm] == 2)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			return 2;
		}
		break;
//2021-12-27 1cam 2Pos Pre Align 시뮬레이션 추가.
	case 1000:
		BOOL bFindPatternEnd = simulration_1cam_2pos_align(algorithm);
		if (bFindPatternEnd == TRUE) m_nSeqProcess[algorithm] = 300;
		else
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;
		}
		break;
	}
	return nRet;
}

int CLET_AlignClientDlg::processAlign1Cam4PosRobotAlign(int algorithm)  //1CAM 2Align   Mark 4개 Search
{
	//HTK 2022-06-29 Convyer Align 분기작업
	if (vt_job_info[algorithm].job_name == "CONV_ALIGN")
	{
		return processAlign1Cam4PosRobotAlign_Conveyer(algorithm);
	}

	CString str;
	int nRet = 0, ncamera = 0;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;
#endif

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[algorithm];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {	// processAlign1Cam2PosPreAlign()
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
#ifdef _DAHUHA
				AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
				AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
				ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
				ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

			LightControllerTurnOnOff(algorithm, nCam, 0);

			str.Format("[%s] Cam %d - Light On", vt_job_info[algorithm].job_name.c_str(), nCam + 1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#elif _SAPERA
			if (m_pSaperaCam[ncamera].IsOpend())
#else
			if (m_pBaslerCam[ncamera])
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[algorithm].job_name.c_str(), ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				Camera_Grab(ncamera);
				//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, ncamera);// Tkyuha 20211201 Thread로 변경
			}
		}

		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 0;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 4;  //4point search 2개의 대상물 찾기 ,왼쪽 2개, 오른쪽2개
			m_pPattern[ncamera].nJob = algorithm;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
		}
	}
	break;
	case 300:
	{
		m_nErrorType[algorithm] = 0;

		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPattern[ncamera] != TRUE)
				bFind = FALSE;
		}

		CPaneAuto* pPane = (CPaneAuto*)m_pPane[PANE_AUTO];
		pPane->m_nObject = 0;
		int _2ObjectAlign = 0;
		m_bFind_object[0] = TRUE;
		m_bFind_object[1] = TRUE;

		if (bFind != TRUE)
		{
			// 1 object
			if (GetMatching(algorithm).getFindInfo(0, 0).GetFound() != FIND_OK ||
				GetMatching(algorithm).getFindInfo(0, 1).GetFound() != FIND_OK)
			{
				m_bFind_object[0] = FALSE;

				// hsj 2022-02-14 확인중
				m_dbRevisionData_obejct[algorithm][AXIS_X][0] = 0;
				m_dbRevisionData_obejct[algorithm][AXIS_Y][0] = 0;
				m_dbRevisionData_obejct[algorithm][AXIS_T][0] = 0;

				m_dReeltoStageDistance[0] = 0;

			}
			else m_bFind_object[0] = TRUE;

			// 2 object
			if (GetMatching(algorithm).getFindInfo(0, 2).GetFound() != FIND_OK ||
				GetMatching(algorithm).getFindInfo(0, 3).GetFound() != FIND_OK)
			{
				m_bFind_object[1] = FALSE;

				// hsj 2022-02-14 확인중
				m_dbRevisionData_obejct[algorithm][AXIS_X][1] = 0;
				m_dbRevisionData_obejct[algorithm][AXIS_Y][1] = 0;
				m_dbRevisionData_obejct[algorithm][AXIS_T][1] = 0;

				m_dReeltoStageDistance[1] = 0;
			}
			else m_bFind_object[1] = TRUE;

			if (m_bFind_object[0] == TRUE) { _2ObjectAlign = 0; bFind = TRUE; pPane->m_nObject = 0; }
			if (m_bFind_object[1] == TRUE) { _2ObjectAlign = 2; bFind = TRUE; pPane->m_nObject = 1; }

			if (vt_job_info[algorithm].model_info.getAlignInfo().getUseRevisionReset())
			{
				m_dbRevisionData_obejct[algorithm][AXIS_X][0] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData_obejct[algorithm][AXIS_Y][0] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData_obejct[algorithm][AXIS_T][0] = GetPrealign(algorithm).getRevisionT();
				m_dbRevisionData_obejct[algorithm][AXIS_X][1] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData_obejct[algorithm][AXIS_Y][1] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData_obejct[algorithm][AXIS_T][1] = GetPrealign(algorithm).getRevisionT();
				if (m_bSimulationStart != TRUE)
				{
					if (m_bFind_object[0] != TRUE) sendRevisionData(0, 0, 0, algorithm);
					if (m_bFind_object[1] != TRUE) sendRevisionSecondData(0, 0, 0, algorithm);
				}
			}
		}

		// HSJ 2022-02-14
		//if(m_bFind_object[0]!=TRUE|| m_bFind_object[1]!=TRUE)
		if (bFind != TRUE)
		{
			nRet = 2;
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);

			str.Format("Mark Search Error - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
			write_NGresult_SummaryFile(vt_job_info[algorithm].main_object_id.c_str(), str, FALSE, algorithm);

			break;
		}
		else
		{
			// 2022-01-20 Reel Align Offset revision From PLC
			// lData = [ X1, X1, Y1, Y1, T1, T1 ... X2, X2, Y2, Y2, T2, T2]
			long lData[40] = { 0, };
			g_CommPLC.GetWord(vt_job_info[algorithm].plc_addr_info.read_word_start, 40, lData);

			double X1, Y1, T1, X2, Y2, T2 = 0.0;
			X1 = MAKELONG(lData[0], lData[1]) / MOTOR_SCALE;
			Y1 = MAKELONG(lData[2], lData[3]) / MOTOR_SCALE;
			T1 = MAKELONG(lData[4], lData[5]) / MOTOR_SCALE;
			X2 = MAKELONG(lData[20], lData[21]) / MOTOR_SCALE;
			Y2 = MAKELONG(lData[22], lData[23]) / MOTOR_SCALE;
			T2 = MAKELONG(lData[24], lData[25]) / MOTOR_SCALE;

			str.Format("[%s] RevisionOffset Object1(X:%.3f Y:%.3f T:%.3f)", vt_job_info[algorithm].job_name.c_str(), X1, Y1, T1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			str.Format("[%s] RevisionOffset Object2(X:%.3f Y:%.3f T:%.3f)", vt_job_info[algorithm].job_name.c_str(), X2, Y2, T2);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		jumpLabel2:
			double posX = 0.0, refX, refworldX;
			double posY = 0.0, refY, refworldY;
			double worldX, worldY;
			CString strTemp;

			// 이미지 좌표계 → 실 좌표계
			ncamera = camBuf.at(0);
			int nCam = 0;
			int nSubPos = _2ObjectAlign / 2;

			for (int nPos = 0; nPos < 2; nPos++)
			{
				refX = GetMatching(algorithm).getRefX(nCam, nPos + _2ObjectAlign);
				refY = GetMatching(algorithm).getRefY(nCam, nPos + _2ObjectAlign);
				posX = GetMatching(algorithm).getFindInfo(nCam, nPos + _2ObjectAlign).GetXPos();
				posY = GetMatching(algorithm).getFindInfo(nCam, nPos + _2ObjectAlign).GetYPos();

				str.Format("[Cam %d] Pos %d - x: %.1f y: %.1f - x: %.1f y: %.1f", ncamera + 1, nPos + _2ObjectAlign, posX, posY, refX, refY);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// 일단은 같은 좌표계에서 불러 오도록 // 개별로 확인 해야 하는지 체크 Tkyuha 20211018 ?????
				GetMachine(algorithm).PixelToWorld(nCam, nSubPos, posX, posY, &worldX, &worldY);
				GetMachine(algorithm).PixelToWorld(nCam, nSubPos, refX, refY, &refworldX, &refworldY);
				worldX -= refworldX;
				worldY -= refworldY;

				GetPrealign(algorithm).setPosX(nPos, worldX);
				GetPrealign(algorithm).setPosY(nPos, worldY);

				//KJH 2022-08-04 conveyer 알고리즘 반영
				GetPrealign(algorithm).setRotateX(nPos, -refworldX + GetMachine(algorithm).getRotateX(nCam, nSubPos));
				GetPrealign(algorithm).setRotateY(nPos, -refworldY + GetMachine(algorithm).getRotateY(nCam, nSubPos));
			}

			double _a, _b, _distance = 0, _cx, _cy;
			double _px = GetMatching(algorithm).getFindInfo(nCam, _2ObjectAlign).GetXPos();
			double _py = GetMatching(algorithm).getFindInfo(nCam, _2ObjectAlign).GetYPos();

			_cx = (_px + posX) / 2., _cy = (_py + posY) / 2.;

			GetLineCoef(_px, _py, posX, posY, _a, _b);
			find_pf_film_stagedge(getProcBuffer(ncamera, 0), algorithm, 0, _cx, _cy, _a, _b, _distance); // 결과 표시 해줄것  //220311 

			//KJH 2022-06-28 Film Feeding 검사를 이용한 Auto Feeding Time Offset 계산
			int Target_Distance = 2;		//KJH 2022-06-28 나중에 파라미터 작업 진행
			sendFilmFeedingOffsetData(_distance, Target_Distance, algorithm, nSubPos);// Auto APC기능 활성화 Reel 검사시 사용 Tkyuha 2022.06.17

			if (_2ObjectAlign == 0)
			{
				m_dReeltoStageDistance[0] = _distance;
			}
			else
			{
				m_dReeltoStageDistance[1] = _distance;
			}


			// 보정량 계산
			int nCamL = 0;
			int nCamR = 1;

			GetPrealign(algorithm).setRotateX(nCamL, GetMachine(algorithm).getRotateX(nCam, nSubPos));
			GetPrealign(algorithm).setRotateY(nCamL, GetMachine(algorithm).getRotateY(nCam, nSubPos));
			GetPrealign(algorithm).setRotateX(nCamR, GetMachine(algorithm).getRotateX(nCam, nSubPos));
			GetPrealign(algorithm).setRotateY(nCamR, GetMachine(algorithm).getRotateY(nCam, nSubPos));

			// 2022-01-20 Reel Align Offset revision From PLC
			// lData = [ X1, X1, Y1, Y1, T1, T1, X2, X2, Y2, Y2, T2, T2]
			/*
			// mm로 Offset 적용
			GetPrealign(algorithm).setRevisionOffset(0, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(0));
			GetPrealign(algorithm).setRevisionOffset(1, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(1));
			GetPrealign(algorithm).setRevisionOffset(2, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(2));
			GetPrealign(algorithm).pDlg = this;
			*/
			if (_2ObjectAlign == 0) // 첫번째 얼라인 
			{
				GetPrealign(algorithm).setRevisionOffset(AXIS_X, X1);
				GetPrealign(algorithm).setRevisionOffset(AXIS_Y, Y1);
				GetPrealign(algorithm).setRevisionOffset(AXIS_T, T1);
			}
			else
			{
				GetPrealign(algorithm).setRevisionOffset(AXIS_X, X2);
				GetPrealign(algorithm).setRevisionOffset(AXIS_Y, Y2);
				GetPrealign(algorithm).setRevisionOffset(AXIS_T, T2);
			}

			// 방향 결정
			GetPrealign(algorithm).setReverseAxisX(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX());
			GetPrealign(algorithm).setReverseAxisY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY());
			GetPrealign(algorithm).setReverseAxisT(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT());
			GetPrealign(algorithm).setReverseAxisXY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseXY());
			int target_dir = vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir();

			switch (vt_job_info[algorithm].model_info.getAlignInfo().getAngleCalcMethod()) {
			case 1:			// Glass Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getGlassWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getGlassHeight());
			}
			break;
			case 2:			// Frame Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getFrameWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getFrameHeight());
			}
			break;
			case 3:			// Rotate Center
			{
				double pitch_x = fabs(GetMachine(algorithm).getRotateX(nCamL, 0) - GetMachine(algorithm).getRotateX(nCamR, 0));
				double pitch_y = fabs(GetMachine(algorithm).getRotateY(nCamL, 0) - GetMachine(algorithm).getRotateY(nCamR, 0));

				GetPrealign(algorithm).setPatternPitchX(pitch_x);
				GetPrealign(algorithm).setPatternPitchY(pitch_y);
			}
			break;
			default:		//	Align Key
			{
				if (vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir() == CAM_HORI)
					GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
				else
					GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchY());		// dh.jung 2021-07-21  change

			}
			break;
			}

			BOOL bUse = vt_job_info[algorithm].model_info.getMachineInfo().getUseImageTheta();
			GetPrealign(algorithm).set_use_image_theta(bUse);

			if (bUse)
			{
				double posX[2], posY[2];
				double theta = 0.0;
				posX[0] = GetMatching(algorithm).getFindInfo(0, 0).GetXPos();
				posY[0] = GetMatching(algorithm).getFindInfo(0, 0).GetYPos();
				posX[1] = GetMatching(algorithm).getFindInfo(0, 1).GetXPos();
				posY[1] = GetMatching(algorithm).getFindInfo(0, 1).GetYPos();

				double dx = posX[1] - posX[0];
				double dy = posY[1] - posY[0];

				if (target_dir == 0)	theta = atan(dy / dx);
				else					theta = atan(dx / dy);
				GetPrealign(algorithm).set_image_theta(theta);
			}

			int type = vt_job_info[algorithm].model_info.getMachineInfo().getAlignmentType();

			GetPrealign(algorithm).setAlignmentType(type);
			if (GetPrealign(algorithm).calcRevisionRobot(0, 1, target_dir) != 0)
			{
				str = "Calc Revision Failed";
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				nRet = 2;
				m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

				m_dbRevisionData[algorithm][AXIS_X] = 0;
				m_dbRevisionData[algorithm][AXIS_Y] = 0;
				m_dbRevisionData[algorithm][AXIS_T] = 0;
				break;
			}

			// 보정량 전송
			if (fabs(GetPrealign(algorithm).getRevisionX()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_X) ||
				fabs(GetPrealign(algorithm).getRevisionY()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_Y) ||
				fabs(GetPrealign(algorithm).getRevisionT()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_T))
			{
				m_nErrorType[algorithm] = ERR_TYPE_REVISION_LIMIT;

				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				str.Format("[%s] X : %.4f Y : %.4f T : %.4f NG Limit", vt_job_info[algorithm].job_name.c_str(), GetPrealign(algorithm).getRevisionX(),
					GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// KBJ 2022-07-06 Align L Check NG Error Message 추가
				CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
				str.Format("[ %d Revision Limit NG] X : %.4f Y : %.4f T : %.4f ", _2ObjectAlign / 2 + 1, GetPrealign(algorithm).getRevisionX(),
					GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
				pFormMain->ShowErrorMessageBlink(str);

				break;
			}

			// 보정량 전송  // 왜 있는지 모르겠네 ?????? Tkyuha
	/*		double xMove = 0, yMove = 0;
			GetPrealign(algorithm).calcRotateOffset(GetPrealign(algorithm).getRevisionOffset(2), xMove, yMove);
			sendRevisionOffsetData(xMove, yMove, GetPrealign(algorithm).getRevisionOffset(2));*/

			// prcoess 시뮬레이션이면 보정량 보내지 않도록 추가.
			if (m_bSimulationStart != TRUE)
			{
				if (_2ObjectAlign == 0) // 첫번째 얼라인 데이타 전송
					sendRevisionData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);
				else  //// 두번째 얼라인 데이타 전송
					sendRevisionSecondData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);
			}
			m_dbRevisionData[algorithm][AXIS_X] = GetPrealign(algorithm).getRevisionX();
			m_dbRevisionData[algorithm][AXIS_Y] = GetPrealign(algorithm).getRevisionY();
			m_dbRevisionData[algorithm][AXIS_T] = GetPrealign(algorithm).getRevisionT();

			// kbj 2022-01-09 add revisiondata from object
			if (_2ObjectAlign == 0) // 첫번째 얼라인 데이타 전송
			{
				m_dbRevisionData_obejct[algorithm][AXIS_X][0] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData_obejct[algorithm][AXIS_Y][0] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData_obejct[algorithm][AXIS_T][0] = GetPrealign(algorithm).getRevisionT();
			}
			else
			{
				m_dbRevisionData_obejct[algorithm][AXIS_X][1] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData_obejct[algorithm][AXIS_Y][1] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData_obejct[algorithm][AXIS_T][1] = GetPrealign(algorithm).getRevisionT();
			}
			//str.Format("X : %.4f Y : %.4f T : %.4f", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);
			str.Format("RevisionData (X : %.4f Y : %.4f T : %.4f)", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);  // dh.jung 2021-07-21  change

			//시간 전달

			CString strTime;
			SYSTEMTIME time;
			GetLocalTime(&time);

			/*if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else												strTime.Format("%s", m_strResultTime[algorithm]);*/

			if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else												strTime.Format("%s:%s:%s", m_strResultTime[algorithm].Left(2), m_strResultTime[algorithm].Mid(3, 2), m_strResultTime[algorithm].Right(2));

			BOOL bResult = FALSE;
			if (nRet == 2) bResult = FALSE;
			else bResult = TRUE;

			// HSJ 2022-02-14 thread_process로 위치변경
			//Align 결과값 띄우기
			/*::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)algorithm);
			if(_2ObjectAlign == 0)	::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(m_bJudge_object[0], algorithm));
			if(_2ObjectAlign == 2)	::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(m_bJudge_object[1], algorithm));
			::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(algorithm));*/
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			if (_2ObjectAlign == 0)
			{
				_2ObjectAlign += 2;

				if (m_bFind_object[1] == TRUE)	goto jumpLabel2; // 두번째 대상물 계산
			}

			// L-Check
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableLCheck())
			{
				// kbj 2022-01-06 save lcheck NG
				m_bLcheckNG[algorithm] = calc_lcheck_1cam_1shot_2object(algorithm);	// yeol 20210602

				if (m_bLcheckNG[algorithm] == TRUE)
				{
					// KBJ 2022-07-06 Align L Check NG Error Message 추가
					CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
					if (fabs(m_dbLCheckSpec[algorithm][0] - m_dbLCheck[algorithm][0]) > vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor())
						strTemp.Format("[L-Check 1 Error !] \n L: %.3f, Spec: %.3f ~ %.3f", m_dbLCheck[algorithm][0], m_dbLCheckSpec[algorithm][0] - vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor(), m_dbLCheckSpec[algorithm][0] + vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor());
					else
						strTemp.Format("[L-Check 2 Error !] \n L: %.3f, Spec: %.3f ~ %.3f", m_dbLCheck[algorithm][1], m_dbLCheckSpec[algorithm][1] - vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor(), m_dbLCheckSpec[algorithm][1] + vt_job_info[algorithm].model_info.getAlignInfo().getLCheckTor());
					pFormMain->ShowErrorMessageBlink(strTemp);

					m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
					nRet = 2;
					break;
				}
			}

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 1;
		}
	}
	break;
	case 400:
		if (m_nManualInputMarkResult[algorithm] == 1)
		{
			// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
			//m_pManualInputMarkCam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			m_pManualInputMark1Cam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			goto jumpLabel2;
		}
		else if (m_nManualInputMarkResult[algorithm] == 2)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			return 2;
		}
		break;
		//2021-12-27 1cam 2Pos Pre Align 시뮬레이션 추가.
	case 1000:
		BOOL bFindPatternEnd = simulration_1cam_2pos_align(algorithm);
		if (bFindPatternEnd == TRUE) m_nSeqProcess[algorithm] = 300;
		else
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;
		}
		break;
	}
	return nRet;
}
#pragma endregion

int CLET_AlignClientDlg::processAlign1Cam4PosRobotAlign_Conveyer(int algorithm)//1CAM 2Align   Mark 4개 Search
{
		CString str;
		int nRet = 0, ncamera = 0;
		int camCount = vt_job_info[algorithm].num_of_camera;
		std::vector<int> camBuf = vt_job_info[algorithm].camera_index;

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		int _sequence = m_nSeqProcess[algorithm];
		ReleaseSRWLockExclusive(&g_srwlock);

		switch (_sequence) {	// processAlign1Cam2PosPreAlign()
		case 0:
			break;
		case 100:
		{
			CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
			pFormMain->HideErrorMessageBlink();

			for (int nCam = 0; nCam < camCount; nCam++)
			{
				ncamera = camBuf.at(nCam);
#ifdef _DAHUHA
				AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
				AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
				m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
				ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
				ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

				LightControllerTurnOnOff(algorithm, nCam, 0);

				str.Format("[%s] Cam %d - Light On", vt_job_info[algorithm].job_name.c_str(), nCam + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

#ifdef _DAHUHA
				if (m_pDahuhaCam[ncamera].isconnected())
#else
				if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
				{
					str.Format("[%s] Cam %d - Grab Start", vt_job_info[algorithm].job_name.c_str(), ncamera + 1);
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
					Camera_Grab(ncamera);
					//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, ncamera);// Tkyuha 20211201 Thread로 변경
				}
			}

			m_nGrabTimeOutCount[algorithm] = 0;
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 200;
			ReleaseSRWLockExclusive(&g_srwlock);
		}
		break;
		case 200:
		{
			BOOL bGrabComplete = TRUE;
			for (int nCam = 0; nCam < camCount; nCam++)
			{
				ncamera = camBuf.at(nCam);
				if (m_bGrabEnd[ncamera] != TRUE)
					bGrabComplete = FALSE;
			}

			if (++m_nGrabTimeOutCount[algorithm] > 100)
			{
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				nRet = 2;

				str.Format("[%s] Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				break;
			}

			if (bGrabComplete)
			{
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 300;
				ReleaseSRWLockExclusive(&g_srwlock);
				str.Format("[%s] Grab Complete", vt_job_info[algorithm].job_name.c_str());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			}
			else	break;

			for (int nCam = 0; nCam < camCount; nCam++)
			{
				ncamera = camBuf.at(nCam);
				m_pPattern[ncamera].pDlg = this;
				m_pPattern[ncamera].nPos = 0;
				m_pPattern[ncamera].nCam = nCam;
				m_pPattern[ncamera].nSearchCount = 4;  //4point search 2개의 대상물 찾기 ,왼쪽 2개, 오른쪽2개
				m_pPattern[ncamera].nJob = algorithm;

				m_bFindPatternEnd[ncamera] = FALSE;
				m_bFindPattern[ncamera] = TRUE;

				AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
			}
		}
		break;
		case 300:
		{
			m_nErrorType[algorithm] = 0;

			BOOL bProcessEnd = TRUE;

			for (int nCam = 0; nCam < camCount; nCam++)
			{
				ncamera = camBuf.at(nCam);
				if (m_bFindPatternEnd[ncamera] != TRUE)
					bProcessEnd = FALSE;
			}

			if (bProcessEnd != TRUE) break;

			BOOL bFind = TRUE;
			for (int nCam = 0; nCam < camCount; nCam++)
			{
				ncamera = camBuf.at(nCam);
				if (m_bFindPattern[ncamera] != TRUE)
					bFind = FALSE;
			}

			CPaneAuto* pPane = (CPaneAuto*)m_pPane[PANE_AUTO];
			pPane->m_nObject = 0;
			int _2ObjectAlign = 0;
			m_bFind_object[0] = TRUE;
			m_bFind_object[1] = TRUE;

			// 2022.06.14 Tkyuha 패널 유무 검사 진행  추가해야함

			if (bFind != TRUE)
			{
				// 1 object
				if (GetMatching(algorithm).getFindInfo(0, 0).GetFound() != FIND_OK ||
					GetMatching(algorithm).getFindInfo(0, 1).GetFound() != FIND_OK)
				{
					m_bFind_object[0] = FALSE;

					// hsj 2022-02-14 확인중
					m_dbRevisionData_obejct[algorithm][AXIS_X][0] = 0;
					m_dbRevisionData_obejct[algorithm][AXIS_Y][0] = 0;
					m_dbRevisionData_obejct[algorithm][AXIS_T][0] = 0;

					m_dReeltoStageDistance[0] = 0;

				}
				else m_bFind_object[0] = TRUE;

				// 2 object
				if (GetMatching(algorithm).getFindInfo(0, 2).GetFound() != FIND_OK ||
					GetMatching(algorithm).getFindInfo(0, 3).GetFound() != FIND_OK)
				{
					m_bFind_object[1] = FALSE;

					// hsj 2022-02-14 확인중
					m_dbRevisionData_obejct[algorithm][AXIS_X][1] = 0;
					m_dbRevisionData_obejct[algorithm][AXIS_Y][1] = 0;
					m_dbRevisionData_obejct[algorithm][AXIS_T][1] = 0;

					m_dReeltoStageDistance[1] = 0;
				}
				else m_bFind_object[1] = TRUE;

				if (m_bFind_object[0] == TRUE) { _2ObjectAlign = 0; bFind = TRUE; pPane->m_nObject = 0; }
				if (m_bFind_object[1] == TRUE) { _2ObjectAlign = 2; bFind = TRUE; pPane->m_nObject = 1; }

				if (m_bSimulationStart != TRUE)
				{
					if (m_bFind_object[0] != TRUE) sendRevisionData(0, 0, 0, algorithm);
					if (m_bFind_object[1] != TRUE) sendRevisionSecondData(0, 0, 0, algorithm);
				}	
			}

			// HSJ 2022-02-14
			//if(m_bFind_object[0]!=TRUE|| m_bFind_object[1]!=TRUE)
			if (bFind != TRUE)
			{
				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);

				str.Format("Mark Search Error - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
				write_NGresult_SummaryFile(vt_job_info[algorithm].main_object_id.c_str(), str, FALSE, algorithm);
				break;
			}
			else
			{
				// 2022-01-20 Reel Align Offset revision From PLC
				// lData = [ X1, X1, Y1, Y1, T1, T1 ... X2, X2, Y2, Y2, T2, T2]
				long lData[40] = { 0, };
				g_CommPLC.GetWord(vt_job_info[algorithm].plc_addr_info.read_word_start, 40, lData);

				double X1, Y1, T1, X2, Y2, T2 = 0.0;
				X1 = MAKELONG(lData[0], lData[1]) / MOTOR_SCALE;
				Y1 = MAKELONG(lData[2], lData[3]) / MOTOR_SCALE;
				T1 = MAKELONG(lData[4], lData[5]) / MOTOR_SCALE;
				X2 = MAKELONG(lData[20], lData[21]) / MOTOR_SCALE;
				Y2 = MAKELONG(lData[22], lData[23]) / MOTOR_SCALE;
				T2 = MAKELONG(lData[24], lData[25]) / MOTOR_SCALE;

				str.Format("[%s] RevisionOffset Object1(X:%.3f Y:%.3f T:%.3f)", vt_job_info[algorithm].job_name.c_str(), X1, Y1, T1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				str.Format("[%s] RevisionOffset Object2(X:%.3f Y:%.3f T:%.3f)", vt_job_info[algorithm].job_name.c_str(), X2, Y2, T2);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			jumpLabel2:
				double posX = 0.0, refX, refworldX;
				double posY = 0.0, refY, refworldY;
				double worldX, worldY;
				CString strTemp;

				// 이미지 좌표계 → 실 좌표계
				ncamera = camBuf.at(0);
				int nCam = 0;
				int nSubPos = _2ObjectAlign / 2;

				for (int nPos = 0; nPos < 2; nPos++)
				{
					refX = GetMatching(algorithm).getRefX(nCam, nPos + _2ObjectAlign);
					refY = GetMatching(algorithm).getRefY(nCam, nPos + _2ObjectAlign);
					posX = GetMatching(algorithm).getFindInfo(nCam, nPos + _2ObjectAlign).GetXPos();
					posY = GetMatching(algorithm).getFindInfo(nCam, nPos + _2ObjectAlign).GetYPos();

					str.Format("[Cam %d] Pos %d - x: %.1f y: %.1f - x: %.1f y: %.1f", ncamera + 1, nPos + _2ObjectAlign, posX, posY, refX, refY);
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

					// Lincoln Lee - 2022-07-12 Conveyer Align 구조 개발
					GetMachine(algorithm).PixelToWorld(nCam, nSubPos, posX, posY, &worldX, &worldY);
					GetMachine(algorithm).PixelToWorld(nCam, nSubPos, refX, refY, &refworldX, &refworldY);					

					worldX -= refworldX;
				    worldY -= refworldY;

					GetPrealign(algorithm).setPosX(nPos, worldX);
					GetPrealign(algorithm).setPosY(nPos, worldY);

					GetPrealign(algorithm).setRotateX(nPos, -refworldX + GetMachine(algorithm).getRotateX(nCam, nSubPos));
					GetPrealign(algorithm).setRotateY(nPos, -refworldY + GetMachine(algorithm).getRotateY(nCam, nSubPos));
				}

				if (_2ObjectAlign == 0)	m_dReeltoStageDistance[0] = 0;
				else					m_dReeltoStageDistance[1] = 0;

				// 보정량 계산
				int nCamL = 0;
				int nCamR = 1;

				if (_2ObjectAlign == 0) // 첫번째 얼라인 
				{
					GetPrealign(algorithm).setRevisionOffset(AXIS_X, X1);
					GetPrealign(algorithm).setRevisionOffset(AXIS_Y, Y1);
					GetPrealign(algorithm).setRevisionOffset(AXIS_T, T1);
				}
				else
				{
					GetPrealign(algorithm).setRevisionOffset(AXIS_X, X2);
					GetPrealign(algorithm).setRevisionOffset(AXIS_Y, Y2);
					GetPrealign(algorithm).setRevisionOffset(AXIS_T, T2);
				}

				// 방향 결정
				GetPrealign(algorithm).setReverseAxisX(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX());
				GetPrealign(algorithm).setReverseAxisY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY());
				GetPrealign(algorithm).setReverseAxisT(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT());
				GetPrealign(algorithm).setReverseAxisXY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseXY());
				int target_dir = vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir();

				switch (vt_job_info[algorithm].model_info.getAlignInfo().getAngleCalcMethod()) {
				case 1:			// Glass Size
				{
					GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getGlassWidth());
					GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getGlassHeight());
				}
				break;
				case 2:			// Frame Size
				{
					GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getFrameWidth());
					GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getFrameHeight());
				}
				break;
				case 3:			// Rotate Center
				{
					double pitch_x = fabs(GetMachine(algorithm).getRotateX(nCamL, 0) - GetMachine(algorithm).getRotateX(nCamR, 0));
					double pitch_y = fabs(GetMachine(algorithm).getRotateY(nCamL, 0) - GetMachine(algorithm).getRotateY(nCamR, 0));

					GetPrealign(algorithm).setPatternPitchX(pitch_x);
					GetPrealign(algorithm).setPatternPitchY(pitch_y);
				}
				break;
				default:		//	Align Key
				{
					if (vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir() == CAM_HORI)
						GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
					else
						GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchY());		// dh.jung 2021-07-21  change

				}
				break;
				}

				BOOL bUse = vt_job_info[algorithm].model_info.getMachineInfo().getUseImageTheta();
				GetPrealign(algorithm).set_use_image_theta(bUse);

				if (bUse)
				{
					double posX[2], posY[2];
					double theta = 0.0;
					posX[0] = GetMatching(algorithm).getFindInfo(0, 0).GetXPos();
					posY[0] = GetMatching(algorithm).getFindInfo(0, 0).GetYPos();
					posX[1] = GetMatching(algorithm).getFindInfo(0, 1).GetXPos();
					posY[1] = GetMatching(algorithm).getFindInfo(0, 1).GetYPos();

					double dx = posX[1] - posX[0];
					double dy = posY[1] - posY[0];

					if (target_dir == 0)	theta = atan(dy / dx);
					else					theta = atan(dx / dy);
					GetPrealign(algorithm).set_image_theta(theta);
				}

				int type = vt_job_info[algorithm].model_info.getMachineInfo().getAlignmentType();

				GetPrealign(algorithm).setAlignmentType(type);

				if (GetPrealign(algorithm).calcRevisionRobot(0, 1, target_dir) != 0 )
				{
					str = "Calc Revision Failed";
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					nRet = 2;
					m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

					m_dbRevisionData[algorithm][AXIS_X] = 0;
					m_dbRevisionData[algorithm][AXIS_Y] = 0;
					m_dbRevisionData[algorithm][AXIS_T] = 0;
					break;
				}

				bool bInclude = true;
				if (vt_job_info[algorithm].model_info.getAlignInfo().getUseIncludedAngle() &&
					vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod() == METHOD_CALIPER)
				{
					double angle_spec = vt_job_info[algorithm].model_info.getAlignInfo().getIncludedAngle();
					double angle_limit = vt_job_info[algorithm].model_info.getAlignInfo().getIncludedAngleLimit();
					double angle = GetMatching(algorithm).getFindInfo(nCam, _2ObjectAlign).getCaliperAngle();

					if (fabs(angle - angle_spec) > angle_limit)
					{
						str.Format("Include Angle Line %d NG - %.2f(%.2f~%.2f)", _2ObjectAlign, angle, angle - angle_spec, angle + angle_spec);
						::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
						bInclude = false;
					}

					angle = GetMatching(algorithm).getFindInfo(nCam, _2ObjectAlign + 1).getCaliperAngle();  //Tkyuha 22.06.23 왜 이게 여기 있는지 모르겠음
					if (fabs(angle - angle_spec) > angle_limit)
					{
						str.Format("Include Angle Line %d NG - %.2f(%.2f~%.2f)", _2ObjectAlign + 2, angle, angle - angle_spec, angle + angle_spec);
						::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
						bInclude = false;
					}

					if (bInclude == false)
					{
						m_nErrorType[algorithm] = ERR_TYPE_ANGLE_ERROR;
						nRet = 2;
						AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
						m_nSeqProcess[algorithm] = 0;
						ReleaseSRWLockExclusive(&g_srwlock);
						break;
					}
				}

				// 보정량 전송
				if (fabs(GetPrealign(algorithm).getRevisionX()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_X) ||
					fabs(GetPrealign(algorithm).getRevisionY()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_Y) ||
					fabs(GetPrealign(algorithm).getRevisionT()) > vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_T))
				{
					m_nErrorType[algorithm] = ERR_TYPE_REVISION_LIMIT;

					nRet = 2;
					AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
					m_nSeqProcess[algorithm] = 0;
					ReleaseSRWLockExclusive(&g_srwlock);
					str.Format("[%s] X : %.4f Y : %.4f T : %.4f NG Limit", vt_job_info[algorithm].job_name.c_str(), GetPrealign(algorithm).getRevisionX(),
						GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

					// KBJ 2022-07-06 Align Revision Limit NG Error Message 추가
					CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
					str.Format("[Revision Limit NG] X : %.4f Y : %.4f T : %.4f", GetPrealign(algorithm).getRevisionX(),
						GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
					pFormMain->ShowErrorMessageBlink(str);

					break;
				}

				// prcoess 시뮬레이션이면 보정량 보내지 않도록 추가.
				if (m_bSimulationStart != TRUE)
				{
					if (_2ObjectAlign == 0) // 첫번째 얼라인 데이타 전송
						sendRevisionData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);
					else  //// 두번째 얼라인 데이타 전송
						sendRevisionSecondData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);
				}
				m_dbRevisionData[algorithm][AXIS_X] = GetPrealign(algorithm).getRevisionX();
				m_dbRevisionData[algorithm][AXIS_Y] = GetPrealign(algorithm).getRevisionY();
				m_dbRevisionData[algorithm][AXIS_T] = GetPrealign(algorithm).getRevisionT();

				// kbj 2022-01-09 add revisiondata from object
				if (_2ObjectAlign == 0) // 첫번째 얼라인 데이타 전송
				{
					m_dbRevisionData_obejct[algorithm][AXIS_X][0] = GetPrealign(algorithm).getRevisionX();
					m_dbRevisionData_obejct[algorithm][AXIS_Y][0] = GetPrealign(algorithm).getRevisionY();
					m_dbRevisionData_obejct[algorithm][AXIS_T][0] = GetPrealign(algorithm).getRevisionT();
				}
				else
				{
					m_dbRevisionData_obejct[algorithm][AXIS_X][1] = GetPrealign(algorithm).getRevisionX();
					m_dbRevisionData_obejct[algorithm][AXIS_Y][1] = GetPrealign(algorithm).getRevisionY();
					m_dbRevisionData_obejct[algorithm][AXIS_T][1] = GetPrealign(algorithm).getRevisionT();
				}
				//str.Format("X : %.4f Y : %.4f T : %.4f", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);
				str.Format("RevisionData (X : %.4f Y : %.4f T : %.4f)", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);  // dh.jung 2021-07-21  change

				//시간 전달

				CString strTime;
				SYSTEMTIME time;
				GetLocalTime(&time);

				if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
				else												strTime.Format("%s:%s:%s", m_strResultTime[algorithm].Left(2), m_strResultTime[algorithm].Mid(3, 2), m_strResultTime[algorithm].Right(2));

				BOOL bResult = FALSE;
				if (nRet == 2) bResult = FALSE;
				else bResult = TRUE;

				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				if (_2ObjectAlign == 0)
				{
					_2ObjectAlign += 2;

					if (m_bFind_object[1] == TRUE)	goto jumpLabel2; // 두번째 대상물 계산
				}

				// L-Check
				if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableLCheck())
				{
					// kbj 2022-01-06 save lcheck NG
					m_bLcheckNG[algorithm] = calc_lcheck_1cam_1shot_2object(algorithm);	// yeol 20210602

					if (m_bLcheckNG[algorithm] == TRUE)
					{
						m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
						nRet = 2;
						break;
					}
				}

				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				nRet = 1;
			}
		}
		break;
		case 400:
			if (m_nManualInputMarkResult[algorithm] == 1)
			{
				// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
				//m_pManualInputMarkCam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
				m_pManualInputMark1Cam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
				goto jumpLabel2;
			}
			else if (m_nManualInputMarkResult[algorithm] == 2)
			{
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				return 2;
			}
			break;
			//2021-12-27 1cam 2Pos Pre Align 시뮬레이션 추가.
		case 1000:
			BOOL bFindPatternEnd = simulration_1cam_2pos_align(algorithm);
			if (bFindPatternEnd == TRUE) m_nSeqProcess[algorithm] = 300;
			else
			{
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				nRet = 2;
			}
			break;
		}
		return nRet;
}

BOOL CLET_AlignClientDlg::simulration_1cam_2pos_align(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	// 알고리즘 시작.

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		m_pPattern[real_cam].pDlg = this;
		m_pPattern[real_cam].nPos = 0;
		m_pPattern[real_cam].nCam = nCam;
		m_pPattern[real_cam].nSearchCount = 4;  //2point search
		m_pPattern[real_cam].nJob = nJob;

		m_bFindPattern[real_cam] = FALSE;
		m_bFindPatternEnd[real_cam] = FALSE;

		AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);

		Delay(50);
	}

	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	int MS_TIMEOUT = 10000;

	BOOL all_insp_end = TRUE;
	while (nEtick - nStick <= MS_TIMEOUT) 
	{
		Sleep(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_insp_end = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];

			if (m_bFindPatternEnd[real_cam] != TRUE)
				all_insp_end = FALSE;
		}

		if (all_insp_end == TRUE) break;

		if (nEtick - nStick == MS_TIMEOUT)
		{
			str.Format("TimeOut(ms : %d) ", MS_TIMEOUT);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	if (all_insp_end != TRUE) return FALSE;


	BOOL bAllFind = TRUE;

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		int real_cam = vt_job_info[nJob].camera_index[nCam];

		if (m_bFindPattern[real_cam] != TRUE)
			bAllFind = FALSE;
	}

	if (bAllFind != TRUE)
	{
		for (int pos = 0; pos < 4; pos++)
		{
			if (GetMatching(nJob).getFindInfo(0, 0).GetFound() != FIND_OK ||
				GetMatching(nJob).getFindInfo(0, 1).GetFound() != FIND_OK)
			{
				m_bFind_object[0] = FALSE;
			}
			else
			{
				m_bFind_object[0] = TRUE;
			}
			if (GetMatching(nJob).getFindInfo(0, 2).GetFound() != FIND_OK ||
				GetMatching(nJob).getFindInfo(0, 3).GetFound() != FIND_OK)
			{
				m_bFind_object[1] = FALSE;
			}
			else
			{
				m_bFind_object[1] = TRUE;
			}
		}

		if (m_bFind_object[0] == TRUE) { bAllFind = TRUE; }
		if (m_bFind_object[1] == TRUE) { bAllFind = TRUE; }
	}

	return bAllFind;
}
int CLET_AlignClientDlg::process1Cam2ShotPrealign(int algorithm)
{
	CString str;
	int nRet = 0, ncamera = 0;
	BOOL bFirstFind = TRUE;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;
#endif

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[algorithm];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {	// processPrealignINFRA()
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("Cam %d - Grab Start", ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, ncamera);
			}
		}

		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			//SendServer(TCP_SEND_CAMERA_GRAB_END);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 280;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 0;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 1;
			m_pPattern[ncamera].nJob = algorithm;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
		}
	}
	break;
	case 280:
		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 290;
		ReleaseSRWLockExclusive(&g_srwlock);
		break;
	case 290:
	{
//		if (m_bSecondGrabStart[algorithm])	m_nSeqProcess[algorithm] = 292;
		// 2번째 촬상 위치에 도착 했는지 체크 하는 부분 추가 필요.

		if (++m_nGrabTimeOutCount[algorithm] > 200)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str = "2nd Grab Position Moving Timeout";
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}
	}
	break;
	case 292:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("Cam %d - 2nd Grab Start", ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, ncamera);
			}
		}

		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 294;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 294:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 296;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;
	}
	break;
	case 296:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		bFirstFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPattern[ncamera] != TRUE)
				bFirstFind = FALSE;
		}

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 1;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 1;
			m_pPattern[ncamera].nJob = algorithm;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 300;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
		break;
	case 300:
	{
		m_nErrorType[algorithm] = 0;

		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPattern[ncamera] != TRUE)
				bFind = FALSE;
		}

		if (bFind != TRUE || bFirstFind !=TRUE)
		{
#ifndef JOB_INFO
			if (getModel().getAlignInfo().getEnableAlignMeasureSpecOutJudge(camBuf.at(0)))
#else
			//KJH 2022-03-10 L-Check Error일 경우에도 Manual Mark 가능하게 변경
			//JSH 2022-03-16 진입 조건에서 L-Check 삭제
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge() )
#endif
			{
				// KBJ 2022-10-11 Manual Mark Bit 추가
				g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, TRUE);

				str.Format("Manual Mark Input - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK, MAKELPARAM(algorithm, TRUE));
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 400;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			else
			{
				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			break;
		}
		else
		{
		jumpLabel2:

			double posX = 0.0;
			double posY = 0.0;
			double worldX, worldY;
			CString strTemp;
			int nPos = 0;
			
			// 이미지 좌표계 → 실 좌표계
			int nCam = 0;
			int real_cam = vt_job_info[algorithm].camera_index[0];
			for (int nPos = 0; nPos < 2; nPos++)
			{
				posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();

				strTemp.Format("[Cam %d] x : %.1f y : %.1f", real_cam + 1, posX, posY);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

				// 일단은 같은 좌표계에서 
				GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);
				GetPrealign(algorithm).setPosX(nPos, worldX);
				GetPrealign(algorithm).setPosY(nPos, worldY);
			}

			// 보정량 계산
			int nCamL = 0;
			int nCamR = 1;

			GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
			GetPrealign(algorithm).setRotateX(nCamL, GetMachine(algorithm).getRotateX(nCamL, 0));
			GetPrealign(algorithm).setRotateY(nCamL, GetMachine(algorithm).getRotateY(nCamL, 0));
			GetPrealign(algorithm).setRotateX(nCamR, GetMachine(algorithm).getRotateX(nCamR, 1));
			GetPrealign(algorithm).setRotateY(nCamR, GetMachine(algorithm).getRotateY(nCamR, 1));

			// mm로 Offset 적용
			GetPrealign(algorithm).setRevisionOffset(0, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(0));
			GetPrealign(algorithm).setRevisionOffset(1, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(1));
			GetPrealign(algorithm).setRevisionOffset(2, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(2));
			GetPrealign(algorithm).pDlg = this;

			// 방향 결정
			GetPrealign(algorithm).setReverseAxisX(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX());
			GetPrealign(algorithm).setReverseAxisY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY());
			GetPrealign(algorithm).setReverseAxisT(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT());
			GetPrealign(algorithm).setReverseAxisXY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseXY());

			switch (vt_job_info[algorithm].model_info.getAlignInfo().getAngleCalcMethod()) {
			case 1:			// Glass Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getGlassWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getGlassHeight());
			}
			break;
			case 2:			// Frame Size
			{
				GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getFrameWidth());
				GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getFrameHeight());
			}
			break;
			case 3:			// Rotate Center
			{
				double pitch_x = fabs(GetMachine(algorithm).getRotateX(nCamL, 0) - GetMachine(algorithm).getRotateX(nCamR, 1));
				double pitch_y = fabs(GetMachine(algorithm).getRotateY(nCamL, 0) - GetMachine(algorithm).getRotateY(nCamR, 1));

				GetPrealign(algorithm).setPatternPitchX(pitch_x);
				GetPrealign(algorithm).setPatternPitchY(pitch_y);
			}
			break;
			default:		//	Align Key
			{
				if (vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir() == CAM_HORI)
					GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
				else
					GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
			}
			break;
			}

			int target_dir = vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir();
			if (GetPrealign(algorithm).calcRevision(nCamL, nCamR, target_dir) != 0)
			{
				str = "Calc Revision Failed";
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				nRet = 2;
				m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

				m_dbRevisionData[algorithm][AXIS_X] = 0;
				m_dbRevisionData[algorithm][AXIS_Y] = 0;
				m_dbRevisionData[algorithm][AXIS_T] = 0;
				break;
			}

			// L_Check 검사 위치 변동 20.02.20
			///////// L Check 검사
#ifndef JOB_INFO
			if (getModel().getAlignInfo().getEnableLCheck(camBuf.at(0)))
#else
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableLCheck())
#endif
			{
				//double camDist = getModel().getAlignInfo().getLCheckScale(camBuf.at(0));

				//double posX1 = GetPrealign(algorithm).getPosX(0);
				//double posY1 = GetPrealign(algorithm).getPosY(0);
				//double posX2 = GetPrealign(algorithm).getPosX(1);
				//double posY2 = GetPrealign(algorithm).getPosY(1);

				//int nCam = ncamera;
				//double world[2][2] = { 0, };
				//int W = m_pViewDisplayInfo[nCam].getViewImageWidth();
				//int H = m_pViewDisplayInfo[nCam].getViewImageHeight();
				//GetMachine().PixelToWorld(nCam, 0, 0, &world[0][0], &world[0][1]);
				//GetMachine().PixelToWorld(nCam, W, H, &world[1][0], &world[1][1]);

				//// Robot 좌표계의 방향에 따라 거리 값을 반영.
				//if (getModel().getAlignInfo().getAlignmentTargetDir(camBuf.at(0)) == 0)		// Horizontal
				//{
				//	if (world[1][0] > world[0][0])	posX2 += camDist;
				//	else							posX2 -= camDist;
				//}
				//else															// Vertical
				//{
				//	if (world[1][1] > world[0][1])	posY2 += camDist;
				//	else							posY2 -= camDist;
				//}

				//double dx = posX1 - posX2;
				//double dy = posY1 - posY2;
				//double diagonal = sqrt(dx * dx + dy * dy);
				//double limit = getModel().getAlignInfo().getLCheckLimit(nCam);
				//double pitch = getModel().getAlignInfo().getFiducialMarkPitchX(algorithm);

				//str.Format("L : %.3f", diagonal);
				//::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				//ncamera = camBuf.at(0);
				//writeLengthData(m_pViewDisplayInfo[ncamera].getPanelID(), diagonal, 2, algorithm);

				//if (fabs(pitch - diagonal) > limit)
				//{
				//	nRet = 2;
				//	m_nSeqProcess[algorithm] = 0;
				//	m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
				//	str.Format("L Check Error!! \r\nLength : %.3f, Pitch : %.3f, Limit : %.3f", diagonal, pitch, limit);
				//	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				//	m_dbLcheckLength[algorithm] = diagonal;
				//	m_bLcheckNG[algorithm] = TRUE;
				//	break;
				//}
			}

			// 보정량 전송
			double xMove = 0, yMove = 0;
			GetPrealign(algorithm).calcRotateOffset(GetPrealign(algorithm).getRevisionOffset(2), xMove, yMove);

			// kbj 2021-12-25 1cam2shot prcoess 시뮬레이션이면 보정량 보내지 않도록 추가.
			if (m_bSimulationStart != TRUE)
			{
				sendRevisionOffsetData(xMove, yMove, GetPrealign(algorithm).getRevisionOffset(2));

				sendRevisionData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);
			}
			str.Format("X : %.4f Y : %.4f T : %.4f", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 1;
		}
	}
	break;
	case 400:
		if (m_nManualInputMarkResult[algorithm] == 1)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			m_pManualInputMark[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			goto jumpLabel2;
		}
		else if (m_nManualInputMarkResult[algorithm] == 2)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			return 2;
		}
		break;
	}
	return nRet;
}
int CLET_AlignClientDlg::process2Cam2ShotPrealign(int algorithm)
{
	CString str;
	int nRet = 0, real_cam = 0;
	BOOL bFirstFind = TRUE;

	int camCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;

	BOOL bRequest = g_CommPLC.GetBit(m_nAlignRequestRead[algorithm]);
	BOOL bRequest2 = g_CommPLC.GetBit(m_nAlignRequestRead[algorithm] + 1);

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[algorithm];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {	// processPrealignINFRA()
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[real_cam].isconnected())
#else
			if (m_pBaslerCam[real_cam] || m_pSaperaCam[real_cam].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[algorithm].job_name.c_str(), nCam + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, real_cam);
			}
		}

		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bGrabEnd[real_cam] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			//SendServer(TCP_SEND_CAMERA_GRAB_END);
			break;
		}

		if (bGrabComplete)
		{
			str.Format("[%s] Grab Complete", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			// 2nd posiion move reqeust bit On
			if (bRequest)
			{
				g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start, TRUE);

				str.Format("[%s] 2nd Position Move Request", vt_job_info[algorithm].job_name.c_str());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			}
			else
			{
				// PLC Bit 꺼지면 그냥 리셋 시켜 버리자..
				str.Format("[%s] PLC Align Request Signal off! seq canceled", vt_job_info[algorithm].job_name.c_str());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				break;
			}

		}
		else	break;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			m_pPattern[real_cam].pDlg = this;
			m_pPattern[real_cam].nPos = 1;
			m_pPattern[real_cam].nCam = nCam;
			m_pPattern[real_cam].nSearchCount = 1;
			m_pPattern[real_cam].nJob = algorithm;

			m_bFindPatternEnd[real_cam] = FALSE;
			m_bFindPattern[real_cam] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 280;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 280:
		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 290;
		ReleaseSRWLockExclusive(&g_srwlock);
		break;
	case 290:
	{
		if (bRequest != TRUE)
		{
			// PLC Bit 꺼지면 그냥 리셋 시켜 버리자..
			str.Format("[%s] PLC Align Request Signal off! seq canceled", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			break;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 200)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s]2nd Grab Position Moving Timeout", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (g_CommPLC.GetBit(vt_job_info[algorithm].plc_addr_info.read_bit_start + 1))
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			m_nSeqProcess[algorithm] = 292;  // 확인필요
			ReleaseSRWLockExclusive(&g_srwlock);			
			break;
		}
	}
	break;
	case 292:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[real_cam].isconnected())
#else
			if (m_pBaslerCam[real_cam] || m_pSaperaCam[real_cam].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - 2nd Grab Start", vt_job_info[algorithm].job_name.c_str(), nCam + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, real_cam);
			}
		}

		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 294;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 294:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bGrabEnd[real_cam] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] 2nd Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 296;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] 2nd Grab Complete", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;
	}
	break;
	case 296:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPatternEnd[real_cam] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		bFirstFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPattern[real_cam] != TRUE)
				bFirstFind = FALSE;
			else
			{
				vt_result_info[algorithm].each_Judge[nCam][0] = TRUE;
			}
		}

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			m_pPattern[real_cam].pDlg = this;
			m_pPattern[real_cam].nPos = 0;
			m_pPattern[real_cam].nCam = nCam;
			m_pPattern[real_cam].nSearchCount = 1;
			m_pPattern[real_cam].nJob = algorithm;

			m_bFindPatternEnd[real_cam] = FALSE;
			m_bFindPattern[real_cam] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 300;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 300:
	{
		m_nErrorType[algorithm] = 0;

		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPatternEnd[real_cam] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPattern[real_cam] != TRUE)
				bFind = FALSE;
			else
			{
				vt_result_info[algorithm].each_Judge[nCam][1] = TRUE;
			}
		}

		if (bFind != TRUE || bFirstFind != TRUE)
		{
			//KJH 2022-03-10 L-Check Error일 경우에도 Manual Mark 가능하게 변경
			//JSH 2022-03-16 진입 조건에서 L-Check 삭제
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge() )
			{
				// KBJ 2022-10-11 Manual Mark Bit 추가
				g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, TRUE);

				str.Format("Manual Mark Input - %d - %d", m_bFindPattern[camBuf.at(0)], m_bFindPattern[camBuf.at(1)]);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK, MAKELPARAM(algorithm, TRUE));
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 400;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			else
			{
				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			break;
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 350;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 350:
	{	
	jumpLabel2:

		const int RB = 1;
		const int RT = 0;
		const int LB = 3;
		const int LT = 2;

		int nCamPosCount = 0;
		int nCamPos[4] = { LT, RT , LB , RB };

		double posX = 0.0;
		double posY = 0.0;
		double worldX, worldY;
		CString strTemp;
		int nPos = 0;
		// 이미지 좌표계 → 실 좌표계
		real_cam = camBuf.at(0);
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			for (int nPos = 0; nPos < 2; nPos++)
			{
				// CAM	POS
				// 0	0	LT
				// 0	1	RT
				//
				posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
				posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();

				strTemp.Format("[%s] Cam %d Pos %d x : %.1f y : %.1f", vt_job_info[algorithm].job_name.c_str(), nCam + 1, nPos + 1, posX, posY);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

				GetMachine(algorithm).PixelToWorld(nCam, 0, posX, posY, &worldX, &worldY);
				GetPrealign(algorithm).setPosX(nPos * 2 + nCam, worldX);
				GetPrealign(algorithm).setPosY(nPos * 2 + nCam, worldY);
				GetPrealign(algorithm).setRotateX(nPos * 2 + nCam, GetMachine(algorithm).getRotateX(nCam, nPos));
				GetPrealign(algorithm).setRotateY(nPos * 2 + nCam, GetMachine(algorithm).getRotateY(nCam, nPos));
			}
		}
		//GetPrealign(algorithm).setPatternPitchX(getModel().getAlignInfo().getFiducialMarkPitchX(algorithm));
		// 4점 얼라인 인경우 패널 크기를 pitch 로 사용
		GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getGlassWidth());
		GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getGlassHeight());


		// mm로 Offset 적용
		GetPrealign(algorithm).setRevisionOffset(0, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(0));
		GetPrealign(algorithm).setRevisionOffset(1, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(1));
		GetPrealign(algorithm).setRevisionOffset(2, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(2));
		GetPrealign(algorithm).pDlg = this;

		// 방향 결정
		GetPrealign(algorithm).setReverseAxisX(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX());
		GetPrealign(algorithm).setReverseAxisY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY());
		GetPrealign(algorithm).setReverseAxisT(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT());
		GetPrealign(algorithm).setReverseAxisXY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseXY());

		int nOLD = GetPrealign(algorithm).getAlignmentType();
		//GetPrealign(algorithm).setAlignmentType(ALIGNMENT_4P_CENTER);
		GetPrealign(algorithm).setAlignmentType(vt_job_info[algorithm].model_info.getMachineInfo().getAlignmentType());


		int nCamL = 0;
		int nCamR = 1;
		int cam_pos = vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir();

		//if (vt_job_info[algorithm].model_info.getMachineInfo().getAlignmentType() == ALIGNMENT_4P_CENTER)
		{
			int cam = 0;
			int pos = 0;
			// LT
			posX = GetMatching(algorithm).getFindInfo(cam, pos).GetXPos();
			posY = GetMatching(algorithm).getFindInfo(cam, pos).GetYPos();
			GetMachine(algorithm).PixelToWorld(cam, 0, posX, posY, &worldX, &worldY);
			GetPrealign(algorithm).setPosX(0, worldX);
			GetPrealign(algorithm).setPosY(0, worldY);
			GetPrealign(algorithm).setRotateX(0, GetMachine(algorithm).getRotateX(cam, pos));
			GetPrealign(algorithm).setRotateY(0, GetMachine(algorithm).getRotateY(cam, pos));

			// RT
			cam = 0;
			pos = 1;
			posX = GetMatching(algorithm).getFindInfo(cam, pos).GetXPos();
			posY = GetMatching(algorithm).getFindInfo(cam, pos).GetYPos();
			GetMachine(algorithm).PixelToWorld(cam, 0, posX, posY, &worldX, &worldY);
			GetPrealign(algorithm).setPosX(1, worldX);
			GetPrealign(algorithm).setPosY(1, worldY);
			GetPrealign(algorithm).setRotateX(1, GetMachine(algorithm).getRotateX(cam, pos));
			GetPrealign(algorithm).setRotateY(1, GetMachine(algorithm).getRotateY(cam, pos));

			// LB
			cam = 1;
			pos = 0;
			posX = GetMatching(algorithm).getFindInfo(cam, pos).GetXPos();
			posY = GetMatching(algorithm).getFindInfo(cam, pos).GetYPos();
			GetMachine(algorithm).PixelToWorld(cam, 0, posX, posY, &worldX, &worldY);
			GetPrealign(algorithm).setPosX(2, worldX);
			GetPrealign(algorithm).setPosY(2, worldY);
			GetPrealign(algorithm).setRotateX(2, GetMachine(algorithm).getRotateX(cam, pos));
			GetPrealign(algorithm).setRotateY(2, GetMachine(algorithm).getRotateY(cam, pos));

			// RB
			cam = 1;
			pos = 1;
			posX = GetMatching(algorithm).getFindInfo(cam, pos).GetXPos();
			posY = GetMatching(algorithm).getFindInfo(cam, pos).GetYPos();
			GetMachine(algorithm).PixelToWorld(cam, 0, posX, posY, &worldX, &worldY);
			GetPrealign(algorithm).setPosX(3, worldX);
			GetPrealign(algorithm).setPosY(3, worldY);
			GetPrealign(algorithm).setRotateX(3, GetMachine(algorithm).getRotateX(cam, pos));
			GetPrealign(algorithm).setRotateY(3, GetMachine(algorithm).getRotateY(cam, pos));
		}
		//else
		//{
		//	// LT
		//	posX = GetMatching(algorithm).getFindInfo(0, 0).GetXPos();
		//	posY = GetMatching(algorithm).getFindInfo(0, 0).GetYPos();
		//	GetMachine(algorithm).PixelToWorld(0, 0, posX, posY, &worldX, &worldY);
		//	GetPrealign(algorithm).setPosX(0, worldX);
		//	GetPrealign(algorithm).setPosY(0, worldY);
		//	GetPrealign(algorithm).setRotateX(0, GetMachine(algorithm).getRotateX(0, 0));
		//	GetPrealign(algorithm).setRotateY(0, GetMachine(algorithm).getRotateY(0, 0));

		//	// LB
		//	posX = GetMatching(algorithm).getFindInfo(1, 0).GetXPos();
		//	posY = GetMatching(algorithm).getFindInfo(1, 0).GetYPos();
		//	GetMachine(algorithm).PixelToWorld(1, 0, posX, posY, &worldX, &worldY);
		//	GetPrealign(algorithm).setPosX(1, worldX);
		//	GetPrealign(algorithm).setPosY(1, worldY);
		//	GetPrealign(algorithm).setRotateX(1, GetMachine(algorithm).getRotateX(1, 0));
		//	GetPrealign(algorithm).setRotateY(1, GetMachine(algorithm).getRotateY(1, 0));
		//}


		switch (vt_job_info[algorithm].model_info.getAlignInfo().getAngleCalcMethod()) {
		case 1:			// Glass Size
		{
			GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getGlassWidth());
			GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getGlassHeight());
		}
		break;
		case 2:			// Frame Size
		{
			GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getGlassInfo().getFrameWidth());
			GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getGlassInfo().getFrameHeight());
		}
		break;
		case 3:			// Rotate Center
		{
			double pitch_x = fabs(GetMachine(algorithm).getRotateX(0, 1) - GetMachine(algorithm).getRotateX(0, 0));
			double pitch_x2 = fabs(GetMachine(algorithm).getRotateX(1, 1) - GetMachine(algorithm).getRotateX(1, 0));
			double pitch_y = fabs(GetMachine(algorithm).getRotateY(1, 0) - GetMachine(algorithm).getRotateY(0, 0));
			double pitch_y2 = fabs(GetMachine(algorithm).getRotateY(1, 1) - GetMachine(algorithm).getRotateY(0, 1));

			GetPrealign(algorithm).setPatternPitchX((pitch_x + pitch_x2) / 2.0);
			GetPrealign(algorithm).setPatternPitchY((pitch_y + pitch_y2) / 2.0);
		}
		break;
		default:		//	Align Key
		{
			GetPrealign(algorithm).setPatternPitchX(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialMarkPitchX());
			GetPrealign(algorithm).setPatternPitchY(vt_job_info[algorithm].model_info.getAlignInfo().getFiducialSecondMarkPitchY());

		}
		break;
		}


		if (GetPrealign(algorithm).calcRevision4Cam_Center(0, 1, 2, 3, vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir()) != 0)
		{
			str = "Calc Revision Failed";
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			nRet = 2;
			m_nErrorType[algorithm] = ERR_TYPE_REVISION_FAIL;

			m_dbRevisionData[algorithm][AXIS_X] = 0;
			m_dbRevisionData[algorithm][AXIS_Y] = 0;
			m_dbRevisionData[algorithm][AXIS_T] = 0;
			break;
		}

		m_dbRevisionData[algorithm][AXIS_X] = GetPrealign(algorithm).getRevisionX();
		m_dbRevisionData[algorithm][AXIS_Y] = GetPrealign(algorithm).getRevisionY();
		m_dbRevisionData[algorithm][AXIS_T] = GetPrealign(algorithm).getRevisionT();


		/*
					if (vt_job_info[algorithm].model_info.getMachineInfo().getAlignmentType() == ALIGNMENT_4P_CENTER)
					{
						if (GetPrealign(algorithm).calcRevision4Cam_Center(0, 1, 2, 3, vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir()) != 0)
						{
							str = "Calc Revision Failed";
							::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
							nRet = 2;

							m_dbRevisionData[algorithm][AXIS_X] = 0;
							m_dbRevisionData[algorithm][AXIS_Y] = 0;
							m_dbRevisionData[algorithm][AXIS_T] = 0;
							break;
						}
					}
					else
					{
						if (GetPrealign(algorithm).calcRevision(nCamL, nCamR, cam_pos, 0, FALSE) != 0)
						{
							str = "Calc Revision Failed";
							::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
							nRet = 2;

							m_dbRevisionData[algorithm][AXIS_X] = 0;
							m_dbRevisionData[algorithm][AXIS_Y] = 0;
							m_dbRevisionData[algorithm][AXIS_T] = 0;
							break;
						}
					}
		*/


		// L_Check 검사 위치 변동 20.02.20
		///////// L Check 검사
		if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableLCheck())
		{
			BOOL bError = FALSE;

			bError = calc_lcheck_2cam_2pos(algorithm);

			if (bError)
			{
				m_nErrorType[algorithm] = ERR_TYPE_L_CHECK;
				m_bLcheckNG[algorithm] = TRUE;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				nRet = 2;
				break;
			}
			else
			{
				m_bLcheckNG[algorithm] = FALSE;
			}
		}

		
		// 보정량 전송
		double xMove = 0, yMove = 0;
		GetPrealign(algorithm).calcRotateOffset(GetPrealign(algorithm).getRevisionOffset(2), xMove, yMove);

		if (m_bSimulationStart != TRUE)
		{
			sendRevisionOffsetData(xMove, yMove, GetPrealign(algorithm).getRevisionOffset(2));
			sendRevisionData(GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT(), algorithm);
			// Matching Rate 전송
			sendMatchingRateData(algorithm);
		}

		str.Format("[%s] X : %.4f Y : %.4f T : %.4f", vt_job_info[algorithm].job_name.c_str(), GetPrealign(algorithm).getRevisionX(), GetPrealign(algorithm).getRevisionY(), GetPrealign(algorithm).getRevisionT());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);

		nRet = 1;
	}
	break;
	case 400:
	{
		if (m_nManualInputMarkResult[algorithm] == 1)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			m_pManualInputMark[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			goto jumpLabel2;
		}
		else if (m_nManualInputMarkResult[algorithm] == 2)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			return 2;
		}
	}
	break;
#pragma region 시뮬레이션 
	case 1000:
	{
		BOOL bFindPatternEnd = simulration_2cam_2shot_align(algorithm);
		if (bFindPatternEnd == TRUE) m_nSeqProcess[algorithm] = 350;
		else
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;
		}		
	}
	break;
#pragma endregion
	}
	return nRet;
}
BOOL CLET_AlignClientDlg::processCenterAlignELB(int algorithm)
{
	BOOL nRet = 0;

	CString str;
	int ncamera = 0;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[algorithm].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algorithm].camera_index;
#endif

	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[algorithm];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		//HTK 2022-04-04 Align TactTime 추가
		//HTK 2022-03-30 Tact Time Display 추가
		((CPaneAuto*)m_pPane[PANE_AUTO])->update_grid_processing_time(0);
		pFormMain->m_clockProcStartTime[0] = clock();

		//KJH 2021-05-29 Grab전 조명 ON
		int camCount = vt_job_info[algorithm].num_of_camera;
		int n = 0;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			LightControllerTurnOnOff(algorithm, nCam, 0);

			//for (int nLight = 0; nLight < vt_job_info[algorithm].light_info[n].num_of_using_light; nLight++)
			//{
			//	int ctrl = vt_job_info[algorithm].light_info[n].controller_id[nLight] - 1;
			//	int ch = vt_job_info[algorithm].light_info[n].channel_id[nLight];
			//	int value = vt_job_info[algorithm].model_info.getLightInfo().getLightBright(nCam, nLight, 0);
			//	if (m_stLightCtrlInfo.nType[0] == LTYPE_LLIGHT_LPC_COT_232)
			//	{
			//		SetLightBright(ctrl, ch, value == 0 ? 0 : value * 10);   // dh.jung 2021-07-12
			//	}
			//	else
			//	{
			//		SetLightBright(ctrl, ch, value);
			//	}
			//	Delay(50);
			//}
		}

		str.Format("[%s] Cam %d - Light On", vt_job_info[algorithm].job_name.c_str(), ncamera + 1);
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		
		//Tkyuha 2021-12-24 Delay 설정
		Delay(vt_job_info[algorithm].model_info.getInspSpecParaInfo().getCenterAlignGrabDelay());

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[algorithm].job_name.c_str(), ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				//SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, ncamera);
				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				//Camera_Grab(ncamera);
				SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, ncamera);
			}
		}

		m_nGrabTimeOutCount[algorithm] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[algorithm] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 210;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[algorithm].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;
	}
	break;
	case 210:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 0;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 1; 
			m_pPattern[ncamera].nJob = algorithm;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[algorithm] = 300;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 300:
	{
		m_nErrorType[algorithm] = 0;

		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE)
		{
			// hsj 2022-02-14
			m_dbRevisionData[algorithm][AXIS_X] = 0;
			m_dbRevisionData[algorithm][AXIS_Y] = 0;
			m_dbRevisionData[algorithm][AXIS_T] = 0;

			break;
		}

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPattern[ncamera] != TRUE)
				bFind = FALSE;
		}

		if (bFind != TRUE)
		{
#ifndef JOB_INFO
			if (getModel().getAlignInfo().getEnableAlignMeasureSpecOutJudge(camBuf.at(0)))
#else
			//KJH 2022-03-10 L-Check Error일 경우에도 Manual Mark 가능하게 변경
			//JSH 2022-03-16 진입 조건에서 L-Check 삭제
			if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge() )
#endif
			{
				// KBJ 2022-10-11 Manual Mark Bit 추가
				g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, TRUE);

				str.Format("[%s] Manual Mark Input - %d - %d", vt_job_info[algorithm].job_name.c_str(), m_bFindPattern[0], m_bFindPattern[1]);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				GetMatching(algorithm).getFindInfo(0, 0).SetFound(TRUE);
				GetMatching(algorithm).getFindInfo(0, 1).SetFound(FALSE);

				// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
				//::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK, MAKELPARAM(algorithm, TRUE));
				::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK_1CAM, MAKELPARAM(algorithm, TRUE));
				int method = vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod();
				if (method == METHOD_LINE)			m_pManualInputMark1Cam[algorithm]->initManualInputTracker(1); // 직선 선택
				else if (method == METHOD_CIRCLE) 
				{
					double xres = GetMachine(algorithm).getCameraResolutionX(0, 0);
					double	dPNSizeSpec = vt_job_info[algorithm].model_info.getInspSpecParaInfo().getPNSizeSpec() / xres;
					int W = m_stCamInfo[0].w;
					int H = m_stCamInfo[0].h;
					CPoint st, et;
					st.x = W / 2 - dPNSizeSpec; st.y = H / 2 - dPNSizeSpec;
					et.x = W / 2 + dPNSizeSpec; et.y = H / 2 + dPNSizeSpec;
					m_pManualInputMark1Cam[algorithm]->initManualInputTracker(2, &st, &et); // 원 선택
				}
				else m_pManualInputMark1Cam[algorithm]->initManualInputTracker(0);

				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 400;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			else
			{
				nRet = 2;

				// hsj 2022-02-14
				m_dbRevisionData[algorithm][AXIS_X] = 0;
				m_dbRevisionData[algorithm][AXIS_Y] = 0;
				m_dbRevisionData[algorithm][AXIS_T] = 0;

				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[algorithm] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);

				str.Format("Mark Search Error - %d - %d", m_bFindPattern[0], m_bFindPattern[1]);
				write_NGresult_SummaryFile(vt_job_info[algorithm].main_object_id.c_str(), str, FALSE, algorithm);
			}
			break;
		}
		else
		{
		jumpLabel2:

			double posX = 0.0;
			double posY = 0.0;
			double worldX, worldY;
			CString strTemp;

			// 이미지 좌표계 → 실 좌표계
			ncamera = camBuf.at(0);
			int nCam = 0, nPos = 0;
			int W = m_stCamInfo[ncamera].w;
			int H = m_stCamInfo[ncamera].h;

			posX = GetMatching(algorithm).getFindInfo(nCam, nPos).GetXPos();
			posY = GetMatching(algorithm).getFindInfo(nCam, nPos).GetYPos();

			strTemp.Format("[%s][Cam %d] Pos %d - x : %.1f y : %.1f", vt_job_info[algorithm].job_name.c_str(), ncamera + 1, nPos, posX, posY);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

			m_ELB_TraceResult.m_vELB_ImageRotateCenter = cv::Point2d(posX, posY);

			// 일단은 같은 좌표계에서 불러 오도록
			GetMachine(algorithm).PixelToWorld(nCam, nCam, posX, posY, &worldX, &worldY);
			GetPrealign(algorithm).setPosX(nPos, worldX);
			GetPrealign(algorithm).setPosY(nPos, worldY);

			// 보정량 계산
			int nCamL = 0;

			GetPrealign(algorithm).setRotateX(nCamL, GetMachine(algorithm).getRotateX(nCamL, 0));
			GetPrealign(algorithm).setRotateY(nCamL, GetMachine(algorithm).getRotateY(nCamL, 0));

			// mm로 Offset 적용
			GetPrealign(algorithm).setRevisionOffset(0, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(0));
			GetPrealign(algorithm).setRevisionOffset(1, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(1));
			GetPrealign(algorithm).setRevisionOffset(2, vt_job_info[algorithm].model_info.getMachineInfo().getRevisionOffset(2));
			GetPrealign(algorithm).pDlg = this;

			// 방향 결정
			GetPrealign(algorithm).setReverseAxisX(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX());
			GetPrealign(algorithm).setReverseAxisY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY());
			GetPrealign(algorithm).setReverseAxisT(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT());
			GetPrealign(algorithm).setReverseAxisXY(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseXY());
			int target_dir = vt_job_info[algorithm].model_info.getAlignInfo().getAlignmentTargetDir();
			int method = vt_job_info[algorithm].model_info.getAlignInfo().getMarkFindMethod();

			//GetPrealign(algorithm).calcRotate(GetMachine(algorithm).getRotateX(nCamL, 0), GetMachine(algorithm).getRotateY(nCamL, 0), worldX, worldY, -m_ELB_TraceResult.m_ELB_ResultT, &m_dbRevisionData[algorithm][AXIS_X], &m_dbRevisionData[algorithm][AXIS_Y]);

			if(method==METHOD_NOTCH || method == METHOD_LINE)
            {
				m_dbRevisionData[algorithm][AXIS_X] = worldX;
				m_dbRevisionData[algorithm][AXIS_Y] = worldY;
	    	}
	    	else
	    	{				
				m_dbRevisionData[algorithm][AXIS_X] = worldX;
				m_dbRevisionData[algorithm][AXIS_Y] = worldY;

				//20211123 Tkyuha 회전중심 무시하도록 얼라인 진행 수정
				/*if (vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX())
					m_dbRevisionData[algorithm][AXIS_X] = worldX - GetMachine(algorithm).getRotateX(nCamL, 0) / 2.;
				else	m_dbRevisionData[algorithm][AXIS_X] = worldX + GetMachine(algorithm).getRotateX(nCamL, 0) / 2.;

				if (vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY())
					m_dbRevisionData[algorithm][AXIS_Y] = worldY - GetMachine(algorithm).getRotateY(nCamL, 0) / 2.;
				else m_dbRevisionData[algorithm][AXIS_Y] = worldY + GetMachine(algorithm).getRotateY(nCamL, 0) / 2.;*/
			 }
			switch (method)
			{
				case METHOD_LINE:			// Line
				{
					m_dbRevisionData[algorithm][AXIS_T] = -m_ELB_TraceResult.m_ELB_ResultT;
					m_dbRevisionData[algorithm][AXIS_X] = 0;
					m_dbRevisionData[algorithm][AXIS_T] = 0;
					if(vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY())
						m_dbRevisionData[algorithm][AXIS_Y] *= -1; // Y축 부호 반전					
				}
				break;
				case METHOD_CIRCLE:			// Circle
				{					
					m_dbRevisionData[algorithm][AXIS_T] = 0;
					if (vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY())
						m_dbRevisionData[algorithm][AXIS_Y] *= -1; // Y축 부호 반전			
					m_dbRevisionData[algorithm][AXIS_Y] += GetPrealign(algorithm).getRevisionOffset(1);
					if (vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX())
						m_dbRevisionData[algorithm][AXIS_X] *= -1; // Y축 부호 반전	
					m_dbRevisionData[algorithm][AXIS_X] += GetPrealign(algorithm).getRevisionOffset(0);
				}
				break;
				case METHOD_NOTCH:			// Notch
				{
					m_dbRevisionData[algorithm][AXIS_T] = 0;// -m_ELB_TraceResult.m_ELB_ResultT;
					if (vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX())
						m_dbRevisionData[algorithm][AXIS_X] *= -1; // X축 부호 반전	
					m_dbRevisionData[algorithm][AXIS_X] += GetPrealign(algorithm).getRevisionOffset(0);
					if (vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY())
						m_dbRevisionData[algorithm][AXIS_Y] *= -1; // Y축 부호 반전	
					m_dbRevisionData[algorithm][AXIS_Y] += GetPrealign(algorithm).getRevisionOffset(1);
					if (vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT())
						m_dbRevisionData[algorithm][AXIS_T] *= -1; // T축 부호 반전	
					m_dbRevisionData[algorithm][AXIS_T] += GetPrealign(algorithm).getRevisionOffset(2);
				}
				break;
				default:		//	Ellipse
				{
					m_dbRevisionData[algorithm][AXIS_T] = 0;
					if (vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseX())
						m_dbRevisionData[algorithm][AXIS_X] *= -1; // X축 부호 반전	
					m_dbRevisionData[algorithm][AXIS_X] += GetPrealign(algorithm).getRevisionOffset(0);
					if (vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseY())
						m_dbRevisionData[algorithm][AXIS_Y] *= -1; // Y축 부호 반전	
					m_dbRevisionData[algorithm][AXIS_Y] += GetPrealign(algorithm).getRevisionOffset(1);
					if (vt_job_info[algorithm].model_info.getAlignInfo().getRevisionReverseT())
						m_dbRevisionData[algorithm][AXIS_T] *= -1; // T축 부호 반전	
					m_dbRevisionData[algorithm][AXIS_T] += GetPrealign(algorithm).getRevisionOffset(2);
				}
				break;
			}

			bool bfalsealarm_check = false;
			//KJH 2022-08-01 Center Align 보정값 0일때 NG예외처리 삭제
			//if(method== METHOD_CIRCLE && ((m_dbRevisionData[algorithm][AXIS_X]==0 && m_dbRevisionData[algorithm][AXIS_Y]==0)))			// Circle
			//	bfalsealarm_check = true;

			// 보정량 전송
			if(bfalsealarm_check || fabs(m_dbRevisionData[algorithm][AXIS_X]> vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_X)) ||
				fabs(m_dbRevisionData[algorithm][AXIS_Y]> vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_Y)) ||
				fabs(m_dbRevisionData[algorithm][AXIS_T])> vt_job_info[algorithm].model_info.getMachineInfo().getRevisionLimit(AXIS_T))
			{
				m_nErrorType[algorithm] = ERR_TYPE_REVISION_LIMIT;

				if (vt_job_info[algorithm].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge())
				{
					// KBJ 2022-10-11 Manual Mark Bit 추가
					g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, TRUE);

					GetMatching(algorithm).getFindInfo(0, 0).SetFound(TRUE);
					GetMatching(algorithm).getFindInfo(0, 1).SetFound(FALSE);
					// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
					//::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK, MAKELPARAM(algorithm, TRUE));
					::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK_1CAM, MAKELPARAM(algorithm, TRUE));

					if (method == METHOD_LINE)			m_pManualInputMark1Cam[algorithm]->initManualInputTracker(1); // 직선 선택
					else if (method == METHOD_CIRCLE)
					{
						double xres = GetMachine(algorithm).getCameraResolutionX(nCamL, 0);
						double	dPNSizeSpec = vt_job_info[algorithm].model_info.getInspSpecParaInfo().getPNSizeSpec()/xres;
						
						CPoint st, et;
						st.x = W/2- dPNSizeSpec; st.y = H/2- dPNSizeSpec;
						et.x = W/2+ dPNSizeSpec; et.y = H/2+ dPNSizeSpec;
						m_pManualInputMark1Cam[algorithm]->initManualInputTracker(2,&st,&et); // 원 선택
					}
					else m_pManualInputMark1Cam[algorithm]->initManualInputTracker(0);

					AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
					m_nSeqProcess[algorithm] = 400;
					ReleaseSRWLockExclusive(&g_srwlock);
				}
				else
				{
					AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
					m_nSeqProcess[algorithm] = 0;
					ReleaseSRWLockExclusive(&g_srwlock);
					nRet = 2;
				}
				
				str.Format("[%s] X : %.4f Y : %.4f T : %.4f NG Limit", vt_job_info[algorithm].job_name.c_str(), m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				write_NGresult_SummaryFile(vt_job_info[algorithm].main_object_id.c_str(), str, FALSE, algorithm);

				// KBJ 2022-07-06 Align Revision Limit NG Error Message 추가
				CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
				str.Format("[Revision Limit NG] X : %.4f Y : %.4f T : %.4f", m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T]);
				pFormMain->ShowErrorMessageBlink(str);

				break;
			}
		
			// kbj 2021-12-27 CenterAlignProcess 시뮬레이션이면 보정량 보내지 않도록 추가.
			if(m_bSimulationStart != TRUE)
				sendRevisionData(m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T], algorithm);

			// KBJ 2022-02-23 CenterAlignProcess 시뮬레이션이면 Rotate Center 보내지 않도록 추가.
			if (m_bSimulationStart != TRUE)
			{
				// 회전 중심 전송
				long pDataCount[4] = { 0, };
				double rotateX = GetMachine(algorithm).getRotateX(nCamL, 0);
				double rotateY = GetMachine(algorithm).getRotateY(nCamL, 0);

				pDataCount[0] = LOWORD(rotateX * MOTOR_SCALE);
				pDataCount[1] = HIWORD(rotateX * MOTOR_SCALE);
				pDataCount[2] = LOWORD(rotateY * MOTOR_SCALE);
				pDataCount[3] = HIWORD(rotateY * MOTOR_SCALE);
				g_CommPLC.SetWord(vt_job_info[algorithm].plc_addr_info.write_word_start + 14, 4, pDataCount);
			}
			str.Format("[%s] X : %.4f Y : %.4f T : %.4f(%.4f,%.4f,%.4f)", vt_job_info[algorithm].job_name.c_str(), m_dbRevisionData[algorithm][AXIS_X], m_dbRevisionData[algorithm][AXIS_Y], m_dbRevisionData[algorithm][AXIS_T],
				GetPrealign(algorithm).getRevisionOffset(0), GetPrealign(algorithm).getRevisionOffset(1), GetPrealign(algorithm).getRevisionOffset(2));
			
			//시간 전달

			CString strTime;
			SYSTEMTIME time;
			GetLocalTime(&time);

			/*if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else												strTime.Format("%s", m_strResultTime[algorithm]);*/

			if (m_strResultTime[algorithm].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
			else										strTime.Format("%s:%s:%s", m_strResultTime[algorithm].Left(2), m_strResultTime[algorithm].Mid(3, 2), m_strResultTime[algorithm].Right(2));

			// HSJ 2022-02-14 thread_process로 위치변경
			//Align 결과값 띄우기
			/*::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)algorithm);
			::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(bResult, algorithm));
			::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(algorithm));*/
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);

			//HTK 2022-04-04 Align TactTime 추가
			pFormMain->m_clockProc_elapsed_time[0] = (clock() - pFormMain->m_clockProcStartTime[0]) / (float)CLOCKS_PER_SEC;
			((CPaneAuto*)m_pPane[PANE_AUTO])->update_grid_processing_time(1, pFormMain->m_clockProc_elapsed_time[0], 7, true);

			//KJH 2022-07-27 Tact Time Log 추가
			theLog.logmsg(LOG_PLC_SEQ, "Center Align Seq Tact Time = %.4f", pFormMain->m_clockProc_elapsed_time[0]);

			nRet = 1;
		}
	}
	break;
	case 400:
		if (m_nManualInputMarkResult[algorithm] == 1)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
			//m_pManualInputMarkCam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			m_pManualInputMark1Cam[algorithm]->KillTimer(TIMER_MANUAL_MARK);
			goto jumpLabel2;
		}
		else if (m_nManualInputMarkResult[algorithm] == 2)
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[algorithm].plc_addr_info.write_bit_start + 8, FALSE);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			return 2;
		}
		break;
// KBJ 2022-02-23 ELB_Center_Align 시뮬레이션 추가.
	case 1000:
		m_ELB_TraceResult.bType = 0;
		BOOL bFindPatternEnd = simulration_ELB_center_align(algorithm);
		if (bFindPatternEnd == TRUE) m_nSeqProcess[algorithm] = 300;
		else
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[algorithm] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;
		}
		break;
	}

	return nRet;
}

BOOL CLET_AlignClientDlg::simulration_ELB_center_align(int nJob) // KBJ 2022-02-23 ELB_Center_Align 시뮬레이션 추가.
{
	CString str;
	int nRet = 0, real_cam = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	// 알고리즘 시작.

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		m_pPattern[real_cam].pDlg = this;
		m_pPattern[real_cam].nPos = 0;
		m_pPattern[real_cam].nCam = nCam;
		m_pPattern[real_cam].nSearchCount = 1;
		m_pPattern[real_cam].nJob = nJob;

		m_bFindPattern[real_cam] = FALSE;
		m_bFindPatternEnd[real_cam] = FALSE;

		AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);

		Delay(50);
	}

	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	int MS_TIMEOUT = 10000;

	BOOL all_insp_end = TRUE;
	while (nEtick - nStick <= MS_TIMEOUT) {
		Sleep(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_insp_end = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];

			if (m_bFindPatternEnd[real_cam] != TRUE)
				all_insp_end = FALSE;
		}

		if (all_insp_end == TRUE) break;

		if (nEtick - nStick == MS_TIMEOUT)
		{
			str.Format("TimeOut(ms : %d) ", MS_TIMEOUT);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	if (all_insp_end != TRUE) return FALSE;


	BOOL bAllFind = TRUE;

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		int real_cam = vt_job_info[nJob].camera_index[nCam];

		if (m_bFindPattern[real_cam] != TRUE)
			bAllFind = FALSE;
	}

	return bAllFind;
}

BOOL CLET_AlignClientDlg::processScanInsp(int nJob)
{
	CString str;
	int nRet = 0, ncamera = 0;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;
#endif
	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		int ncount = 1;
		if (m_nSeqScanInspGrabCount[nJob] == 1) ncount = _SCAN_GRAB_MAXCOUNT;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_bGrabEnd[ncamera] = FALSE;
			m_pSaperaCam[ncamera].ClearFullBuffer();

			//g_CommPLC.SetBit(m_nInspAckWrite[nJob], TRUE);
			//if (ncamera == 0) Sleep(150);
			//else Sleep(120);
#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("Cam %d - Grab Start", ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_MULTI_FRAME, MAKELPARAM(ncamera, ncount));
//				m_nSeqCurrentInspGrabCount = m_nSeqScanInspGrabCount[nJob];   // dh.jung 2021-05-12 add
			}
		}

		m_nGrabTimeOutCount[nJob] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		int ncount = 1;

		if (m_nSeqScanInspGrabCount[nJob] == 1) ncount = _SCAN_GRAB_MAXCOUNT;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			for (int j = 0; j < ncount; j++)
			{
				if (!m_pSaperaCam[ncamera].GetGrabEndFlag(j))
					bGrabComplete = FALSE;
			}
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 210;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;		
	}
	break;
	case 210:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = m_nSeqScanInspGrabCount[nJob];
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 1;  //2point search
			m_pPattern[ncamera].nJob = nJob;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_EdgeIspection, &m_pPattern[ncamera]);
		}
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 330;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 330:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bJudge = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (!m_bFindPattern[ncamera]) bJudge = FALSE;
		}

		/*if(bJudge) g_CommPLC.SetBit(m_nAlignOkWrite[nJob], TRUE);
		else g_CommPLC.SetBit(m_nAlignNgWrite[nJob], TRUE);*/

		if (bJudge)		nRet = 1;
		else nRet = 2;

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	}
	return nRet;
}
#pragma region 필름 검사
BOOL CLET_AlignClientDlg::processFilmInsp(int nJob)
{
	CString str;

	std::vector<int> camBuf = vt_job_info[nJob].camera_index;
	if (camBuf.size() <= 0) return 2;

	int nRet = 0;
	int nCam = 0;
	int real_cam = camBuf.at(0);
	int nPos = 0;

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {
	case 0:	break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

#ifdef _DAHUHA
		AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
		AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
		m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
		ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
		ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif
		
		// 2022-08-23 KBJ
		int ms = MIN(2000, vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmInspGrabDelay());
		Delay(ms);
		
#ifdef _DAHUHA
		if (m_pDahuhaCam[real_cam].isconnected())
#else
		if (m_pBaslerCam[real_cam] || m_pSaperaCam[real_cam].IsOpend())
#endif
			SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, real_cam);
		m_nGrabTimeOutCount[nJob] = 0;

		str.Format("[%s] Grab Start", vt_job_info[nJob].get_job_name());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		if (m_bGrabEnd[real_cam] != TRUE)
			bGrabComplete = FALSE;

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].get_job_name());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);
			
			//HTK 2022-07-11 Film Insp Grab bit & Reset추가
			g_CommPLC.SetBit(m_nInspOkWrite[nJob] + 8, TRUE);
			str.Format("[%s] Grab Complete - Grab Bit On", vt_job_info[nJob].get_job_name());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	break;
	case 300:
	{
		CString strTemp;
		int nPos = 0;
		BOOL bFind = TRUE;

		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;	

		CPaneSimulation* pPane = (CPaneSimulation*)m_pPane[PANE_SIMULATION];
		if (m_bSimulationStart != TRUE || pPane->m_bUseLive == TRUE)
			copyMemory(getProcBuffer(real_cam, 1), getSrcBuffer(real_cam), W * H);

		str.Format("[%s] Find Pattern", vt_job_info[nJob].get_job_name());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		//m_bInspResult[nJob] = algorithm_Film_insp_assemble(getProcBuffer(real_cam, 0), nJob, nCam, NULL);
		m_bInspResult[nJob] = algorithm_PF_Film_insp(getProcBuffer(real_cam, 1), nJob, nCam);

		str.Format("[%s] Find Pattern & Calc Distance", vt_job_info[nJob].get_job_name());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		//KJH 2022-03-12 PF INSP FDC 보고 추가
		if (m_bSimulationStart != TRUE) SendFDCValue_PFINSP(nJob, nCam);

		if (theApp.m_bEnforceOkFlag) m_bInspResult[nJob] = TRUE;

		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		int nview = vt_job_info[nJob].viewer_index[nCam];
		display_PF_Film_insp(getProcBuffer(real_cam, 1), nJob, nCam, &pFormMain->m_pDlgViewerMain[nview]->GetViewer());

		m_bInspResult[nJob] = Exception_Film_Insp_Judge(nJob, &pFormMain->m_pDlgViewerMain[nview]->GetViewer());

		//HTK 2022-07-11 Film Insp Grab bit & Reset추가
		g_CommPLC.SetBit(m_nInspOkWrite[nJob] + 8, FALSE);

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);

		if (m_bInspResult[nJob] > 0)	nRet = 1;
		else							nRet = 2;

		if (theApp.m_bEnforceOkFlag) nRet = 1;
	}
	break;
#pragma region 시뮬레이션 
	case 1000:
	{
		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		copyMemory(getProcBuffer(real_cam, 1), getProcBuffer(real_cam, 0), W* H);
		m_bInspResult[nJob] = algorithm_PF_Film_insp(getProcBuffer(real_cam, 1), nJob, nCam);

		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		int nview = vt_job_info[nJob].viewer_index[nCam];
		display_PF_Film_insp(getProcBuffer(real_cam, 1), nJob, nCam, &pFormMain->m_pDlgViewerMain[nview]->GetViewer());

		m_bInspResult[nJob] = Exception_Film_Insp_Judge(nJob, &pFormMain->m_pDlgViewerMain[nview]->GetViewer());

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);

		if (m_bInspResult[nJob] > 0)	nRet = 1;
		else							nRet = 2;
	}
	break;
#pragma endregion
	}
	return nRet;
}
#pragma endregion
#pragma region 센터 사이드 카메라 검사
BOOL CLET_AlignClientDlg::processNozzleStatusInsp(int nJob)
{
	CString str;

	std::vector<int> camBuf = vt_job_info[nJob].camera_index;
	if (camBuf.size() <= 0) return 2;

	int nRet = 0;
	int nCam = 0;
	int real_cam = camBuf.at(0);
	int nPos = 0;

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) 
	{
	case 0:	break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

#ifdef _DAHUHA
		AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
		AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
		m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
		ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
		ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif
#ifdef _DAHUHA
		if (m_pDahuhaCam[real_cam].isconnected())
#else
		if (m_pBaslerCam[real_cam] || m_pSaperaCam[real_cam].IsOpend())
#endif
			SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, real_cam);
		m_nGrabTimeOutCount[nJob] = 0;

		str.Format("[%s] Grab Start", vt_job_info[nJob].get_job_name());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		if (m_bGrabEnd[real_cam] != TRUE)
			bGrabComplete = FALSE;

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].get_job_name());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[nJob].get_job_name());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	break;
	case 300:
	{
		CString strTemp;
		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		copyMemory(getProcBuffer(real_cam, 0), getSrcBuffer(real_cam), W * H);

		str.Format("[%s] Find Pattern", vt_job_info[nJob].get_job_name());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		int nview = vt_job_info[nJob].viewer_index[nCam];

        CViewerEx *pView = &pFormMain->m_pDlgViewerMain[nview]->GetViewer();

		if (m_nNozzleSideCamMode == 0)
		{
			double dbDistance = pFormMain->fnCalcNozzleGap_Distance(getProcBuffer(real_cam, 0), W, H, nJob, real_cam, 0, pView);
			m_bInspResult[nJob] = fabs(dbDistance) < 0.2 ? FALSE : TRUE;
		}
		else if (m_nNozzleSideCamMode == 1)
		{
			double dbSize = pFormMain->fnCalcNozzleClean_Insp(getProcBuffer(real_cam, 0), W, H, nJob, real_cam, 0, pView);
			m_bInspResult[nJob] = fabs(dbSize) > 0.2 ? FALSE : TRUE;
		}
		else
		{
			double dbCount = pFormMain->fnCalcNozzleDopo_Insp(getProcBuffer(real_cam, 0), W, H, nJob, real_cam, 0, pView);
			m_bInspResult[nJob] = fabs(dbCount) > 0.1 ? FALSE : TRUE;
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);

		if (m_bInspResult[nJob] > 0)	nRet = 1;
		else							nRet = 2;
	}
	break;
	}
	return nRet;
}
#pragma endregion
BOOL CLET_AlignClientDlg::processNozzleAlign(int nJob)
{
	CString str;
	int nRet = 0, ncamera = 0;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;
#endif
	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {
	case 0:
		break;
	case 100:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("Cam %d - Grab Start", ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, ncamera);
			}
		}

		m_nGrabTimeOutCount[nJob] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 210;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;		
	}
	break;
	case 210:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 0;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 1;  //2point search
			m_pPattern[ncamera].nJob = nJob;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 300;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bFind = TRUE;
		int nseq = m_nSeqNozzleGrabCount;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_nSeqNozzleGrabCount > 5) nseq = m_nSeqNozzleGrabCount - 5;
			switch (nseq)
			{
			case 1: // 측면 0번 카메라 , T축 보상
			{
				CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
				int viewer = vt_job_info[nJob].viewer_index[0];

				ncamera = camBuf.at(0);
				int W = m_stCamInfo[ncamera].w;
				int H = m_stCamInfo[ncamera].h;
				m_bFindPattern[ncamera] = pFormMain->InspNozzleSearchAngle_Bee(getProcBuffer(ncamera, 0), W, H, nJob, 0, &pFormMain->m_pDlgViewerMain[viewer]->GetViewer());
				if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getUseDustInsp())
					m_bFindPattern[ncamera] = pFormMain->InspNozzleSearchInspection(getProcBuffer(ncamera, 0), W, H, nJob, 0, &pFormMain->m_pDlgViewerMain[viewer]->GetViewer());

				if (nCam == 0 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
			}
			    break;
			case 2: // 측면 0번 카메라 , Z축 보상 
				if (nCam == 0 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
				break;			
			case 3: // 하부 1번카메라 , Y축 보상
				if (nCam == 1 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
				break;
			case 4: // 정면 2번 카메라 , X축 보상
				if (nCam == 2 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
				break;
			case 5: // 측면 0번 카메라 , Z축 보상 
				if (nCam == 0 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
				break;
			default:
				if ( m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
				break;
			}			
		}	

		if (bFind != TRUE)
		{
			nRet = 2;
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			break;
		}
		else
		{
			double posX = 0.0, refX = 0.0;
			double posY = 0.0, refY = 0.0;
			double worldX[3] = { 0, }, worldY[3] = { 0, };
			double refworldX[3] = { 0, }, refworldY[3] = { 0, };
			CString strTemp;
						
			// 이미지 좌표계 → 실 좌표계
			for (int nCam = 0; nCam < camCount; nCam++)
			{

				ncamera = camBuf.at(nCam);	
				posX = GetMatching(nJob).getFindInfo(nCam, 0).GetXPos();
				posY = GetMatching(nJob).getFindInfo(nCam, 0).GetYPos();

				refX = GetMatching(nJob).getRefX(nCam, 0);
				refY = GetMatching(nJob).getRefY(nCam, 0);

				strTemp.Format("[Cam %d] X : %.1f, Y : %.1f, - Ref_X : %.1f, Ref_Y : %.1f", ncamera + 1, posX, posY, refX, refY);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
				
				//KJH 2021-12-14 Nozzle Align Log 추가
				theLog.logmsg(LOG_INSPECTOR, strTemp); //20211006 Tkyuha 로그 위치 변경

				// 일단은 같은 좌표계에서 불러 오도록
				GetMachine(nJob).PixelToWorld(nCam, 0, posX, posY, &worldX[nCam], &worldY[nCam]);	
				GetMachine(nJob).PixelToWorld(nCam, 0, refX, refY, &refworldX[nCam], &refworldY[nCam]);

				worldX[nCam] -= refworldX[nCam];
				worldY[nCam] -= refworldY[nCam];
			}			

			// 정면 카메라 UP/Down 상태 확인 : 2번
			// 측면 카메라 Left/Right 상태 확인  : 0번
			// 하면 카메라 기울기  : 1번
			//X축 하면 카메라(1번)		좌측 우측(X방향)
			//Y축 사이드 카메라(0번))	좌측 우측(X방향)
			//Z축 정면 카메라(2번)		위 아래  (Y방향)			

			if (m_nSeqNozzleGrabCount > 5) nseq = m_nSeqNozzleGrabCount - 5;
			switch (nseq)
			{
			case 1: // 측면 0번 카메라 , T축 보상
			{
				double _angle = vt_job_info[nJob].model_info.getAlignInfo().getIncludedAngleLimit();
				m_dbRevisionData[nJob][AXIS_X] = 0;
				m_dbRevisionData[nJob][AXIS_Y] = 0;
				m_dbRevisionData[nJob][AXIS_Z] = 0;
				if(_angle == 0)	m_dbRevisionData[nJob][AXIS_T] = 0;
				else m_dbRevisionData[nJob][AXIS_T] = _angle - m_dNozzleCurrentAngle; //임시 사용 
			}
				break;
			case 2: // 측면 0번 카메라 , z축 보상 
				if (vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseT())		worldY[0] *= -1;
				m_dbRevisionData[nJob][AXIS_X] = 0;
				m_dbRevisionData[nJob][AXIS_Y] = 0;	
				m_dbRevisionData[nJob][AXIS_T] = 0;
				m_dbRevisionData[nJob][AXIS_Z] = worldY[0];
				break;
			case 3: // 하부 1번 카메라 , Y축 보상
				if (vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseY())	   	worldY[1] *= -1;
				m_dbRevisionData[nJob][AXIS_X] = 0;
				m_dbRevisionData[nJob][AXIS_Y] = worldY[1];
				m_dbRevisionData[nJob][AXIS_T] = 0;
				m_dbRevisionData[nJob][AXIS_Z] = 0;
				break;
			case 4: // 정면 2번카메라 , X축 보상
				if (vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseX())
				{
					worldX[1] *= -1;
					worldX[2] *= -1;
				}
				//KJH 2021-12-10 X좌표 흔들림에 의한 편차로 X보정값 적은 값으로 선택적 보상개념 도입
				if (worldX[2] < worldX[1])
				{
					m_dbRevisionData[nJob][AXIS_X] = worldX[2];
				}
				else
				{
					m_dbRevisionData[nJob][AXIS_X] = worldX[1];
				}
				m_dbRevisionData[nJob][AXIS_Y] = 0;
				m_dbRevisionData[nJob][AXIS_T] = 0;
				m_dbRevisionData[nJob][AXIS_Z] = 0;
				break;	
			case 5: // 측면 0번 카메라 , Z축 보상
				if (vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseT())		worldY[0] *= -1;
				m_dbRevisionData[nJob][AXIS_X] = 0;
				m_dbRevisionData[nJob][AXIS_Y] = 0;
				m_dbRevisionData[nJob][AXIS_T] = 0;
				m_dbRevisionData[nJob][AXIS_Z] = worldY[0];
				break;
			default:
				m_dbRevisionData[nJob][AXIS_X] = worldX[2];
				m_dbRevisionData[nJob][AXIS_Y] = worldY[1];
				m_dbRevisionData[nJob][AXIS_T] = 0;
				m_dbRevisionData[nJob][AXIS_Z] = worldY[0];
				break;
			}			
			
			if (nseq !=1)	m_dbRevisionData[nJob][AXIS_T] = 0;
			// GetMatching(nJob).getHalcon(0, 0, 0).halcon_GetResultAngle();
			GetPrealign(nJob).setRevisionX(m_dbRevisionData[nJob][AXIS_X]);
			GetPrealign(nJob).setRevisionY(m_dbRevisionData[nJob][AXIS_Y]);
			GetPrealign(nJob).setRevisionT(m_dbRevisionData[nJob][AXIS_T]);
			GetPrealign(nJob).setRevisionZ(m_dbRevisionData[nJob][AXIS_Z]);
			
			// kbj 2021-12-27 NozzleAlign 시뮬레이션이면 보정량 보내지 않도록 추가.
			if(m_bSimulationStart != TRUE)
				sendRevisionNozzleData(GetPrealign(nJob).getRevisionX(), GetPrealign(nJob).getRevisionY(), GetPrealign(nJob).getRevisionT(), GetPrealign(nJob).getRevisionZ(), nJob);
			
			strTemp.Format("[Nozzle] X : %.4f, Y : %.4f, T : %.4f, Z : %.4f", m_dbRevisionData[nJob][AXIS_X], m_dbRevisionData[nJob][AXIS_Y], m_dbRevisionData[nJob][AXIS_T], m_dbRevisionData[nJob][AXIS_Z]);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
			theLog.logmsg(LOG_INSPECTOR, strTemp); //20211006 Tkyuha 로그 위치 변경

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 1;
		}
	}
	break;
	}
	return nRet;
}
//Tkyuha 20211205 노즐 카메라와 센터 카메라를 이용한 얼라인 계산
BOOL CLET_AlignClientDlg::processCenterNozzleAlign(int nJob)
{
	CString str;
	int nRet = 0, ncamera = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	AcquireSRWLockExclusive(&g_srwlock); 
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		//KJH 2021-05-29 Grab전 조명 ON
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			LightControllerTurnOnOff(nJob, nCam, 0);
		}

		str.Format("[%s] - Light On", vt_job_info[nJob].job_name.c_str());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("Cam %d - Grab Start", ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, ncamera);
			}
		}

		m_nGrabTimeOutCount[nJob] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 210;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;
	}
	break;
	case 210:
	{
		bool _calcMethod = vt_job_info[nJob].model_info.getInspSpecParaInfo().getCenterNozzleAlignMethod();

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 0;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 1;  //2point search
			m_pPattern[ncamera].nJob = nJob;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			if(_calcMethod) AfxBeginThread(Thread_FindNozzlePattern, &m_pPattern[ncamera]); // 직선 성분을 이용한 노즐 끝단 찾기
			else AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);        // 기존 방법을 이용한 얼라인			
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 300;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE)
		{
			// hsj 2022-02-14
			m_dbRevisionData[nJob][AXIS_X] = 0;
			m_dbRevisionData[nJob][AXIS_Y] = 0;
			m_dbRevisionData[nJob][AXIS_T] = 0;
			m_dbRevisionData[nJob][AXIS_Z] = 0;

			break;
		}
		
		BOOL bFind = TRUE;
		int nseq = m_nSeqNozzleGrabCount;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			//KJH 2022-05-05 Nozzle XYZ 검사 기능 추가
			//if (m_nSeqNozzleGrabCount > 4) nseq = m_nSeqNozzleGrabCount - 4;
			switch (nseq)
			{
			case 1: // 측면 0번 카메라 , T축 보상
			{
				CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
				int viewer = vt_job_info[nJob].viewer_index[0];

				ncamera = camBuf.at(0);
				int W = m_stCamInfo[ncamera].w;
				int H = m_stCamInfo[ncamera].h;
				m_bFindPattern[ncamera] = pFormMain->InspNozzleSearchAngle_Bee(getProcBuffer(ncamera, 0), W, H, nJob, 0, &pFormMain->m_pDlgViewerMain[viewer]->GetViewer());
				if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getUseDustInsp())
					m_bFindPattern[ncamera] = pFormMain->InspNozzleSearchInspection(getProcBuffer(ncamera, 0), W, H, nJob, 0, &pFormMain->m_pDlgViewerMain[viewer]->GetViewer());

				if (nCam == 0 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
			}
			break;
			case 2: // 측면 0번 카메라 , Z축 보상 
				if (nCam == 0 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
				break;
			case 3: // 하부 1번카메라 , XY축 보상
				if (nCam == 1 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
				break;
			case 4: // 측면 0번 카메라 , Z축 보상 
				if (nCam == 0 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
				break;
			//KJH 2022-05-05 Nozzle XYZ 검사 기능 추가
			//case 96: // Nozzle Inspection 
			//	if (nCam == 1) copyMemory(getProcBuffer(ncamera, 0), getSrcBuffer(ncamera), m_stCamInfo[ncamera].w * m_stCamInfo[ncamera].h);
			//	if (nCam == 1 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
			//	break;
			default:
				//KJH 2022-05-05 Nozzle XYZ 검사 기능 추가
				CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
				int viewer = vt_job_info[nJob].viewer_index[0];

				ncamera = camBuf.at(0);
				int W = m_stCamInfo[ncamera].w;
				int H = m_stCamInfo[ncamera].h;
				BOOL m_bFindAngle = TRUE;

				m_bFindAngle = pFormMain->InspNozzleSearchAngle_Bee(getProcBuffer(ncamera, 0), W, H, nJob, 0, &pFormMain->m_pDlgViewerMain[viewer]->GetViewer());
				if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getUseDustInsp())
					m_bFindPattern[ncamera] = pFormMain->InspNozzleSearchInspection(getProcBuffer(ncamera, 0), W, H, nJob, 0, &pFormMain->m_pDlgViewerMain[viewer]->GetViewer());

				if (nCam == 0 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
				if (nCam == 1 && m_bFindPattern[ncamera] != TRUE)		bFind = FALSE;
				if (nCam == 0 && m_bFindAngle != TRUE)					bFind = FALSE;
				break;
			}
		}

		if (bFind != TRUE)
		{
			nRet = 2;

			// hsj 2022-02-14
			m_dbRevisionData[nJob][AXIS_X] = 0;
			m_dbRevisionData[nJob][AXIS_Y] = 0;
			m_dbRevisionData[nJob][AXIS_T] = 0;
			m_dbRevisionData[nJob][AXIS_Z] = 0;

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);

			//KJH 2022-05-31 Nozzle Align , XYZ Insp NG시 Word에 0쓰기

			GetPrealign(nJob).setRevisionX(m_dbRevisionData[nJob][AXIS_X]);
			GetPrealign(nJob).setRevisionY(m_dbRevisionData[nJob][AXIS_Y]);
			GetPrealign(nJob).setRevisionT(m_dbRevisionData[nJob][AXIS_T]);
			GetPrealign(nJob).setRevisionZ(m_dbRevisionData[nJob][AXIS_Z]);

			if (m_bSimulationStart != TRUE)
				sendRevisionNozzleData(GetPrealign(nJob).getRevisionX(), GetPrealign(nJob).getRevisionY(), GetPrealign(nJob).getRevisionT(), GetPrealign(nJob).getRevisionZ(), nJob);
			
			CString strTemp;
			strTemp.Format("[%s] Find Mark NG / Send Data Zero ", vt_job_info[nJob].get_job_name());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
			theLog.logmsg(LOG_INSPECTOR, strTemp);
			break;
		}
		else
		{
			double posX = 0.0, refX = 0.0;
			double posY = 0.0, refY = 0.0;
			double worldX[3] = { 0, }, worldY[3] = { 0, };
			double refworldX[3] = { 0, }, refworldY[3] = { 0, };
			CString strTemp;

			if (m_nSeqNozzleGrabCount == 100)		nseq = 0;
			else if (m_nSeqNozzleGrabCount > 4)		nseq = m_nSeqNozzleGrabCount - 4;

			//Tkyuha 2022-06-17 Nozzle XY 검사중 다시 한번 Y만 정밀 Search , 검증후 적용 예정
			bool _recalc = vt_job_info[nJob].model_info.getInspSpecParaInfo().getCenterNozzleYAlignRecalc();
			if (nseq == 3 && _recalc)
			{
				ncamera = camBuf.at(1);
				posX = GetMatching(nJob).getFindInfo(1, 0).GetXPos();
				posY = GetMatching(nJob).getFindInfo(1, 0).GetYPos();
				// KBJ 2022-09-16
				//double rv = reCalculateMarkYpos(getProcBuffer(ncamera, 0), m_stCamInfo[ncamera].w, m_stCamInfo[ncamera].h, posX, posY);
				double rv = reCalculateMarkZGapYpos2(getProcBuffer(ncamera, 0), m_stCamInfo[ncamera].w, m_stCamInfo[ncamera].h, posX, posY);
				if (rv > 0 && fabs(rv-posY)>2.0)  GetMatching(nJob).getFindInfo(1, 0).SetYPos(rv);
			}

			// KBJ 2022-12-06 Side Nozzle Z Align Recalc
			bool _recalc_z = vt_job_info[nJob].model_info.getInspSpecParaInfo().getSideNozzleZAlignRecalc();
			if ((nseq == 2 && _recalc_z) || (nseq == 4 && _recalc))
			{
				int real_cam = camBuf.at(0);

				int W = m_stCamInfo[real_cam].w;
				int H = m_stCamInfo[real_cam].h;

				double posX = GetMatching(nJob).getFindInfo(0, 0).GetXPos();
				double posY = GetMatching(nJob).getFindInfo(0, 0).GetYPos();
				if (GetMatching(nJob).getFindInfo(0, 0).getScore() >= 50.0)
				{
					reCalculateMarkZGapYpos3(nJob, getProcBuffer(ncamera, 1), W, H, &posX, &posY);
					GetMatching(nJob).getFindInfo(0, 0).SetXPos(posX);
					GetMatching(nJob).getFindInfo(0, 0).SetYPos(posY);
				}
			}

			//KJH 2022-05-05 Nozzle XYZ 검사 기능 추가 Pos 같은거 사용해야함
			//int _nNozzleSelectPos = m_nSeqNozzleGrabCount == 100 ? 1 : 0;
			int _nNozzleSelectPos = 0;
			// 이미지 좌표계 → 실 좌표계
			for (int nCam = 0; nCam < camCount; nCam++)
			{
				ncamera = camBuf.at(nCam);
				posX = GetMatching(nJob).getFindInfo(nCam, _nNozzleSelectPos).GetXPos();
				posY = GetMatching(nJob).getFindInfo(nCam, _nNozzleSelectPos).GetYPos();

				refX = GetMatching(nJob).getRefX(nCam, _nNozzleSelectPos);
				refY = GetMatching(nJob).getRefY(nCam, _nNozzleSelectPos);

				strTemp.Format("[%s][Cam %d] X : %.1f, Y : %.1f, - Ref_X : %.1f, Ref_Y : %.1f", vt_job_info[nJob].get_job_name(), ncamera + 1, posX, posY, refX, refY);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

				//KJH 2021-12-14 Nozzle Align Log 추가
				theLog.logmsg(LOG_INSPECTOR, strTemp); //20211006 Tkyuha 로그 위치 변경

				// 일단은 같은 좌표계에서 불러 오도록
				GetMachine(nJob).PixelToWorld(nCam, 0, posX, posY, &worldX[nCam], &worldY[nCam]);
				GetMachine(nJob).PixelToWorld(nCam, 0, refX, refY, &refworldX[nCam], &refworldY[nCam]);

				worldX[nCam] -= refworldX[nCam];
				worldY[nCam] -= refworldY[nCam];
			}

			CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
			// 측면 카메라 기울기, Z축 상태 확인	: 0번
			// 상면 카메라 XY축 상태 확인			: 1번
			
			switch (nseq)
			{
			case 1: // 측면 0번 카메라 , T축 보상
			{
				double _angle = vt_job_info[nJob].model_info.getAlignInfo().getIncludedAngleLimit();
				m_dbRevisionData[nJob][AXIS_X] = 0;
				m_dbRevisionData[nJob][AXIS_Y] = 0;
				m_dbRevisionData[nJob][AXIS_Z] = 0;
				if (_angle == 0)	m_dbRevisionData[nJob][AXIS_T] = 0;
				else m_dbRevisionData[nJob][AXIS_T] = _angle - m_dNozzleCurrentAngle; //임시 사용 

				pFormMain->HideErrorMessageBlink();
			}
			break;
			case 2: // 측면 0번 카메라 , Z축 보상 
				if (vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseT())		worldY[0] *= -1;
				m_dbRevisionData[nJob][AXIS_X] = 0;
				m_dbRevisionData[nJob][AXIS_Y] = 0;
				m_dbRevisionData[nJob][AXIS_T] = 0;
				m_dbRevisionData[nJob][AXIS_Z] = worldY[0];
				break;
			case 3: // 하부 1번 카메라 , XY축 보상
				if (vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseX())	   	worldX[1] *= -1;
				if (vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseY())	   	worldY[1] *= -1;
				m_dbRevisionData[nJob][AXIS_X] = worldX[1];
				m_dbRevisionData[nJob][AXIS_Y] = worldY[1];
				m_dbRevisionData[nJob][AXIS_T] = 0;
				m_dbRevisionData[nJob][AXIS_Z] = 0;
				break;
			case 4: // 측면 0번 카메라 , Z축 보상
				if (vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseT())		worldY[0] *= -1;
				m_dbRevisionData[nJob][AXIS_X] = 0;
				m_dbRevisionData[nJob][AXIS_Y] = 0;
				m_dbRevisionData[nJob][AXIS_T] = 0;
				m_dbRevisionData[nJob][AXIS_Z] = worldY[0];
				m_nNozzleAlignCount++;
				break;
			default:
				//KJH 2022-05-05 Nozzle XYZ 검사 기능 추가
				//nSeq = 0일때 XYZT 값 보고

				m_dbRevisionData[nJob][AXIS_X] = worldX[1];
				m_dbRevisionData[nJob][AXIS_Y] = worldY[1];
				m_dbRevisionData[nJob][AXIS_T] = m_dNozzleCurrentAngle;
				m_dbRevisionData[nJob][AXIS_Z] = worldY[0];
				break;
			}

			if (nseq == 4 && m_nNozzleAlignCount>2) // Ref 위치와 Align Pixel 좌표를 비교 해서 1.5 Pixel 이내 인경우만 정상 동작으로 판단 하도록 예외처리
			{
				double diff_z = fabs(GetMatching(nJob).getFindInfo(0, 0).GetYPos() - GetMatching(nJob).getRefY(0, 0));
				double diff_x = fabs(GetMatching(nJob).getFindInfo(1, 0).GetXPos() - GetMatching(nJob).getRefX(1, 0));
				double diff_y = fabs(GetMatching(nJob).getFindInfo(1, 0).GetYPos() - GetMatching(nJob).getRefY(1, 0));

				if (diff_z >= 2 || diff_x >= 2 || diff_y >= 2)
				{					
					strTemp.Format("[%s] X : %.1f, Y : %.1f, Z : %.1f \n Clean the Nozzle And Retry Align !!", vt_job_info[nJob].get_job_name(), diff_x, diff_y, diff_z);
					pFormMain->ShowErrorMessageBlink(strTemp);

					AcquireSRWLockExclusive(&g_srwlock); 
					m_nSeqProcess[nJob] = 0;
					ReleaseSRWLockExclusive(&g_srwlock);
					nRet = 2;
					break;
				}
			}

			//if (m_nSeqNozzleGrabCount == 100 || nseq == 4 && m_nNozzleAlignCount > 3) // 얼라인이 16회 라는 가정에서 수행 // Tkyuha 20220422 얼라인 완료후 카메라 Exposure 원복 하기 위함
			//KJH 2022-05-14 Nozzle XYZ Insp 추가로 검사 후 Center Align ExposureTime으로 변경
			if (m_nSeqNozzleGrabCount == 100)
			{
				ncamera = vt_job_info[0].camera_index[0];
				int nExpousure = vt_job_info[0].model_info.getMachineInfo().getExposureTime(ncamera);
#ifdef _DAHUHA
				if (m_pDahuhaCam[ncamera].isconnected())		m_pDahuhaCam[ncamera].setExposureTime(nExpousure);
#else
				if (m_pBaslerCam[ncamera])						m_pBaslerCam[ncamera]->SetExposure(nExpousure);
#endif
			}

			//if (nseq != 1)	m_dbRevisionData[nJob][AXIS_T] = 0;
			//GetMatching(nJob).getHalcon(0, 0, 0).halcon_GetResultAngle();
			GetPrealign(nJob).setRevisionX(m_dbRevisionData[nJob][AXIS_X]);
			GetPrealign(nJob).setRevisionY(m_dbRevisionData[nJob][AXIS_Y]);
			GetPrealign(nJob).setRevisionT(m_dbRevisionData[nJob][AXIS_T]);
			GetPrealign(nJob).setRevisionZ(m_dbRevisionData[nJob][AXIS_Z]);

			// kbj 2021-12-27 NozzleAlign 시뮬레이션이면 보정량 보내지 않도록 추가.
			if (m_bSimulationStart != TRUE)
				sendRevisionNozzleData(GetPrealign(nJob).getRevisionX(), GetPrealign(nJob).getRevisionY(), GetPrealign(nJob).getRevisionT(), GetPrealign(nJob).getRevisionZ(), nJob);

			strTemp.Format("[%s] X : %.4f, Y : %.4f, Z : %.4f, T : %.4f", vt_job_info[nJob].get_job_name(), m_dbRevisionData[nJob][AXIS_X], m_dbRevisionData[nJob][AXIS_Y], m_dbRevisionData[nJob][AXIS_Z], m_dbRevisionData[nJob][AXIS_T]);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
			theLog.logmsg(LOG_INSPECTOR, strTemp); //20211006 Tkyuha 로그 위치 변경

			//KJH 2022-05-19 XYZ 검사시 Spec 판정하기
			if (m_nSeqNozzleGrabCount == 100)
			{
				double NozzleSpec_Z_Min		= vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(7);
				double NozzleSpec_Z_Max		= vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(7);
				double NozzleSpec_XY_Min	= vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(8);;
				double NozzleSpec_XY_Max	= vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(8);

				if (GetPrealign(nJob).getRevisionX() < NozzleSpec_XY_Min || GetPrealign(nJob).getRevisionX() > NozzleSpec_XY_Max)
				{
					strTemp.Format("[%s] Nozzle XYZ Insp - X Spec Over", vt_job_info[nJob].get_job_name());
					pFormMain->ShowErrorMessageBlink(strTemp);

					AcquireSRWLockExclusive(&g_srwlock);
					m_nSeqProcess[nJob] = 0;
					ReleaseSRWLockExclusive(&g_srwlock);

					nRet = 2;
					break;
				}
				else if(GetPrealign(nJob).getRevisionY() < NozzleSpec_XY_Min || GetPrealign(nJob).getRevisionY() > NozzleSpec_XY_Max)
				{
					strTemp.Format("[%s] Nozzle XYZ Insp - Y Spec Over", vt_job_info[nJob].get_job_name());
					pFormMain->ShowErrorMessageBlink(strTemp);

					AcquireSRWLockExclusive(&g_srwlock);
					m_nSeqProcess[nJob] = 0;
					ReleaseSRWLockExclusive(&g_srwlock);

					nRet = 2;
					break;
				}
				else if (GetPrealign(nJob).getRevisionZ() < NozzleSpec_Z_Min || GetPrealign(nJob).getRevisionZ() > NozzleSpec_Z_Max)
				{
					strTemp.Format("[%s] Nozzle XYZ Insp - Z Spec Over", vt_job_info[nJob].get_job_name());
					pFormMain->ShowErrorMessageBlink(strTemp);

					AcquireSRWLockExclusive(&g_srwlock);
					m_nSeqProcess[nJob] = 0;
					ReleaseSRWLockExclusive(&g_srwlock);

					nRet = 2;
					break;
				}
			}
			
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			
			nRet = 1;
		}
	}
	break;
	}
	return nRet;
}
//Tkyuha 20211205 측면 카메라를 이용한 스테이지와 노즐 사이 갭측정
BOOL CLET_AlignClientDlg::processCenterNozzleGapMeasure(int nJob)
{
	CString str;
	int nRet = 0, ncamera = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	AcquireSRWLockExclusive(&g_srwlock);
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) 
	{
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		//KJH 2021-05-29 Grab전 조명 ON
		int n = 0;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			LightControllerTurnOnOff(nJob, nCam, 0);

			//for (int nLight = 0; nLight < vt_job_info[nJob].light_info[n].num_of_using_light; nLight++)
			//{
			//	int ctrl = vt_job_info[nJob].light_info[n].controller_id[nLight] - 1;
			//	int ch = vt_job_info[nJob].light_info[n].channel_id[nLight];
			//	int value = vt_job_info[nJob].model_info.getLightInfo().getLightBright(nCam, nLight, 0);
			//	if (m_stLightCtrlInfo.nType[0] == LTYPE_LLIGHT_LPC_COT_232)		SetLightBright(ctrl, ch, value == 0 ? 0 : value * 10);   // dh.jung 2021-07-12
			//	else															SetLightBright(ctrl, ch, value);
			//	Delay(50);
			//}
		}

		str.Format("[%s] - Light On", vt_job_info[nJob].job_name.c_str());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[ncamera] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[ncamera].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[ncamera]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[ncamera].isconnected())
#else 
			if (m_pBaslerCam[ncamera] || m_pSaperaCam[ncamera].IsOpend())
#endif
			{
				str.Format("Cam %d - Grab Start", ncamera + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, ncamera);
			}
		}

		m_nGrabTimeOutCount[nJob] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bGrabEnd[ncamera] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 210;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;
	}
	break;
	case 210:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			m_pPattern[ncamera].pDlg = this;
			m_pPattern[ncamera].nPos = 0;
			m_pPattern[ncamera].nCam = nCam;
			m_pPattern[ncamera].nSearchCount = 1;  //2point search
			m_pPattern[ncamera].nJob = nJob;

			m_bFindPatternEnd[ncamera] = FALSE;
			m_bFindPattern[ncamera] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[ncamera]);
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 300;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPatternEnd[ncamera] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			ncamera = camBuf.at(nCam);
			if (m_bFindPattern[ncamera] != TRUE)
				bFind = FALSE;
		}

		if (bFind != TRUE)
		{
			nRet = 2;
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			break;
		}
		else
		{
			double posX = 0.0;
			double posY = 0.0;
			double worldX, worldY;
			double worldX_CX, worldY_CY;
			
			ncamera = camBuf.at(0);
			int W = m_stCamInfo[ncamera].w;
			int H = m_stCamInfo[ncamera].h;
			int cx = W / 2;
			int cy = H / 2;
			
			CString strTemp;

			int nCam = 0, nPos = 0;
			posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
			posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

			strTemp.Format("[%s][Cam %d] Y : %.1f ", vt_job_info[nJob].get_job_name(), ncamera + 1, posY);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
			theLog.logmsg(LOG_INSPECTOR, strTemp);

			// 일단은 같은 좌표계에서 불러 오도록
			GetMachine(nJob).PixelToWorld(nCam, 0, posX, posY, &worldX, &worldY, TRUE);
			GetMachine(nJob).PixelToWorld(nCam, 0, cx, cy, &worldX_CX, &worldY_CY, TRUE);

			worldX -= worldX_CX;
			worldY -= worldY_CY;

			if (vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseY())	   worldY *= -1;

			m_dbRevisionData[nJob][AXIS_X] = 0;
			m_dbRevisionData[nJob][AXIS_Y] = 0;
			m_dbRevisionData[nJob][AXIS_T] = 0;
			m_dbRevisionData[nJob][AXIS_Z] = worldY;

			GetPrealign(nJob).setRevisionX(m_dbRevisionData[nJob][AXIS_X]);
			GetPrealign(nJob).setRevisionY(m_dbRevisionData[nJob][AXIS_Y]);
			GetPrealign(nJob).setRevisionT(m_dbRevisionData[nJob][AXIS_T]);
			GetPrealign(nJob).setRevisionZ(m_dbRevisionData[nJob][AXIS_Z]);

			sendRevisionData(GetPrealign(nJob).getRevisionX(), GetPrealign(nJob).getRevisionY(), GetPrealign(nJob).getRevisionT(), nJob);
			// Matching Rate 전송
			//sendMatchingRateData(nJob);

			strTemp.Format("[%s] Send Revision Data - Y : %.4f", vt_job_info[nJob].get_job_name(), m_dbRevisionData[nJob][AXIS_Y]);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
			theLog.logmsg(LOG_INSPECTOR, strTemp);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 1;
		}
	}
	}
	return nRet;
}

//HTK 2022-07-12 Nozzel#45에 약액상태 검사 추가
BOOL CLET_AlignClientDlg::processViewerSubInspection(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0,nInspCount=0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	AcquireSRWLockExclusive(&g_srwlock);
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	switch (_sequence)
	{
	case 0:
		break;
	case 100:
	{
		bool enable = vt_job_info[nJob].model_info.getInspSpecParaInfo().get45DegreeInkInspEnable();
		if (!enable)
		{
			nRet = 1;
			break;
		}

		//TKHA 2022-07-11 
		g_CommPLC.SetBit(m_nInspOkWrite[nJob]+54, FALSE);
		g_CommPLC.SetBit(m_nInspOkWrite[nJob]+55, FALSE);

		pFormMain->HideErrorMessageBlink();
		pFormMain->read_glass_id(nJob);
		pFormMain->reset_viewer(nJob);
		pFormMain->SendMessageA(WM_VIEW_CONTROL, MSG_FMV_GLASSID_UPDATE, nJob);

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 110;
		ReleaseSRWLockExclusive(&g_srwlock);

		int grabdelay = vt_job_info[nJob].model_info.getInspSpecParaInfo().get45DegreenStartDelay();  // Grab Dealy 추가 항목 22.07.06 Tkyuha
		Delay(grabdelay);

		str.Format("[%s] 45Degree Inspection", vt_job_info[nJob].job_name.c_str());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		nInspCount = 0;
	}
	break;
	case 110:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif
		}

		m_nGrabTimeOutCount[nJob] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bGrabEnd[real_cam] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 210;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;
	}
	break;
	case 210:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			m_pPattern[real_cam].pDlg = this;
			m_pPattern[real_cam].nPos = 0;
			m_pPattern[real_cam].nCam = nCam;
			m_pPattern[real_cam].nSearchCount = 1;  //2point search
			m_pPattern[real_cam].nJob = nJob;

			m_bFindPatternEnd[real_cam] = FALSE;
			m_bFindPattern[real_cam] = TRUE;

			AfxBeginThread(Thread_Ink_45CamInspection, &m_pPattern[real_cam]);
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 300;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPatternEnd[real_cam] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPattern[real_cam] != TRUE)
				bFind = FALSE;
		}

		int viewer = vt_job_info[nJob].viewer_index[0];
		nInspCount++;
 		if (bFind != TRUE)
		{
			nRet = 2; 
			nInspCount = 0;
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);

			str.Format("[%s] Ink Check !!!", vt_job_info[nJob].job_name.c_str());

			//TKHA 2022-07-11 
			g_CommPLC.SetBit(m_nInspOkWrite[nJob] + 55, TRUE);
			
			pFormMain->ShowErrorMessageBlink(str);
			pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(FALSE);
			break;
		}
		else
		{
			pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);		
			
			if (nInspCount >= 2)
			{
				nInspCount = 0;
				nRet = 1;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				//TKHA 2022-07-11 
				g_CommPLC.SetBit(m_nInspOkWrite[nJob]+54, TRUE);
				pFormMain->resetProcessStart(nJob);
				str.Format("[%s] 45Degree Inspection End ", vt_job_info[nJob].job_name.c_str());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			}
			else
			{
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 110;
				ReleaseSRWLockExclusive(&g_srwlock);

				int grabdelay = vt_job_info[nJob].model_info.getInspSpecParaInfo().get45DegreenIntervalDelay();  // Grab Dealy 추가 항목 22.07.06 Tkyuha
				Delay(grabdelay);
			}
		}
	}
	break;
	}

	return nRet;
}

BOOL CLET_AlignClientDlg::simulration_2cam_2shot_align(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;


	// 알고리즘 시작.
	for (int nPos = 0; nPos < 2; nPos++)
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			m_pPattern[real_cam].pDlg = this;
			m_pPattern[real_cam].nPos = nPos;
			m_pPattern[real_cam].nCam = nCam;
			m_pPattern[real_cam].nSearchCount = 1;
			m_pPattern[real_cam].nJob = nJob;

			m_bFindAlignPatternEnd[real_cam][nPos] = FALSE;
			m_bFindAlignPattern[real_cam][nPos] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);

			Delay(50);
		}
	}

	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	int MS_TIMEOUT = 10000;

	BOOL all_insp_end = TRUE;
	while (nEtick - nStick <= MS_TIMEOUT) {
		Sleep(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_insp_end = TRUE;
		for (int nPos = 0; nPos < m_nSeqTotalInspGrabCount; nPos++)
		{
			for (int nCam = 0; nCam < camCount; nCam++)
			{
				int real_cam = vt_job_info[nJob].camera_index[nCam];

				if (m_bFindAlignPatternEnd[real_cam][nPos] != TRUE)
					all_insp_end = FALSE;
			}
		}

		if (all_insp_end == TRUE) break;

		if (nEtick - nStick == MS_TIMEOUT)
		{
			str.Format("TimeOut(ms : %d) ", MS_TIMEOUT);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}

	if (all_insp_end != TRUE) return FALSE;


	BOOL bAllFind = TRUE;
	for (int nPos = 0; nPos < m_nSeqTotalInspGrabCount; nPos++)
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];

			if (m_bFindAlignPattern[real_cam][nPos] != TRUE)
				bAllFind = FALSE;
		}
	}

	return bAllFind;
}

//Default 4CAM에서 패턴매칭 각 1개씩 4개
int CLET_AlignClientDlg::ProcessPrealign_4Cam_4Align(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;

	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {
	case 0:
		break;
	case 100:
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[real_cam].isconnected())
#else
			if (m_pBaslerCam[real_cam] || m_pSaperaCam[real_cam].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[nJob].job_name.c_str(), nCam + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				Camera_Grab(real_cam);
				//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, real_cam);
			}
		}

		m_nGrabTimeOutCount[nJob] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bGrabEnd[real_cam] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);

			str.Format("[%s] Grab Complete", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			m_pPattern[real_cam].pDlg = this;
			m_pPattern[real_cam].nPos = 0;
			m_pPattern[real_cam].nCam = nCam;
			m_pPattern[real_cam].nSearchCount = 1;
			m_pPattern[real_cam].nJob = nJob;

			m_bFindPatternEnd[real_cam] = FALSE;
			m_bFindPattern[real_cam] = TRUE;

			AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);
		}
	}
	break;
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPatternEnd[real_cam] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPattern[real_cam] != TRUE)	bFind = FALSE;
			else
			{
				vt_result_info[nJob].each_Judge[nCam][0] = TRUE;
			}
		}

		if (bFind != TRUE)
		{
			//KJH 2022-03-10 L-Check Error일 경우에도 Manual Mark 가능하게 변경
			//JSH 2022-03-16 진입 조건에서 L-Check 삭제
			if (vt_job_info[nJob].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge() )
			{
				str.Format("[%s] Manual Mark Input - %d - %d", vt_job_info[nJob].job_name.c_str(), m_bFindPattern[camBuf[0]], m_bFindPattern[camBuf[1]]);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK, MAKELPARAM(nJob, TRUE));
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 400;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			else
			{
				nRet = 2;
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			break;
		}	
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 350;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 350:
	{
		CString strTemp;

		double posX[2] = { 0.0, };
		double posY[2] = { 0.0, };
		double worldX[2], worldY[2];

		int nPos = 0;
		int nCamT = 0, nCamB = 0;

		// 마크 순서
		// 1		0
		// 3		2

		// 0과 1 마크의 평균을 왼쪽 마크 정보로 하고,
		// 2와 3 마크의 평균을 오른쪽 마크 정보로 하여 보정량을 계산한다.

		/*
		for (int i = 0; i < 2; i++)
		{
			nCamT = camBuf.at(2*i);
			nCamB = camBuf.at(2*i+1);

			posX[0] = GetMatching().getFindInfo(nCamT, nPos).GetXPos();
			posY[0] = GetMatching().getFindInfo(nCamT, nPos).GetYPos();

			posX[1] = GetMatching().getFindInfo(nCamB, nPos).GetXPos();
			posY[1] = GetMatching().getFindInfo(nCamB, nPos).GetYPos();

			GetMachine().PixelToWorld(nCamT, posX[0], posY[0], &worldX[0], &worldY[0]);
			GetMachine().PixelToWorld(nCamB, posX[1], posY[1], &worldX[1], &worldY[1]);

			GetPrealign(algorithm).setPosX(nCamT, worldX[0]);
			GetPrealign(algorithm).setPosY(nCamT, worldY[0]);
			GetPrealign(algorithm).setPosX(nCamB,  worldX[1]);
			GetPrealign(algorithm).setPosY(nCamB,  worldY[1]);

			GetPrealign(algorithm).setRotateX(nCamT, GetMachine().getRotateX(nCamT));
			GetPrealign(algorithm).setRotateY(nCamT, GetMachine().getRotateY(nCamT));
			GetPrealign(algorithm).setRotateX(nCamB, GetMachine().getRotateX(nCamB));
			GetPrealign(algorithm).setRotateY(nCamB, GetMachine().getRotateY(nCamB));
		}
		*/

		/*
		int cam = 0;
		double posX = 0.0;
		double posY = 0.0;
		double worldX, worldY;

		for (int nCam = 0; nCam < camCount; nCam++)
		{

			cam = camBuf.at(nCam);

			posX = GetMatching().getFindInfo(cam, nPos).GetXPos();
			posY = GetMatching().getFindInfo(cam, nPos).GetYPos();

			GetMachine().PixelToWorld(cam, posX, posY, &worldX, &worldY);

			GetPrealign(algorithm).setPosX(cam, worldX);
			GetPrealign(algorithm).setPosY(cam, worldY);
		}
		*/

		//////////////////////////////////// 21.01.09
		// 마크 순서
		// 0		1
		// 2		3
		// 0과 1 마크의 평균을 왼쪽 마크 정보로 하고,
		// 2와 3 마크의 평균을 오른쪽 마크 정보로 하여 보정량을 계산한다.

		//GetPrealign(algorithm).setPatternPitchX(getModel().getAlignInfo().getFiducialMarkPitchX(algorithm));
		// 4점 얼라인 인경우 패널 크기를 pitch 로 사용
		// 이미지 좌표계 → 실 좌표계
		for (int i = 0; i < 2; i++)
		{
			nCamT = i;
			nCamB = i + 2;

			posX[0] = GetMatching(nJob).getFindInfo(nCamT, nPos).GetXPos();
			posY[0] = GetMatching(nJob).getFindInfo(nCamT, nPos).GetYPos();

			posX[1] = GetMatching(nJob).getFindInfo(nCamB, nPos).GetXPos();
			posY[1] = GetMatching(nJob).getFindInfo(nCamB, nPos).GetYPos();

			GetMachine(nJob).PixelToWorld(nCamT, nPos, posX[0], posY[0], &worldX[0], &worldY[0]);
			GetMachine(nJob).PixelToWorld(nCamB, nPos, posX[1], posY[1], &worldX[1], &worldY[1]);

			GetPrealign(nJob).setPosX(nCamT, worldX[0]);
			GetPrealign(nJob).setPosY(nCamT, worldY[0]);
			GetPrealign(nJob).setPosX(nCamB, worldX[1]);
			GetPrealign(nJob).setPosY(nCamB, worldY[1]);

			GetPrealign(nJob).setRotateX(nCamT, GetMachine(nJob).getRotateX(nCamT, nPos));
			GetPrealign(nJob).setRotateY(nCamT, GetMachine(nJob).getRotateY(nCamT, nPos));
			GetPrealign(nJob).setRotateX(nCamB, GetMachine(nJob).getRotateX(nCamB, nPos));
			GetPrealign(nJob).setRotateY(nCamB, GetMachine(nJob).getRotateY(nCamB, nPos));
		}

		int bMethod = vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod();

		if (bMethod == METHOD_MATCHING)
		{
			GetPrealign(nJob).setPatternPitchX(vt_job_info[nJob].model_info.getGlassInfo().getGlassWidth());
			GetPrealign(nJob).setPatternPitchY(vt_job_info[nJob].model_info.getGlassInfo().getGlassHeight());
		}
		else if (bMethod == METHOD_CALIPER)
		{
			GetPrealign(nJob).setPatternPitchX(vt_job_info[nJob].model_info.getGlassInfo().getFrameWidth());
			GetPrealign(nJob).setPatternPitchY(vt_job_info[nJob].model_info.getGlassInfo().getFrameHeight());
		}


		// mm로 Offset 적용
		GetPrealign(nJob).setRevisionOffset(0, vt_job_info[nJob].model_info.getMachineInfo().getRevisionOffset(0));
		GetPrealign(nJob).setRevisionOffset(1, vt_job_info[nJob].model_info.getMachineInfo().getRevisionOffset(1));
		GetPrealign(nJob).setRevisionOffset(2, vt_job_info[nJob].model_info.getMachineInfo().getRevisionOffset(2));
		GetPrealign(nJob).pDlg = this;
		// 방향 결정
		GetPrealign(nJob).setReverseAxisX(vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseX());
		GetPrealign(nJob).setReverseAxisY(vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseY());
		GetPrealign(nJob).setReverseAxisT(vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseT());
		GetPrealign(nJob).setReverseAxisXY(vt_job_info[nJob].model_info.getAlignInfo().getRevisionReverseXY());


		switch (vt_job_info[nJob].model_info.getAlignInfo().getAngleCalcMethod()) {
		case 1:			// Glass Size
		{
			GetPrealign(nJob).setPatternPitchX(vt_job_info[nJob].model_info.getGlassInfo().getGlassWidth());
			GetPrealign(nJob).setPatternPitchY(vt_job_info[nJob].model_info.getGlassInfo().getGlassHeight());
		}
		break;
		case 2:			// Frame Size
		{
			GetPrealign(nJob).setPatternPitchX(vt_job_info[nJob].model_info.getGlassInfo().getFrameWidth());
			GetPrealign(nJob).setPatternPitchY(vt_job_info[nJob].model_info.getGlassInfo().getFrameHeight());
		}
		break;
		case 3:			// Rotate Center
		{
			// LT RT LB RB
			double pitch_x = fabs(GetMachine(nJob).getRotateX(1, 0) - GetMachine(nJob).getRotateX(0, 0));
			double pitch_x2 = fabs(GetMachine(nJob).getRotateX(3, 0) - GetMachine(nJob).getRotateX(2, 0));
			double pitch_y = fabs(GetMachine(nJob).getRotateY(2, 0) - GetMachine(nJob).getRotateY(0, 0));
			double pitch_y2 = fabs(GetMachine(nJob).getRotateY(3, 0) - GetMachine(nJob).getRotateY(1, 0));

			GetPrealign(nJob).setPatternPitchX((pitch_x + pitch_x2) / 2.0);
			GetPrealign(nJob).setPatternPitchY((pitch_y + pitch_y2) / 2.0);
		}
		break;
		default:		//	Align Key
		{
			GetPrealign(nJob).setPatternPitchX(vt_job_info[nJob].model_info.getAlignInfo().getFiducialMarkPitchX());
			GetPrealign(nJob).setPatternPitchY(vt_job_info[nJob].model_info.getAlignInfo().getFiducialSecondMarkPitchY());

		}
		break;
		}


		if (GetPrealign(nJob).calcRevision4Cam_Center(0, 1, 2, 3, vt_job_info[nJob].model_info.getAlignInfo().getAlignmentTargetDir()) != 0)
		{
			vt_result_info[nJob].each_Judge[0][0] = FALSE;
			vt_result_info[nJob].each_Judge[1][0] = FALSE;
			vt_result_info[nJob].each_Judge[2][0] = FALSE;
			vt_result_info[nJob].each_Judge[3][0] = FALSE;


			str.Format("[%s] Calc Revision Failed", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			nRet = 2;

			m_nErrorType[nJob] = ERR_TYPE_REVISION_FAIL;

			m_dbRevisionData[nJob][AXIS_X] = 0;
			m_dbRevisionData[nJob][AXIS_Y] = 0;
			m_dbRevisionData[nJob][AXIS_T] = 0;
			break;
		}

		///////// L Check 검사
		if (vt_job_info[nJob].model_info.getAlignInfo().getEnableLCheck())
		{
			BOOL bError = FALSE;
			bError = calc_lcheck_4cam_1pos(nJob);

			if (bError)
			{
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				m_nErrorType[nJob] = ERR_TYPE_L_CHECK;
				m_bLcheckNG[nJob] = TRUE;
				nRet = 2;
				break;
			}
			else
			{
				m_bLcheckNG[nJob] = FALSE;
			}
		}


		// 보정량 전송
		double xMove = 0, yMove = 0;
		GetPrealign(nJob).calcRotateOffset(GetPrealign(nJob).getRevisionOffset(2), xMove, yMove);
		if (m_bSimulationStart != TRUE)
		{
			sendRevisionOffsetData(xMove, yMove, GetPrealign(nJob).getRevisionOffset(2));
			sendRevisionData(GetPrealign(nJob).getRevisionX(), GetPrealign(nJob).getRevisionY(), GetPrealign(nJob).getRevisionT(), nJob);
			// Matching Rate 전송
			sendMatchingRateData(nJob);

			sendLCheckData4Cam4Align(nJob);
		}

		m_dbRevisionData[nJob][AXIS_X] = GetPrealign(nJob).getRevisionX();
		m_dbRevisionData[nJob][AXIS_Y] = GetPrealign(nJob).getRevisionY();
		m_dbRevisionData[nJob][AXIS_T] = GetPrealign(nJob).getRevisionT();

		str.Format("[%s] X : %.4f Y : %.4f T : %.4f", vt_job_info[nJob].job_name.c_str(), m_dbRevisionData[nJob][AXIS_X], m_dbRevisionData[nJob][AXIS_Y], m_dbRevisionData[nJob][AXIS_T]);
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		// 좌표 저장 검사시 사용 하기 위함 
		// 3번째 위치에 마크 등록 되어 있어야함

		if (vt_job_info[nJob].model_info.getGlassInfo().getModelPanelType() == _CORE_MODEL_CALC)
		{
			/*nCamT = 0;
			nCamB = 1;
			int real_cam_T = camBuf.at(0);
			int real_cam_B = camBuf.at(1);
			int W = m_stCamInfo[real_cam_T].w;
			int H = m_stCamInfo[real_cam_B].h;
			GetMatching(algorithm).findPattern(getProcBuffer(real_cam_T), nCamT, 2, W, H);
			GetMatching(algorithm).findPattern(getProcBuffer(real_cam_B), nCamB, 2, W, H);

			posX[0] = GetMatching(algorithm).getFindInfo(nCamT, nPos).GetXPos();
			posY[0] = GetMatching(algorithm).getFindInfo(nCamT, nPos).GetYPos();
			posX[1] = GetMatching(algorithm).getFindInfo(nCamB, nPos).GetXPos();
			posY[1] = GetMatching(algorithm).getFindInfo(nCamB, nPos).GetYPos();

			ofstream writeFile(string_format("%s\\InspResult.txt", m_strComFolerName));

			if (writeFile.is_open()) {
				writeFile << string_format("%.3f\n", posX[0]);
				writeFile << string_format("%.3f\n", posY[0]);
				writeFile << string_format("%.3f\n", posX[1]);
				writeFile << string_format("%.3f\n", posY[1]);

				for (int k = 0; k < 4; k++)
				{
					writeFile << string_format("%.3f\n", GetMatching(algorithm).getFindInfo(k, nPos).GetXPos());
					writeFile << string_format("%.3f\n", GetMatching(algorithm).getFindInfo(k, nPos).GetYPos());
				}

				writeFile.close();
			}*/

			nCamT = 0;
			nCamB = 1;
			int real_cam_T = camBuf.at(0);
			int real_cam_B = camBuf.at(1);

			int nsaveId = 0;
			int W = m_stCamInfo[real_cam_T].w;
			int H = m_stCamInfo[real_cam_B].h;
			GetMatching(nJob).findPattern(getProcBuffer(real_cam_T, 0), nCamT, 2, W, H);
			GetMatching(nJob).findPattern(getProcBuffer(real_cam_B, 0), nCamB, 2, W, H);

			posX[0] = GetMatching(nJob).getFindInfo(nCamT, 2).GetXPos();
			posY[0] = GetMatching(nJob).getFindInfo(nCamT, 2).GetYPos();
			posX[1] = GetMatching(nJob).getFindInfo(nCamB, 2).GetXPos();
			posY[1] = GetMatching(nJob).getFindInfo(nCamB, 2).GetYPos();

			GetMachine(nJob).PixelToWorld(nCamT, 0, posX[0], posY[0], &worldX[0], &worldY[0]);
			GetMachine(nJob).PixelToWorld(nCamB, 0, posX[1], posY[1], &worldX[1], &worldY[1]);

#ifndef _USEPLC_ADDRESS
			long resultData[32] = { 0, };
			for (int k = 0; k < 2; k++)
			{
				resultData[k * 4] = LOWORD((long)(worldX[k] * MOTOR_SCALE));
				resultData[k * 4 + 1] = HIWORD((long)(worldX[k] * MOTOR_SCALE));
				resultData[k * 4 + 2] = LOWORD((long)(worldY[k] * MOTOR_SCALE));
				resultData[k * 4 + 3] = HIWORD((long)(worldY[k] * MOTOR_SCALE));
			}

			GetMachine(nJob).PixelToWorld(camBuf.at(2), 0, W / 4., H * 3 / 4., &worldX[0], &worldY[0]);
			GetMachine(nJob).PixelToWorld(camBuf.at(3), 0, W / 4., H * 3 / 4., &worldX[1], &worldY[1]);

			for (int k = 0; k < 2; k++)
			{
				resultData[k * 4 + 8] = LOWORD((long)(worldX[k] * MOTOR_SCALE));
				resultData[k * 4 + 9] = HIWORD((long)(worldX[k] * MOTOR_SCALE));
				resultData[k * 4 + 10] = LOWORD((long)(worldY[k] * MOTOR_SCALE));
				resultData[k * 4 + 11] = HIWORD((long)(worldY[k] * MOTOR_SCALE));
			}

			for (int k = 0; k < 4; k++)
			{
				GetMachine(nJob).PixelToWorld(k, 0, GetMatching(nJob).getFindInfo(k, nPos).GetXPos(),
				GetMatching(nJob).getFindInfo(k, nPos).GetYPos(), &worldX[0], &worldY[0]);

				resultData[k * 4 + 16] = LOWORD((long)(worldX[0] * MOTOR_SCALE));
				resultData[k * 4 + 17] = HIWORD((long)(worldX[0] * MOTOR_SCALE));
				resultData[k * 4 + 18] = LOWORD((long)(worldY[0] * MOTOR_SCALE));
				resultData[k * 4 + 19] = HIWORD((long)(worldY[0] * MOTOR_SCALE));
			}

			int addr_wd_curr_calib_data = 15300; // D15300 검사 영역으로 변경
			g_CommPLC.SetWord(addr_wd_curr_calib_data, 32, resultData);

			// Matching Rate 전송
			sendMatchingRateData(nJob);
#else
			str.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, nsaveId, m_nClientID + nJob, vt_job_info[nJob].main_object_id.c_str());

			for (int i = 9; i >= 0; i--)
			{
				str.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, i, m_nClientID + nJob, vt_job_info[nJob].main_object_id.c_str());
				if (_access(str, 0) == 0)
				{
					nsaveId = (i + 1) % 10;
					break;
				}
			}

			str.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, nsaveId, m_nClientID + nJob, vt_job_info[nJob].main_object_id.c_str());

			if (_access(str, 0) == 0)
			{
				ofstream writeFile(str);

				if (writeFile.is_open()) {
					writeFile << string_format("%.3f\n", worldX[0]);
					writeFile << string_format("%.3f\n", worldY[0]);
					writeFile << string_format("%.3f\n", worldX[1]);
					writeFile << string_format("%.3f\n", worldY[1]);

					GetMachine(nJob).PixelToWorld(camBuf.at(2), 0, W / 4., H * 3 / 4., &worldX[0], &worldY[0]);
					GetMachine(nJob).PixelToWorld(camBuf.at(3), 0, W / 4., H * 3 / 4., &worldX[1], &worldY[1]);

					writeFile << string_format("%.3f\n", worldX[0]);
					writeFile << string_format("%.3f\n", worldY[0]);
					writeFile << string_format("%.3f\n", worldX[1]);
					writeFile << string_format("%.3f\n", worldY[1]);

					for (int k = 0; k < 4; k++)
					{
						GetMachine(nJob).PixelToWorld(k, 0, GetMatching(nJob).getFindInfo(k, nPos).GetXPos(),
							GetMatching(nJob).getFindInfo(k, nPos).GetYPos(), &worldX[0], &worldY[0]);

						writeFile << string_format("%.3f\n", worldX[0]);
						writeFile << string_format("%.3f\n", worldY[0]);
					}

					writeFile.close();

				}
			}
#endif
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);
		nRet = 1;
	}
	break;
	case 400:
		if (m_nManualInputMarkResult[nJob] == 1)
		{
			m_pManualInputMark[nJob]->KillTimer(TIMER_MANUAL_MARK);
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 350;
			ReleaseSRWLockExclusive(&g_srwlock);
		}
		else if (m_nManualInputMarkResult[nJob] == 2)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			return 2;
		}
	break;
#pragma region 시뮬레이션 
	case 1000:
	{
		BOOL bFindPatternEnd = simulration_4cam_1shot_align(nJob);
		if (bFindPatternEnd == TRUE)	m_nSeqProcess[nJob] = 350;
		else
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;
		}
	}
	break;
#pragma endregion
	}

	return nRet;
}
BOOL CLET_AlignClientDlg::simulration_4cam_1shot_align(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	// 알고리즘 시작.

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		m_pPattern[real_cam].pDlg = this;
		m_pPattern[real_cam].nPos = 0;
		m_pPattern[real_cam].nCam = nCam;
		m_pPattern[real_cam].nSearchCount = 1;  //2point search
		m_pPattern[real_cam].nJob = nJob;

		m_bFindPattern[real_cam] = FALSE;
		m_bFindPatternEnd[real_cam] = FALSE;

		AfxBeginThread(Thread_FindPattern, &m_pPattern[real_cam]);

		Delay(50);
	}

	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	int MS_TIMEOUT = 10000;

	BOOL all_insp_end = TRUE;
	while (nEtick - nStick <= MS_TIMEOUT) {
		Sleep(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_insp_end = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];

			if (m_bFindPatternEnd[real_cam] != TRUE)
				all_insp_end = FALSE;
		}

		if (all_insp_end == TRUE) break;

		if (nEtick - nStick == MS_TIMEOUT)
		{
			str.Format("TimeOut(ms : %d) ", MS_TIMEOUT);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	if (all_insp_end != TRUE) return FALSE;


	BOOL bAllFind = TRUE;

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		int real_cam = vt_job_info[nJob].camera_index[nCam];

		if (m_bFindPattern[real_cam] != TRUE)
			bAllFind = FALSE;
	}

	return bAllFind;
}
int CLET_AlignClientDlg::processAlignExist(int nJob)
{
	CString str;

	std::vector<int> camBuf = vt_job_info[nJob].camera_index;
	if (camBuf.size() <= 0) return 2;

	int nRet = 0;
	int nCam = 0;
	int real_cam = camBuf.at(0);
	int nPos = 0;

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {
	case 0:	break;
	case 100:
		{
#ifdef _DAHUHA
		AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
		AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
		m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
		ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
		ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif
#ifdef _DAHUHA
			if (m_pDahuhaCam[real_cam].isconnected())
#else
			if (m_pBaslerCam[real_cam] || m_pSaperaCam[real_cam].IsOpend())
#endif
				SendMessage(WM_VIEW_CONTROL, MSG_MD_CAMERA_SINGLE_FRAME, real_cam); 
			m_nGrabTimeOutCount[nJob] = 0;

			str.Format("[%s] Grab Start", vt_job_info[nJob].get_job_name());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 200;
			ReleaseSRWLockExclusive(&g_srwlock);
		}
		break;
	case 200:
		{
			BOOL bGrabComplete = TRUE;
			if (m_bGrabEnd[real_cam] != TRUE)
				bGrabComplete = FALSE;

			if (++m_nGrabTimeOutCount[nJob] > 100)
			{
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				nRet = 2;

				str.Format("[%s] Grab TimeOut", vt_job_info[nJob].get_job_name());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				break;
			}

			if (bGrabComplete)
			{
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 300;
				ReleaseSRWLockExclusive(&g_srwlock);
				str.Format("[%s] Grab Complete", vt_job_info[nJob].get_job_name());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			}
		}
		break;
	case 300:
		{
			CString strTemp;
			int nPos = 0;
			BOOL bFind = TRUE;

			int W = m_stCamInfo[real_cam].w;
			int H = m_stCamInfo[real_cam].h;

			copyMemory(getProcBuffer(real_cam, 0), getSrcBuffer(real_cam), W * H);

			str.Format("[%s] Find Pattern", vt_job_info[nJob].get_job_name());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			//m_bInspResult[nJob] = algorithm_AlignExist(getProcBuffer(real_cam, 0), nJob, nCam, FALSE);
			m_bInspResult[nJob] = algorithm_exist_insp_assemble(getProcBuffer(real_cam, 0), nJob, nCam, FALSE);

			long lRevisionData = 0;
			lRevisionData = m_bInspResult[nJob];

			g_CommPLC.SetWord(m_nInspResultWrite[nJob], 1, &lRevisionData);
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);

			if (m_bInspResult[nJob] > 0)	nRet = 1;
			else							nRet = 2;
		}
		break;
#pragma region 시뮬레이션 
	case 1000:
	{
		m_bInspResult[nJob] = algorithm_exist_insp_assemble(getProcBuffer(real_cam, 0), nJob, nCam, FALSE);
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);

		if (m_bInspResult[nJob] > 0)	nRet = 1;
		else							nRet = 2;
	}
	break;
#pragma endregion
	}
	return nRet;
}
int CLET_AlignClientDlg::processPcbDistanceInsp(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;
#endif
	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {
	case 0:
		break;
	case 100:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[real_cam].isconnected())
#else
			if (m_pBaslerCam[real_cam] || m_pSaperaCam[real_cam].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[nJob].job_name.c_str(), nCam + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				Sleep(500); // 영상 흔들림 방지
				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				Camera_Grab(real_cam);
				//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, real_cam);
			}
			else
			{
#pragma region 이미지 수동 선택
				CFileDialog dlg(TRUE, NULL, _T("Image File"), OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
					_T("Image Files (*.bmp;*.jpg;)|*.bmp;*.jpg|All Files (*.*)|*.*||"), this);

				if (dlg.DoModal() != IDOK) {
					nRet = 2;
					break;
				}

				CString path_name = dlg.GetPathName();

				if (path_name.Find("_ImgRaw.jpg") >= 0)
				{
					m_nSeqCurrentInspGrabCount = 0;
				}
				else
				{
					m_nSeqCurrentInspGrabCount = 1;
				}

				cv::Mat loadImg = cv::imread((LPCTSTR)dlg.GetPathName(), 0);
				int W = m_stCamInfo[real_cam].w;
				int H = m_stCamInfo[real_cam].h;

				if (loadImg.cols != W || loadImg.rows != H)
				{
					str.Format("Image Size is not Valid.	size %d x %d", W, H);
					AfxMessageBox(str);

					loadImg.release();
					nRet = 2;
					break;
				}
				else
				{
					copyMemory(getSrcBuffer(real_cam), loadImg.data, W * H);
					copyMemory(getProcBuffer(real_cam, 0), loadImg.data, W * H);
					loadImg.release();
					m_bGrabEnd[real_cam] = TRUE;
				}
#pragma endregion
			}
		}

		m_nGrabTimeOutCount[nJob] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bGrabEnd[real_cam] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;
		///
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			m_pPattern[real_cam].pDlg = this;
			m_pPattern[real_cam].nPos = m_nSeqCurrentInspGrabCount;
			m_pPattern[real_cam].nCam = nCam;
			m_pPattern[real_cam].nSearchCount = 2;  //2point search
			m_pPattern[real_cam].nJob = nJob;

			m_bFindPatternEnd[real_cam] = FALSE;
			m_bFindPattern[real_cam] = TRUE;

			AfxBeginThread(Thread_PcbDistanceInspection, &m_pPattern[real_cam]);
		}
		if( m_bSimulationStart ) m_nSeqProcess[nJob] = 300;
	}
	break;
#pragma region 시뮬레이션 
	case 250:
	{
		m_nGrabTimeOutCount[nJob] = 0;
		BOOL bProcessEnd = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPatternEnd[real_cam] != TRUE)
				bProcessEnd = FALSE;
		}
		if (bProcessEnd == TRUE)	m_nSeqProcess[nJob] = 300;
		else						break;
	}
	break;
#pragma endregion
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPatternEnd[real_cam] != TRUE)
				bProcessEnd = FALSE;
		}

		if (bProcessEnd != TRUE) break;

		BOOL bAllFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPattern[real_cam] != TRUE)
				bAllFind = FALSE;
		}

		m_bInspResult[nJob] = bAllFind;

		/*
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			int W = m_stCamInfo[real_cam].w;
			int H = m_stCamInfo[real_cam].h;
			copyMemory(getProcBuffer(real_cam, 0), getSrcBuffer(real_cam), W * H);
		}
		*/

		long revisionData[SIZE_REVISION_DATA * CAM_COUNT] = { 0, };
		CString str;


		// 데이터 전송
		if (m_nSeqCurrentInspGrabCount == m_nSeqTotalInspGrabCount - 1)
		{
			for (int nCam = 0; nCam < camCount; nCam++)
			{
				int nCam1_Start_addr = 15072;
				int nCam2_Start_addr = 15092;
				int ncamera = camBuf.at(nCam);

				for (int nPos = 0; nPos < m_nSeqTotalInspGrabCount; nPos++)
				{
					revisionData[nCam * 40 + 0] = LOWORD((long)(m_stInsp_DistanceResult[ncamera][nPos].dDistance * MOTOR_SCALE));
					revisionData[nCam * 40 + 1] = HIWORD((long)(m_stInsp_DistanceResult[ncamera][nPos].dDistance * MOTOR_SCALE));
					revisionData[nCam * 40 + 2] = LOWORD((long)(m_stInsp_DistanceResult[ncamera][nPos].dWidthDistance * MOTOR_SCALE));
					revisionData[nCam * 40 + 3] = HIWORD((long)(m_stInsp_DistanceResult[ncamera][nPos].dWidthDistance * MOTOR_SCALE));
					revisionData[nCam * 40 + 4] = LOWORD((long)(m_stInsp_DistanceResult[ncamera][nPos].dHeightDistance * THETA_SCALE));
					revisionData[nCam * 40 + 5] = HIWORD((long)(m_stInsp_DistanceResult[ncamera][nPos].dHeightDistance * THETA_SCALE));
				}
				if (nCam == 0)	g_CommPLC.SetWord(nCam1_Start_addr, 20, revisionData);
				else			g_CommPLC.SetWord(nCam2_Start_addr, 20, revisionData);
			}
		}
		
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);

		str.Format("[%s] PCB Inspection End", vt_job_info[nJob].job_name.c_str());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		if (m_bInspResult[nJob])	nRet = 1;
		else						nRet = 2;
	}
	break;
	}
	return nRet;
}
int CLET_AlignClientDlg::processPcbDistanceInsp2(int nJob)
{
	BOOL bRequest = g_CommPLC.GetBit(m_nInspRequestRead[nJob]);

	CString str;
	int nRet = 0, real_cam = 0;

	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;
	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {
	case 0:
		break;
	case 100:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[real_cam].isconnected())
#else
			if (m_pBaslerCam[real_cam] || m_pSaperaCam[real_cam].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - GrabCount %d / %d", vt_job_info[nJob].get_job_name(), nCam + 1, m_nSeqCurrentInspGrabCount + 1, m_nSeqTotalInspGrabCount);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				Delay(500); // 영상 흔들림 방지
				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				Camera_Grab(real_cam);
				//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, real_cam);
			}
		}

		m_nGrabTimeOutCount[nJob] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bGrabEnd[real_cam] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Pos.%d Grab TimeOut", vt_job_info[nJob].job_name.c_str(), m_nSeqCurrentInspGrabCount + 1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			str.Format("[%s] Pos.%d Grab Complete", vt_job_info[nJob].job_name.c_str(), m_nSeqCurrentInspGrabCount + 1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			//posiion move reqeust bit On
			if (bRequest)
			{
				// 마지막이 아닐때만 비트 킴.

				// Tact Time 줄이기 위해 일단 PLC 신호 ON 하고 다음에서 검사 진행 함.
				if (m_nSeqCurrentInspGrabCount != m_nSeqTotalInspGrabCount - 1)
				{
					g_CommPLC.SetBit(m_nInspAckWrite[nJob] + m_nSeqCurrentInspGrabCount, TRUE);
					str.Format("[%s] Pos.%d Move Request", vt_job_info[nJob].job_name.c_str(), m_nSeqCurrentInspGrabCount + 2);
					::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				}

				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 300;
				ReleaseSRWLockExclusive(&g_srwlock);
			}
			else
			{
				// PLC Bit 꺼지면 그냥 리셋 시켜 버리자..
				str.Format("[%s] PLC Inspection Request Signal off! seq canceled", vt_job_info[nJob].job_name.c_str());
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
				m_nSeqProcess[nJob] = 0;
				ReleaseSRWLockExclusive(&g_srwlock);
				nRet = 2;
				break;
			}
		}
		else	break;
	}
	break;
	case 300:
	{
		str.Format("[%s] Pos.%d Inspection Start", vt_job_info[nJob].job_name.c_str(), m_nSeqCurrentInspGrabCount + 1);
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			m_pPattern[real_cam].pDlg = this;
			m_pPattern[real_cam].nPos = m_nSeqCurrentInspGrabCount;
			m_pPattern[real_cam].nCam = nCam;
			m_pPattern[real_cam].nSearchCount = 2;  //2point search
			m_pPattern[real_cam].nJob = nJob;

			m_bFindPatternEnd[real_cam] = FALSE;
			m_bFindPattern[real_cam] = TRUE;

			AfxBeginThread(Thread_PcbDistanceInspection, &m_pPattern[real_cam]);
		}

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 310;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 310:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPatternEnd[real_cam] != TRUE)
				bProcessEnd = FALSE;
		}
		if	(bProcessEnd != TRUE) break;

		BOOL bAllFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPattern[real_cam] != TRUE)
			{
				bAllFind = FALSE;
				m_stInsp_DistanceResult[real_cam][m_nSeqCurrentInspGrabCount].bNG = TRUE;
			}
		}

		str.Format("[%s] Pos.%d Inspection End - %s", vt_job_info[nJob].job_name.c_str(), m_nSeqCurrentInspGrabCount + 1, bAllFind ? "OK" : "NG");
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 320;
		ReleaseSRWLockExclusive(&g_srwlock);

	}
	break;
	case 320:
	{
		// 마지막 일때 400 Sequnce
		if (m_nSeqCurrentInspGrabCount == m_nSeqTotalInspGrabCount - 1)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 400;
			ReleaseSRWLockExclusive(&g_srwlock);
		}
		else  // 마지막 아니면 350 Sequnce에서 비트 대기
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 350;
			ReleaseSRWLockExclusive(&g_srwlock);
			m_nSeqCurrentInspGrabCount++;
		}

		m_nGrabTimeOutCount[nJob] = 0;
	}
	break;
	case 350:
	{
		if (bRequest != TRUE)
		{
			// PLC Bit 꺼지면 그냥 리셋 시켜 버리자..
			str.Format("[%s] PLC Align Request Signal off! seq canceled", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;
			break;
		}

		if (++m_nGrabTimeOutCount[nJob] > 200)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Pos.%d Moving Timeout", vt_job_info[nJob].job_name.c_str(), m_nSeqCurrentInspGrabCount + 1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}


		// PLC Bit 대기
		// 다음 포지션에 도착했는지 체크.
		if (g_CommPLC.GetBit(m_nInspRequestRead[nJob] + m_nSeqCurrentInspGrabCount))
		{

			str.Format("[%s] Pos.%d Inspection Request On", vt_job_info[nJob].job_name.c_str(), m_nSeqCurrentInspGrabCount + 1);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 100;
			ReleaseSRWLockExclusive(&g_srwlock);
		}
		else
		{
			break;
		}
	}
	break;
	case 400:
	{
		/*
								-------------------> CAM 진행방향
		//		/	  /				 /	   /			   /	 /			/	  /		  //
		//		/	  /				 /	   /	           /     /			/	  /		  //
		//		///////		         ///////		      ///////		   ///////	      //
		//	      PCB1                PCB2	               PCB3              PCB4		  //
		////////////////////////////////////////////////////////////////////////////////////   <- 패널끝단
			(Cam1-1) (Cam1-2)  (Cam1-3) (Cam1-4)     (Cam2-1) (Cam2-2) (Cam2-3) (Cam2-4)       <- CAM 위치
		*/
		//일단 사용안함
		/*
		double robot_x[2];
		double robot_y[2];
#pragma region Panel 좌측 끝단과 <-> PCB Edge 거리 계산
		// 좌측 Panel 끈단 포지션 = 왼쪽 카메라 첫번째 포지션
		real_cam = camBuf.at(0);
		int dFirstPos = 0;
		int dFirstCam1Pos = m_stInsp_DistanceResult[real_cam][dFirstPos].dCameraPos;

		// Panel 끝단 (로봇 좌표로 변환)
		GetMachine(nJob).PixelToWorld(0, 0, m_stInsp_DistanceResult[real_cam][dFirstPos].xPos[1], m_stInsp_DistanceResult[real_cam][dFirstPos].yPos[1], &robot_x[0], &robot_y[0]);
		m_stInsp_DistanceResult[real_cam][dFirstPos].xPosWorld[1] = robot_x[0] + dFirstCam1Pos;
		m_stInsp_DistanceResult[real_cam][dFirstPos].yPosWorld[1] = robot_y[0];

		for (int nCamPos = 1; nCamPos < m_nSeqTotalInspGrabCount - 1; nCamPos++)
		{
			// PCB Edge (로봇 좌표로 변환)
			GetMachine(nJob).PixelToWorld(0, 0, m_stInsp_DistanceResult[real_cam][nCamPos].xPos[1], m_stInsp_DistanceResult[real_cam][nCamPos].yPos[1], &robot_x[1], &robot_y[1]);
			m_stInsp_DistanceResult[real_cam][nCamPos].xPosWorld[1] = robot_x[1] + m_stInsp_DistanceResult[real_cam][nCamPos].dCameraPos;
			m_stInsp_DistanceResult[real_cam][nCamPos].yPosWorld[1] = robot_y[1];

			// 떨어진 거리 계산
			double dx = m_stInsp_DistanceResult[real_cam][0].xPosWorld[1] - m_stInsp_DistanceResult[real_cam][nCamPos].xPosWorld[0];
			double dy = m_stInsp_DistanceResult[real_cam][0].yPosWorld[1] - m_stInsp_DistanceResult[real_cam][nCamPos].yPosWorld[0];

			m_stInsp_DistanceResult[real_cam][nCamPos].dWidthDistance = sqrt(dx * dx + dy * dy);
			m_stInsp_DistanceResult[real_cam][nCamPos].dWidthDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(0, nCamPos, 0);
		}
#pragma endregion

#pragma region Panel 우측 끝단과 <-> PCB 거리 계산
		// 우측 Panel 끝단 포지션 = 오른쪽 카메라 마지막 포지션
		real_cam = camBuf.at(1);
		int nLastPos = m_nSeqTotalInspGrabCount - 1;
		int dLastCam2Pos = m_stInsp_DistanceResult[real_cam][nLastPos].dCameraPos;

		// Panel 끝단 (로봇 좌표로 변환)
		GetMachine(nJob).PixelToWorld(1, 0, m_stInsp_DistanceResult[real_cam][nLastPos].xPos[1], m_stInsp_DistanceResult[real_cam][nLastPos].yPos[1], &robot_x[0], &robot_y[0]);
		m_stInsp_DistanceResult[real_cam][nLastPos].xPosWorld[1] = robot_x[0] + dLastCam2Pos;
		m_stInsp_DistanceResult[real_cam][nLastPos].yPosWorld[1] = robot_y[0];

		// 다른 위치
		for (int nCamPos = 0; nCamPos < nLastPos; nCamPos++)
		{
			// PCB Edge (로봇 좌표로 변환)
			GetMachine(nJob).PixelToWorld(1, 0, m_stInsp_DistanceResult[real_cam][nCamPos].xPos[1], m_stInsp_DistanceResult[real_cam][nCamPos].yPos[1], &robot_x[1], &robot_y[1]);
			m_stInsp_DistanceResult[real_cam][nCamPos].xPosWorld[1] = robot_x[1] + m_stInsp_DistanceResult[real_cam][nCamPos].dCameraPos;
			m_stInsp_DistanceResult[real_cam][nCamPos].yPosWorld[1] = robot_y[1];

			// 떨어진 거리 계산
			double dx = m_stInsp_DistanceResult[real_cam][nLastPos].xPosWorld - m_stInsp_DistanceResult[real_cam][nCamPos].xPosWorld;
			double dy = m_stInsp_DistanceResult[real_cam][nLastPos].yPosWorld - m_stInsp_DistanceResult[real_cam][nCamPos].yPosWorld;

			m_stInsp_DistanceResult[real_cam][nCamPos].dWidthDistance = sqrt(dx * dx + dy * dy);
			m_stInsp_DistanceResult[real_cam][nCamPos].dWidthDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(1, nCamPos, 0);
		}
#pragma endregion
		*/
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 500;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 500:
	{
		double Spec_distance_LSL = 0;
		double Spec_distance_USL = 0;
		int num_of_insp_pos = m_nSeqTotalInspGrabCount * 2 + 2;	// 검사 포지션 수는 탭별 Y축 2포인트 + 양끝 x축 2포인트
		int real_pos = 0;
		int real_cam = 0;

		// 카메라별 측정 값을 Pos1 ~ 로 변환
#pragma region 카메라별 측정 값을 Pos1 ~ 로 변환
		for (int nPos = 0; nPos < num_of_insp_pos; nPos++)
		{
			// 첫번째 포지션
			if (nPos == 0)
			{
				real_pos = 0;	real_cam = camBuf.at(0);
				m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][real_pos].dWidthDistance;
			}
			// 마지막 포지션
			else if (nPos == (num_of_insp_pos - 1))
			{
				real_pos = m_nSeqTotalInspGrabCount - 1;		real_cam = camBuf.at(1);
				m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][real_pos].dWidthDistance;
			}
			else
			{
				if (nPos < (num_of_insp_pos / 2)) {
					real_pos = nPos - 1;
					real_cam = camBuf.at(0);
					m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][real_pos].dHeightDistance;
				}
				else {
					real_pos = nPos - (num_of_insp_pos / 2);
					real_cam = camBuf.at(1);
					m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][real_pos].dHeightDistance;
				}
			}
		}
#pragma endregion

#pragma region 스펙 비교
		// (Distnace) 스펙 비교
		BOOL spec_judge = TRUE;
		for (int nPos = 0; nPos < num_of_insp_pos; nPos++)
		{
			Spec_distance_LSL = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(nPos);
			Spec_distance_USL = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(nPos);

			double value = m_dDistanceInspDataResult[nPos];

			if (value < Spec_distance_LSL || value > Spec_distance_USL)
			{
				spec_judge = FALSE;
				m_dDistanceInspJudgeResult[nPos] = FALSE;
			}
			else
			{
				m_dDistanceInspJudgeResult[nPos] = TRUE;
			}
		}
#pragma endregion

#pragma region 최종 판정
		m_bInspResult[nJob] = TRUE;

		for (int nPos = 0; nPos < m_nSeqTotalInspGrabCount; nPos++)
		{
			for (int nCam = 0; nCam < camCount; nCam++)
			{
				real_cam = camBuf.at(nCam);
				if (m_stInsp_DistanceResult[real_cam][nPos].bNG == TRUE)
				{
					m_bInspResult[nJob] = FALSE;
				}
			}
		}

		if( spec_judge != TRUE )
			m_bInspResult[nJob] = FALSE;
#pragma endregion

#pragma region 결과 Display
		for (int nPos = 0; nPos < num_of_insp_pos; nPos++)
		{
			Spec_distance_LSL = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(nPos);
			Spec_distance_USL = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(nPos);

			str.Format("[%s]P%d(%s) D : %.3f( %.3f ~ %.3f )",	vt_job_info[nJob].job_name.c_str(),
																nPos + 1,
																m_dDistanceInspJudgeResult[nPos] ? "OK" : "NG!",
																m_dDistanceInspDataResult[nPos],
																Spec_distance_LSL,
																Spec_distance_USL);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
#pragma endregion

#pragma region POS별 spec NG에 대해 [cam][pos]별(Viewer) NG로 변환
		for (int nPos = 0; nPos < num_of_insp_pos; nPos++)
		{
			// 첫번째 포지션
			if (nPos == 0)
			{
				real_pos = 0;
				real_cam = camBuf.at(0);
			}
			// 마지막 포지션
			else if (nPos == (num_of_insp_pos - 1))
			{
				real_pos = m_nSeqTotalInspGrabCount - 1;
				real_cam = camBuf.at(1);
			}
			else
			{
				if (nPos < (num_of_insp_pos / 2)) {
					real_pos = nPos - 1;
					real_cam = camBuf.at(0);
				}
				else {
					real_pos = nPos - (num_of_insp_pos / 2);
					real_cam = camBuf.at(1);
				}
			}

			if (m_dDistanceInspJudgeResult[nPos] != TRUE)
				m_stInsp_DistanceResult[real_cam][real_pos].bNG = TRUE;
		}
#pragma endregion

#pragma region PLC로 측정값 전송
		if (m_bSimulationStart != TRUE)
		{
			long revisionData[20] = { 0, };
			CString str;

			// 데이터 전송
			int Start_addr = 15070;
			for (int nPos = 0; nPos < num_of_insp_pos; nPos++)
			{
				revisionData[0 + nPos * 2] = LOWORD((long)(m_dDistanceInspDataResult[nPos] * MOTOR_SCALE));
				revisionData[1 + nPos * 2] = HIWORD((long)(m_dDistanceInspDataResult[nPos] * MOTOR_SCALE));;
			}
			g_CommPLC.SetWord(Start_addr, 20, revisionData);
		}
#pragma endregion

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);

		str.Format("[%s] PCB Inspection End", vt_job_info[nJob].job_name.c_str());
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		if (m_bInspResult[nJob])	nRet = 1;
		else						nRet = 2;
	}
	break;
#pragma region 시뮬레이션 
	case 1000:
	{
		m_bInspResult[nJob] = simulration_pcb_insp(nJob);
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 500;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
#pragma endregion

	}
	return nRet;
}
BOOL CLET_AlignClientDlg::simulration_pcb_insp(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	// 알고리즘 시작.
	for (int nPos = 0; nPos < m_nSeqTotalInspGrabCount; nPos++)
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			m_pPattern[real_cam].pDlg = this;
			m_pPattern[real_cam].nPos = nPos;
			m_pPattern[real_cam].nCam = nCam;
			m_pPattern[real_cam].nSearchCount = 2;  //2point search
			m_pPattern[real_cam].nJob = nJob;

			m_bFindInspPattern[real_cam][nPos] = FALSE;
			m_bFindInspPatternEnd[real_cam][nPos] = FALSE;

			AfxBeginThread(Thread_PcbDistanceInspection, &m_pPattern[real_cam]);

			Delay(50);
		}
	}
	
	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	int MS_TIMEOUT = 10000;

	BOOL all_insp_end = TRUE;
	while (nEtick - nStick <= MS_TIMEOUT) {
		Delay(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_insp_end = TRUE;
		for (int nPos = 0; nPos < m_nSeqTotalInspGrabCount; nPos++)
		{
			for (int nCam = 0; nCam < camCount; nCam++)
			{
				int real_cam = vt_job_info[nJob].camera_index[nCam];

				if (m_bFindInspPatternEnd[real_cam][nPos] != TRUE)
					all_insp_end = FALSE;
			}
		}

		if (all_insp_end == TRUE) break;

		if (nEtick - nStick == MS_TIMEOUT)
		{
			str.Format("TimeOut(ms : %d) ", MS_TIMEOUT);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	
	if (all_insp_end != TRUE) return FALSE;

	return all_insp_end;
}
int CLET_AlignClientDlg::processAssembleInsp(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	int nPos = 0;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algorithm);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algorithm);
#else
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;
#endif

	AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
	int _sequence = m_nSeqProcess[nJob];
	ReleaseSRWLockExclusive(&g_srwlock);

	switch (_sequence) {
	case 0:
		break;
	case 100:
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
#ifdef _DAHUHA
			AcquireSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#else
			AcquireSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock); // 동기화 시킴 Tkyuha 20211027
#endif
			m_bGrabEnd[real_cam] = FALSE;
#ifdef _DAHUHA
			ReleaseSRWLockExclusive(&m_pDahuhaCam[real_cam].g_bufsrwlock);
#else
			ReleaseSRWLockExclusive(&m_pBaslerCam[real_cam]->g_bufsrwlock);
#endif

#ifdef _DAHUHA
			if (m_pDahuhaCam[real_cam].isconnected())
#else
			if (m_pBaslerCam[real_cam] || m_pSaperaCam[real_cam].IsOpend())
#endif
			{
				str.Format("[%s] Cam %d - Grab Start", vt_job_info[nJob].job_name.c_str(), nCam + 1);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
				Camera_Grab(real_cam);
				//SendMessage(WM_VIEW_CONTROL, MSG_MD_GRAB_THREAD, real_cam);
			}
			else
			{
				CFileDialog dlg(TRUE, NULL, _T("Image File"), OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
					_T("Image Files (*.bmp;*.jpg;)|*.bmp;*.jpg|All Files (*.*)|*.*||"), this);

				if (dlg.DoModal() != IDOK) {
					nRet = 2;
					break;
				}

				cv::Mat loadImg = cv::imread((LPCTSTR)dlg.GetPathName(), 0);

				int W = m_stCamInfo[real_cam].w;
				int H = m_stCamInfo[real_cam].h;

				if (loadImg.cols != W || loadImg.rows != H)
				{
					str.Format("Image Size is not Valid.	size %d x %d", W, H);
					AfxMessageBox(str);

					loadImg.release();
					nRet = 2;
					break;
				}
				else
				{
					copyMemory(getSrcBuffer(real_cam), loadImg.data, W * H);
					copyMemory(getProcBuffer(real_cam, 0), loadImg.data, W * H);
					loadImg.release();
					m_bGrabEnd[real_cam] = TRUE;

				}
			}
		}

		m_nGrabTimeOutCount[nJob] = 0;
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 200;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 200:
	{
		BOOL bGrabComplete = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bGrabEnd[real_cam] != TRUE)
				bGrabComplete = FALSE;
		}

		if (++m_nGrabTimeOutCount[nJob] > 100)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 0;
			ReleaseSRWLockExclusive(&g_srwlock);
			nRet = 2;

			str.Format("[%s] Grab TimeOut", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			break;
		}

		if (bGrabComplete)
		{
			AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
			m_nSeqProcess[nJob] = 300;
			ReleaseSRWLockExclusive(&g_srwlock);
			str.Format("[%s] Grab Complete", vt_job_info[nJob].job_name.c_str());
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		else	break;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			m_pPattern[real_cam].pDlg = this;
			m_pPattern[real_cam].nPos = 0;
			m_pPattern[real_cam].nCam = nCam;
			m_pPattern[real_cam].nSearchCount = 2;  //2point search
			m_pPattern[real_cam].nJob = nJob;

			m_bFindPatternEnd[real_cam] = FALSE;
			m_bFindPattern[real_cam] = TRUE;

			AfxBeginThread(Thread_AssembleInspection, &m_pPattern[real_cam]);
		}
	}
	break;
	case 300:
	{
		BOOL bProcessEnd = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPatternEnd[real_cam] != TRUE)
				bProcessEnd = FALSE;
		}
		if (bProcessEnd != TRUE) break;

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 400;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
	break;
	case 400:
	{
		BOOL bAllFind = TRUE;
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			real_cam = camBuf.at(nCam);
			if (m_bFindPattern[real_cam] != TRUE)
			{
				m_stInsp_DistanceResult[real_cam][0].bNG = TRUE;
				bAllFind = FALSE;
			}
		}

#pragma region _CORE_MODEL_CALC 수동 계산시 사용
		if (vt_job_info[nJob].model_info.getGlassInfo().getModelPanelType() == _CORE_MODEL_CALC)  // 수동 계산시 사용
		{
			int nreadId = 0;
			double curdegrees;
			double posCurX[4] = { 0, };
			double posCurY[4] = { 0, };
			int W = m_stCamInfo[camBuf.at(0)].w;
			int H = m_stCamInfo[camBuf.at(0)].h;

			int nPos = 2;
			double posX[4] = { 0, }, posY[4] = { 0, }, posX1, posY1, radians;
			double posRX[4] = { 0, }, posRY[4] = { 0, };
			double posNX[4] = { 0, }, posNY[4] = { 0, };
			double posTheta[4] = { 0, }, posDistance[4] = { 0, };

			for (int nCam = 0; nCam < camCount; nCam++)
			{
				real_cam = camBuf[nCam];
				GetMatching(nJob).findPattern(getProcBuffer(real_cam, 0), nCam, nPos, W, H);

				posCurX[nCam] = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
				posCurY[nCam] = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

				GetMachine(nJob).PixelToWorld(nCam, 0, posCurX[nCam], posCurY[nCam], &posCurX[nCam], &posCurY[nCam], TRUE);
			}

			// 
			//	홈 2포인트									8
			//	각 아래쪽 카메라 기준 위치의 로봇 좌표	2포인트	8
			//  실제 찾은 각 코너의 로봇 좌표 4포인트			16
#ifndef _USEPLC_ADDRESS
			long* lData = new long[32];
			int addr_wd_curr_calib_data = 15300; // R15300 검사 영역으로 변경
			g_CommPLC.GetWord(addr_wd_curr_calib_data, 32, lData);

			for (int i = 0; i < 2; i++)
			{
				posX[i] = MAKELONG(lData[i * 4], lData[i * 4 + 1]) / MOTOR_SCALE;
				posY[i] = MAKELONG(lData[i * 4 + 2], lData[i * 4 + 3]) / MOTOR_SCALE;
			}
			for (int i = 0; i < 2; i++)
			{
				posX[i + 2] = MAKELONG(lData[i * 4 + 8], lData[i * 4 + 9]) / MOTOR_SCALE;
				posY[i + 2] = MAKELONG(lData[i * 4 + 10], lData[i * 4 + 11]) / MOTOR_SCALE;
			}

			for (int k = 0; k < 4; k++)
			{
				posRX[k] = MAKELONG(lData[k * 4 + 16], lData[k * 4 + 17]) / MOTOR_SCALE;
				posRY[k] = MAKELONG(lData[k * 4 + 18], lData[k * 4 + 19]) / MOTOR_SCALE;
			}
#else			
			// 0    1
			// 2    3 순서 인경우
			//str.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, nreadId, m_nClientID, m_cPanel_Read_ID[algorithm]);
			str.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, nreadId, m_nClientID, vt_job_info[nJob].main_object_id.c_str());

			for (int i = 9; i >= 0; i--)
			{
				//str.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, i, m_nClientID, m_cPanel_Read_ID[algorithm]);
				str.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, i, m_nClientID, vt_job_info[nJob].main_object_id.c_str());
				if (_access(str, 0) == 0)
				{
					nreadId = i;
					break;
				}
			}
			//str.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, nreadId, m_nClientID, m_cPanel_Read_ID[algorithm]);
			str.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, nreadId, m_nClientID, vt_job_info[nJob].main_object_id.c_str());

			if (_access(str, 0) == 0)
			{
				ifstream openFile(str);
				if (openFile.is_open()) {
					string line;
					getline(openFile, line); posX[0] = atof(line.c_str());
					getline(openFile, line); posY[0] = atof(line.c_str());
					getline(openFile, line); posX[1] = atof(line.c_str());
					getline(openFile, line); posY[1] = atof(line.c_str());
					getline(openFile, line); posX[2] = atof(line.c_str());
					getline(openFile, line); posY[2] = atof(line.c_str());
					getline(openFile, line); posX[3] = atof(line.c_str());
					getline(openFile, line); posY[3] = atof(line.c_str());

					for (int k = 0; k < 4; k++)
					{
						getline(openFile, line); posRX[k] = atof(line.c_str());
						getline(openFile, line); posRY[k] = atof(line.c_str());
					}

					openFile.close();
					remove(str); // 사용후 삭제
				}
			}
#endif

			double pPanelTheata = atan2(posY[1] - posY[0], posX[1] - posX[0]) * 180.f / CV_PI;
			double pCurTheata = atan2(posCurY[1] - posCurY[0], posCurX[1] - posCurX[0]) * 180.f / CV_PI;
			double pDiffTheata = pCurTheata - pPanelTheata;

			for (int k = 0; k < 4; k++)
			{
				if (k > 1)
				{
					double CurX = posCurX[k % 2];
					double CurY = H * 3. / 4.;
					GetMachine(nJob).PixelToWorld(k, 0, CurX, CurY, &CurX, &CurY, TRUE);
					posCurY[k % 2] = CurY + (CurY + posCurY[k % 2]);
				}

				posTheta[k] = (posRX[k] - posX[k % 2]) != 0 ? atan((posRY[k] - posY[k]) / (posRX[k] - posX[k % 2])) : 0;
				curdegrees = (posTheta[k] * (180.0 / CV_PI));

				radians = (curdegrees + pDiffTheata) * (CV_PI / 180.0);
				posDistance[k] = sqrt(pow(posRX[k] - posX[k % 2], 2) + pow(posRY[k] - posY[k], 2));

				if (k % 2 == 0)	posNX[k] = posCurX[k % 2] - (posDistance[k] * cos(radians));
				else posNX[k] = posCurX[k % 2] + (posDistance[k] * cos(radians));

				if (radians > 0)		posNY[k] = posCurY[k % 2] - (posDistance[k] * sin(radians));
				else 					posNY[k] = posCurY[k % 2] + (posDistance[k] * sin(radians));
			}

			// 신규좌표로 계산
			for (int k = 0; k < 4; k++)
			{
				GetMachine(nJob).WorldToPixel(k, 0, posNX[k], posNY[k], &posNX[k], &posNY[k]);

				m_stInsp_DistanceResult[camBuf.at(k)][0].xPos[1] = posNX[k];
				m_stInsp_DistanceResult[camBuf.at(k)][0].yPos[1] = posNY[k];
				posX1 = m_stInsp_DistanceResult[camBuf.at(k)][0].xPos[1];
				posY1 = m_stInsp_DistanceResult[camBuf.at(k)][0].yPos[1];

				GetMachine(nJob).PixelToWorld(k, 0, posNX[k], posNY[k], &posNX[k], &posNY[k], TRUE);

				m_stInsp_DistanceResult[camBuf.at(k)][0].dDistance = sqrt(pow(posNX[k] - posX1, 2) + pow(posNY[k] - posY1, 2));
				m_stInsp_DistanceResult[camBuf.at(k)][0].dWidthDistance = fabs(posNX[k] - posX1);
				m_stInsp_DistanceResult[camBuf.at(k)][0].dHeightDistance = fabs(posNY[k] - posY1);

				str.Format("[%s] cam : %d, pos : %d, count : %d, size : %d", vt_job_info[nJob].job_name.c_str(), k, 0, 0, W * H);
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			}
		}
#pragma endregion

#pragma region 스펙 비교(검사 결과 계산)
		double Spec_distance_LSL = 0;
		double Spec_distance_USL = 0;
		double Spec_distance_Tilt = 0;
		double Spec_distance_Tilt_Tolerance = 0;

		// (Distnace) Data 저장 
		for (int nPos = 0; nPos < 8; nPos++)
		{
			switch (nPos)
			{
				case 0:	real_cam = camBuf.at(1); m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][0].dWidthDistance;			break;
				case 1:	real_cam = camBuf.at(3); m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][0].dWidthDistance;			break;
				case 2:	real_cam = camBuf.at(3); m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][0].dHeightDistance;		break;
				case 3:	real_cam = camBuf.at(2); m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][0].dHeightDistance;		break;
				case 4:	real_cam = camBuf.at(2); m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][0].dWidthDistance;			break;
				case 5:	real_cam = camBuf.at(0); m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][0].dWidthDistance;			break;
				case 6:	real_cam = camBuf.at(0); m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][0].dHeightDistance;		break;
				case 7:	real_cam = camBuf.at(1); m_dDistanceInspDataResult[nPos] = m_stInsp_DistanceResult[real_cam][0].dHeightDistance;		break;
			}
		}
		// (Distnace) 판정 
		for (int nPos = 0; nPos < 8; nPos++)
		{
			Spec_distance_LSL = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(nPos);
			Spec_distance_USL = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(nPos);

			if (m_dDistanceInspDataResult[nPos] < Spec_distance_LSL ||
				m_dDistanceInspDataResult[nPos] > Spec_distance_USL)
			{
				m_dDistanceInspJudgeResult[nPos] = FALSE;
			}
		}
		for (int nPos = 0; nPos < 8; nPos++)
		{
			if (m_dDistanceInspJudgeResult[nPos] != TRUE)
			{
				switch (nPos)
				{
				case 0:	real_cam = camBuf.at(1); break;
				case 1:	real_cam = camBuf.at(3); break;
				case 2:	real_cam = camBuf.at(3); break;
				case 3:	real_cam = camBuf.at(2); break;
				case 4:	real_cam = camBuf.at(2); break;
				case 5:	real_cam = camBuf.at(0); break;
				case 6:	real_cam = camBuf.at(0); break;
				case 7:	real_cam = camBuf.at(1); break;
				}
				m_stInsp_DistanceResult[real_cam][0].bNG = TRUE;
			}
		}

		// (Tilt) Data 저장 
		for (int nPos = 0; nPos < 4; nPos++)
		{
			switch (nPos)
			{
			case 0:		m_dDistanceInspSubDataResult[nPos] = fabs(m_dDistanceInspDataResult[0] - m_dDistanceInspDataResult[1]);		break;
			case 1:		m_dDistanceInspSubDataResult[nPos] = fabs(m_dDistanceInspDataResult[2] - m_dDistanceInspDataResult[3]);		break;
			case 2:		m_dDistanceInspSubDataResult[nPos] = fabs(m_dDistanceInspDataResult[4] - m_dDistanceInspDataResult[5]);		break;
			case 3:		m_dDistanceInspSubDataResult[nPos] = fabs(m_dDistanceInspDataResult[6] - m_dDistanceInspDataResult[7]);		break;
			}
		}

		// (Tilt) 판정
		for (int nPos = 0; nPos < 4; nPos++)
		{
			Spec_distance_Tilt			 = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(nPos);
			Spec_distance_Tilt_Tolerance = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(0);

			if (fabs(Spec_distance_Tilt - m_dDistanceInspSubDataResult[nPos]) > Spec_distance_Tilt_Tolerance)
				m_dDistanceInspSubJudgeResult[nPos] = FALSE;
		}
		for (int nPos = 0; nPos < 4; nPos++)
		{
			if (m_dDistanceInspSubJudgeResult[nPos] != TRUE)
			{
				switch (nPos)
				{
				case 0:	real_cam = camBuf.at(1); m_stInsp_DistanceResult[real_cam][0].bNG = TRUE; real_cam = camBuf.at(3); m_stInsp_DistanceResult[real_cam][0].bNG = TRUE; break;
				case 1:	real_cam = camBuf.at(3); m_stInsp_DistanceResult[real_cam][0].bNG = TRUE; real_cam = camBuf.at(2); m_stInsp_DistanceResult[real_cam][0].bNG = TRUE; break;
				case 2:	real_cam = camBuf.at(2); m_stInsp_DistanceResult[real_cam][0].bNG = TRUE; real_cam = camBuf.at(0); m_stInsp_DistanceResult[real_cam][0].bNG = TRUE; break;
				case 3:	real_cam = camBuf.at(0); m_stInsp_DistanceResult[real_cam][0].bNG = TRUE; real_cam = camBuf.at(1); m_stInsp_DistanceResult[real_cam][0].bNG = TRUE; break;
				}
			}
		}
#pragma endregion

#pragma region 최종 판정
		m_bInspResult[nJob] = TRUE;
		for (int nPos = 0; nPos < 8; nPos++)
		{
			if (m_dDistanceInspJudgeResult[nPos] != TRUE)
				m_bInspResult[nJob] = FALSE;
		}
		for (int nPos = 0; nPos < 4; nPos++)
		{
			if (m_dDistanceInspSubJudgeResult[nPos] != TRUE)
				m_bInspResult[nJob] = FALSE;
		}
#pragma endregion
		for (int nPos = 0; nPos < 8; nPos++)
		{
			str.Format("[%s] P%d(%s) D : %.3f( %.3f ~ %.3f )",		vt_job_info[nJob].job_name.c_str(),
																	nPos + 1,
																	m_dDistanceInspJudgeResult[nPos] ? "OK" : "NG!",
																	m_dDistanceInspDataResult[nPos],
																	Spec_distance_LSL,
																	Spec_distance_USL);
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
		for (int nPos = 0; nPos < 4; nPos++)
		{
			str.Format("[%s] Tilt%d(%s) T : %.3f( %d ~ %.3f )",		vt_job_info[nJob].job_name.c_str(),
																	nPos + 1,
																	m_dDistanceInspSubJudgeResult[nPos] ? "OK" : "NG!",
																	m_dDistanceInspSubDataResult[nPos],
																	0,
																	vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(nPos) + vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(0));
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}

		str.Format("[%s] Inspection End", vt_job_info[nJob].job_name.c_str());
		//tnwjddl
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_UPDATE_INSP_RESULT, nJob);
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 0;
		ReleaseSRWLockExclusive(&g_srwlock);

		if (bAllFind != TRUE)	m_bInspResult[nJob] = FALSE;	// 패턴을 못찾을 경우에는 무조건 NG

		if (m_bInspResult[nJob])	nRet = 1;
		else						nRet = 2;
	}
	break;
#pragma region 시뮬레이션 
	case 1000:
	{
		m_bInspResult[nJob] = simulration_assemble_insp(nJob);
		AcquireSRWLockExclusive(&g_srwlock); // 동기화 시킴 Tkyuha 20211027
		m_nSeqProcess[nJob] = 400;
		ReleaseSRWLockExclusive(&g_srwlock);
	}
#pragma endregion
	break;
	}

	return nRet;
}
BOOL CLET_AlignClientDlg::simulration_assemble_insp(int nJob)
{
	CString str;
	int nRet = 0, real_cam = 0;
	int camCount = vt_job_info[nJob].num_of_camera;
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;

	// 알고리즘 시작.

	for (int nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		m_pPattern[real_cam].pDlg = this;
		m_pPattern[real_cam].nPos = 0;
		m_pPattern[real_cam].nCam = nCam;
		m_pPattern[real_cam].nSearchCount = 2;  //2point search
		m_pPattern[real_cam].nJob = nJob;

		m_bFindPatternEnd[real_cam] = FALSE;
		m_bFindPattern[real_cam] = TRUE;

		AfxBeginThread(Thread_AssembleInspection, &m_pPattern[real_cam]);
	}

	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	int MS_TIMEOUT = 10000;

	BOOL all_insp_end = TRUE;
	while (nEtick - nStick <= MS_TIMEOUT) {
		Sleep(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_insp_end = TRUE;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];

			if (m_bFindPatternEnd[real_cam] != TRUE)
				all_insp_end = FALSE;
		}

		if (all_insp_end == TRUE) break;

		if (nEtick - nStick == MS_TIMEOUT)
		{
			str.Format("TimeOut(ms : %d) ", MS_TIMEOUT);
			::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		}
	}
	if (all_insp_end != TRUE) return FALSE;

	return all_insp_end;
}

void CLET_AlignClientDlg::setViewerReferencePos()
{
	CFormMainView *pFormMain = (CFormMainView *)m_pForm[FORM_MAIN];
	CFormCameraView *pFormCamera = (CFormCameraView *)m_pForm[FORM_CAMERA];
	CFormMachineView *pFormMachine = (CFormMachineView *)m_pForm[FORM_MACHINE];

	// 보류
#ifndef JOB_INFO
	for (int nCam = 0; nCam < m_nNumCamera; nCam++)
	{
		int m_nNumPos = m_pViewDisplayInfo[nCam].getMarkCount() + m_pViewDisplayInfo[nCam].getCaliperCount();

		for (int nPos = 0; nPos < m_nNumPos; nPos++)
		{
			double posX = GetMatching().getRefX(nCam, nPos);
			double posY = GetMatching().getRefY(nCam, nPos);

			int nIndex = nCam * m_nNumPos + nPos;

			pFormMain->m_pDlgViewerMain[nCam]->GetViewer().setRefPosX(nIndex % 4, posX);
			pFormMain->m_pDlgViewerMain[nCam]->GetViewer().setRefPosY(nIndex % 4, posY);
			pFormMain->m_pDlgViewerMain[nCam]->GetViewer().Invalidate();

			pFormCamera->m_ViewerCamera.setRefPosX(nIndex % 4, posX);
			pFormCamera->m_ViewerCamera.setRefPosY(nIndex % 4, posY);
			pFormCamera->m_ViewerCamera.Invalidate();

			pFormMachine->m_pDlgViewerMachine[nCam]->GetViewer().setRefPosX(nIndex % 4, posX);
			pFormMachine->m_pDlgViewerMachine[nCam]->GetViewer().setRefPosY(nIndex % 4, posY);
			pFormMachine->m_pDlgViewerMachine[nCam]->GetViewer().Invalidate();
		}
	}
#else

	for (int nJob = 0; nJob < vt_job_info.size(); nJob++)
	{
		for (int nCam = 0; nCam < vt_job_info[nJob].num_of_camera; nCam++)
		{
			for (int nPos = 0; nPos < vt_job_info[nJob].num_of_position; nPos++)
			{
				double posX = GetMatching(nJob).getRefX(nCam, nPos);
				double posY = GetMatching(nJob).getRefY(nCam, nPos);

				int nIndex = nCam * vt_job_info[nJob].num_of_position + nPos;

				int viewer = vt_job_info[nJob].viewer_index[nCam];
				//pFormMain->m_pDlgViewerMain[viewer]->GetViewer().setRefPosX(nIndex % 4, posX);
				//pFormMain->m_pDlgViewerMain[viewer]->GetViewer().setRefPosY(nIndex % 4, posY);
				//pFormMain->m_pDlgViewerMain[viewer]->GetViewer().Invalidate();


				//pFormMachine->m_pDlgViewerMachine[viewer]->GetViewer().setRefPosX(nIndex % 4, posX);
				//pFormMachine->m_pDlgViewerMachine[viewer]->GetViewer().setRefPosY(nIndex % 4, posY);
				//pFormMachine->m_pDlgViewerMachine[viewer]->GetViewer().Invalidate();

				pFormMain->m_pDlgViewerMain[viewer]->GetViewer().AddSoftGraphic(new GraphicPoint(posX, posY, Gdiplus::Color(0xffff0000), 5));
				pFormMachine->m_pDlgViewerMachine[viewer]->GetViewer().AddSoftGraphic(new GraphicPoint(posX, posY, Gdiplus::Color(0xffff0000), 5));

				int real_cam = vt_job_info[nJob].camera_index[nCam];
				if (pFormCamera->curr_cam == real_cam)
				{
					//pFormCamera->m_ViewerCamera.setRefPosX(nIndex % 4, posX);
					//pFormCamera->m_ViewerCamera.setRefPosY(nIndex % 4, posY);
					//pFormCamera->m_ViewerCamera.Invalidate();
					pFormCamera->m_ViewerCamera.AddSoftGraphic(new GraphicPoint(posX, posY, Gdiplus::Color(0xffff0000), 5));
				}
			}
		}
	}
#endif
}

int CLET_AlignClientDlg::algorithm_exist_insp_assemble(BYTE *pImage, int nJob, int nCam, BOOL bManual)
{
	BOOL bNG = FALSE;
	BOOL bInspResult = 3;
	CString strTemp;
	 
	double avgLimit			= vt_job_info[nJob].model_info.getInspSpecParaInfo().getExistPanelGray();
	double avgDummyLimit	= vt_job_info[nJob].model_info.getInspSpecParaInfo().getExistDummyGray();
	int real_cam			= vt_job_info[nJob].camera_index[nCam];

	int W = m_stCamInfo[real_cam].w;
	int H = m_stCamInfo[real_cam].h;

	cv::Mat img(H, W, CV_8UC1, pImage);
	std::vector < std::vector<cv::Point> >contours;

	cv::Scalar scalar = cv::mean(img);
	if (scalar.val[0] < 10)
	{
		bInspResult = -1;
		strTemp.Format("Averge Gray(%.1f) less than 10!! NG!!!", scalar.val[0]);
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
		bNG = TRUE;
	}
	else
	{
		CRect rectROI = GetMatching(nJob).getSearchROI(nCam, 0);

		if (rectROI.Width() <= 0 || rectROI.Height() <= 0)
		{
			rectROI.left = 10;
			rectROI.top = 10;
			rectROI.right = W - 10;
			rectROI.bottom = H - 10;
		}

		cv::imwrite("c:\\ld_src_img.jpg", img);

		cv::Rect roi;
		roi.x = rectROI.left;
		roi.y = rectROI.top;
		roi.width = rectROI.Width();
		roi.height = rectROI.Height();

		//cv::Mat InspImg = img(cv::Rect(rectROI.left, rectROI.top, rectROI.Width(), rectROI.Height()));
		cv::Mat InspImg;
		img(roi).copyTo(InspImg);
		scalar = cv::mean(InspImg);

		cv::imwrite("c:\\ld_org_img.jpg", InspImg);

		GetMatching(nJob).endInSearch(&InspImg, &InspImg);

		cv::imwrite("c:\\ld_end_in_search.jpg", InspImg);

		GetMatching(nJob).InspectionEnhance(&InspImg, &InspImg, 1);

		cv::imwrite("c:\\ld_enhance.jpg", InspImg);

		int thresh = avgLimit;
		cv::threshold(InspImg, InspImg, thresh, 255, cv::THRESH_BINARY_INV);

		cv::imwrite("c:\\ld_threahold.jpg", InspImg);
		
		//cv::findContours(InspImg, contours, CV_RETR_LIST, CV_CHAIN_APPROX_NONE);
		cv::findContours(InspImg, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_NONE);


		BOOL separ_find = FALSE;

		int contours_count = 0;
		m_RectExistBlob.assign(contours.size(), 0);
		for (int i = 0; i < contours.size(); i++)
		{
			cv::Rect rect = cv::boundingRect(contours[i]);
			if (rect.width > rectROI.Width() / 2)
			{
				separ_find = TRUE;
				m_RectExistBlob[contours_count].left = rect.x;
				m_RectExistBlob[contours_count].top = rect.y;
				m_RectExistBlob[contours_count].right = rect.x + rect.width;
				m_RectExistBlob[contours_count].bottom = rect.y + rect.height;
				contours_count++;
			}
		}


		if (separ_find)
		{
			bInspResult = 2;
		}
		else
		{
			if (scalar.val[0] < vt_job_info[nJob].model_info.getInspSpecParaInfo().getExistPanelGray())
			{
				bInspResult = 1;
			}
			else
			{
				bInspResult = 3;
			}
		}
	}

	CString strObject;

	if (bInspResult == 3)			strObject = "Empty";
	else if (bInspResult == 1)		strObject = "GLASS";
	else if (bInspResult == 2)		strObject = "Separator";
	else if (bInspResult == -1)		strObject = "Light Error";

	strTemp.Format("Result : %s - %s", strObject, bNG ? "NG" : "OK");
	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

	m_nExistResult = bInspResult;
	m_dExistResultData = scalar.val[0];
	m_strExistResult = strObject;

	contours.clear();

	return bInspResult;
}

BOOL CLET_AlignClientDlg::find_pf_film_pattern(BYTE* pImage, int nJob, int nCam)
{
	BOOL bFind = TRUE;

	CPatternMatching* pPattern = &GetMatching(nJob);
	int real_cam = vt_job_info[nJob].camera_index[nCam];

	int W = vt_job_info[nJob].camera_size[nCam].x;
	int H = vt_job_info[nJob].camera_size[nCam].y;


	for (int nPos = 0; nPos < 4; nPos++)
	{
		pPattern->findPattern(pImage, nCam, nPos, W, H);
		CFindInfo find = GetMatching(nJob).getFindInfo(nCam, nPos);

		m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[0] = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[0] = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

		if (find.GetFound() != FIND_OK )
			bFind = FALSE;
	}

	if (vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING_LINE_THETA)
	{
		double dx = 0.0, dy = 0.0, dt = 0.0, posx = 0.0, posy = 0.0;

		BOOL bFixtureUse = vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();

		// panel mark 정보 이용하여 fixture로 활용
		for (int nPos = 0; nPos < 2; nPos++)
		{
			if (bFixtureUse)
			{
				double refX = GetMatching(nJob).getFixtureX(nCam, nPos);
				double refY = GetMatching(nJob).getFixtureY(nCam, nPos);
				double posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
				double posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

				CFindInfo pFindInfo = GetMatching(nJob).getFindInfo(nCam, nPos);
				pFindInfo.SetMatchingXPos(posX);
				pFindInfo.SetMatchingYPos(posY);
				GetMatching(nJob).setFindInfo(nCam, nPos, pFindInfo);

				dx = posX - refX;
				dy = posY - refY;
				dt = 0.0;
			}

			m_pDlgCaliper->m_Caliper[real_cam][nPos][0].processCaliper(pImage, W, H, dx, dy, dt);
		}
	}
	

	return bFind;
}

BOOL CLET_AlignClientDlg::find_pf_film_edge_pattern(BYTE* pImage, int nJob, int nCam)
{
	BOOL bFind = TRUE;

	CPatternMatching* pPattern = &GetMatching(nJob);
	int real_cam = vt_job_info[nJob].camera_index[nCam];

	int w = vt_job_info[nJob].camera_size[nCam].x;
	int h = vt_job_info[nJob].camera_size[nCam].y;

	for (int nPos = 0; nPos < 2; nPos++)
	{
		pPattern->findPattern(pImage, nCam, nPos, w, h);
		CFindInfo find = GetMatching(nJob).getFindInfo(nCam, nPos);

		m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[0] = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[0] = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

		if (find.GetFound() != FIND_OK)
			bFind = FALSE;
	}

	for (int nPos = 2; nPos < 4; nPos++)
	{
		double dx, dy, dt = 0;

		BOOL bFixtureUse = vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();
		if (bFixtureUse)
		{
			double fixtureX = GetMatching(nJob).getFixtureX(nCam, nPos);
			double fixturY = GetMatching(nJob).getFixtureY(nCam, nPos);
			double posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
			double posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

			dx = posX - fixtureX;
			dy = posY - fixturY;
			dt = 0.0;

		}

		m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].processCaliper(pImage, w, h, dx, dy, dt, TRUE);
		m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_2].processCaliper(pImage, w, h, dx, dy, dt, TRUE);

		BOOL bFindLine[2];
		bFindLine[0] = false; 
		bFindLine[1] = false;
		sLine line_info [2];

		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].m_lineInfo;
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_2].m_lineInfo;
		bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].getIsMakeLine();
		bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_2].getIsMakeLine();

		if (bFindLine[0] && bFindLine[1])
		{
			sLine lineHori = line_info[0];
			sLine lineVert = line_info[1];

			CCaliper::cramersRules(-lineHori.a, 1, -lineVert.a, 1, lineHori.b, lineVert.b, &m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[1], &m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[1]);

			double dAngle = calcIncludedAngle(lineHori, lineVert);

			GetMatching(nJob).getFindInfo(nCam, nPos).SetXPos(m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[1]);
			GetMatching(nJob).getFindInfo(nCam, nPos).SetYPos(m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[1]);
		}
		else bFind = false;
	}

	return bFind;
}

//hsj 2022-01-15 캘리퍼 이용하여 패널 엣지 찾기
BOOL CLET_AlignClientDlg::find_pf_panel_edge(BYTE* pImage, int nJob, int nCam, BOOL bUseManulMark)
{
	BOOL bFind[2] = { TRUE, TRUE };

	CPatternMatching* pPattern = &GetMatching(nJob);
	int real_cam = vt_job_info[nJob].camera_index[nCam];

	int w = vt_job_info[nJob].camera_size[nCam].x;
	int h = vt_job_info[nJob].camera_size[nCam].y;

	//0 : 왼쪽 1: 오른쪽
	BOOL bFindLine[2];
	bFindLine[0] = false;
	bFindLine[1] = false;
	sLine line_info[2];

	sLine center_line_panel[2];
	CPoint pCenter[2];
	sLine center_to_panel_line[2];
	cv::Rect inspRoi[2];

	int cut_start_x[2], cut_end_x[2], cut_start_y[2], cut_end_y[2];

	for (int nPos = 0; nPos < 2; nPos++)
	{
		BOOL bFindPattern = TRUE;
		double dx=0, dy=0, dt = 0;

		BOOL bFixtureUse = vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();
		
		if( bUseManulMark == FALSE ) bFindPattern = GetMatching(nJob).findPattern(pImage, nCam, nPos, w, h);

		if (bFixtureUse)
		{
			//bFindPattern = GetMatching(nJob).findPattern(pImage, nCam, nPos, w, h);

			if (bFindPattern)
			{
				double fixtureX = GetMatching(nJob).getFixtureX(nCam, nPos);
				double fixturY = GetMatching(nJob).getFixtureY(nCam, nPos);
				double posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
				double posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

				dx = posX - fixtureX;
				dy = posY - fixturY;
				dt = 0.0;
			}
			else
			{
				bFind[nPos] = FALSE;
			}
		}
		m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].processCaliper(pImage, w, h, dx, dy, dt, TRUE);
		m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_2].processCaliper(pImage, w, h, dx, dy, dt, TRUE);
#pragma region 노치곡선의 윗쪽 선 찾기
		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].m_lineInfo;
		bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].getIsMakeLine();
#pragma endregion

#pragma region 노치곡선의 아랫쪽 선 찾기
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_2].m_lineInfo;
		bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_2].getIsMakeLine();
#pragma endregion

#pragma region 기울기를 반영한 중앙선 찾기
		int cy;
		// y = ax + b

		//BOOL bFindPattern;

		//bFindPattern = GetMatching(nJob).findPattern(pImage, nCam, nPos, w, h);

		if (bFindLine[0] && bFindLine[1])
		{
			//중심점을 지나는 중앙선
			center_line_panel[nPos].a = (line_info[0].a + line_info[1].a) / 2;

			//윗선과 아랫선의 중심점 y
			// hsj 2022-02-17 중앙의 y절편은 마크등록한 x를 이용해서 구하기 (만약 마크를 못찾으면 설정한 켈리퍼의 중앙값으로..)
			int nUp_cy, nDown_cy;
			int x;

			if (bFindPattern)
			{
				x = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
			}
			else
			{
				x = line_info[0].sx;
				bFind[nPos] = FALSE;
			}

			nUp_cy = line_info[0].a * x + line_info[0].b;
			nDown_cy = line_info[1].a * x + line_info[1].b;

			cy = (nUp_cy + nDown_cy) / 2;
			
			//b=y-ax
			center_line_panel[nPos].b = cy-center_line_panel[nPos].a*x;
		}
		else
		{
			bFind[nPos] = FALSE;
		}
#pragma endregion


#pragma region 중앙선과 노치라인이 만나는 위치(X,Y) 찾기
		
		if (bFindPattern)
		{
			cut_start_x[nPos] = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos() - 100;
			cut_end_x[nPos] = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos() + 100;

			cut_start_y[nPos] = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos() - 100;
			cut_end_y[nPos] = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos() + 100;
		}
		else
		{
			cut_start_x[nPos] = 0;
			cut_end_x[nPos] = w;

			cut_start_y[nPos] = 0;
			cut_end_y[nPos] = h;

			bFind[nPos] = FALSE;
		}

		if (cut_start_x[nPos] < 0 || cut_start_x[nPos] > w) cut_start_x[nPos] = 0;
		if (cut_end_x[nPos] < 0 || cut_end_x[nPos] > w ) cut_end_x[nPos] = w;
		if (cut_start_y[nPos] < 0 || cut_start_x[nPos] > h)cut_start_y[nPos] = 0;
		if (cut_end_y[nPos] < 0 || cut_end_y[nPos] > h) cut_end_y[nPos] = h;

		inspRoi[nPos] = cv::Rect(cut_start_x[nPos], cut_start_y[nPos], cut_end_x[nPos] - cut_start_x[nPos], cut_end_y[nPos] - cut_start_y[nPos]);
		
		cv::Mat mat(h,w, CV_8UC1, pImage);
		cv::Mat  imgCut_ThreshodImage = mat(inspRoi[nPos]).clone();
	
		// hsj 2022-02-07 필름검사 threshold 기능 추가
		if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getUsePanelThresh_Auto() != TRUE)
		{
			int nthresh = vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelThresh();
			cv::threshold(imgCut_ThreshodImage, imgCut_ThreshodImage, nthresh, 255, CV_THRESH_BINARY);
		}
		else
		{
			//otsu 영상처리
			cv::threshold(imgCut_ThreshodImage, imgCut_ThreshodImage, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
		}

		// y = ax + b
		// x=(y-b)/a
		// y' = center_line_panel[nPos].a * X+ center_line_panel[nPos].b
		// center_line_panel[nPos].a * ndist + y'
		uchar* Raw = imgCut_ThreshodImage.data;
		int nSearch_y, nSearch_x;
		
		// hsj 2022-02-04 예외처리 추가
		if (bFind[nPos])
		{
			// 왼쪽 패널 만나는 점 찾기
			if (nPos == 0)
			{
				for (int ndist = 0; ndist < inspRoi[nPos].width-1; ndist++)
				{
					// hsj 2022-01-27 x찾는 식 수정
					int x;
					x = ndist + cut_start_x[nPos];

					nSearch_y = center_line_panel[nPos].a * x + center_line_panel[nPos].b;
					nSearch_y = nSearch_y - cut_start_y[nPos] - 1;

					//만나는 점 찾기
					if (Raw[nSearch_y * imgCut_ThreshodImage.cols + ndist] == 255)
					{
						nSearch_x = ndist + cut_start_x[nPos];
						nSearch_y = nSearch_y + cut_start_y[nPos] + 1;
					
						pCenter[nPos].x = nSearch_x;
						pCenter[nPos].y = nSearch_y;

						break;
					}
				}
			}
			// 오른쪽 패널 만나는 점 찾기 
			else
			{
				for (int ndist = inspRoi[nPos].width-1; ndist > 0; ndist--)
				{
					// hsj 2022-01-27 x찾는 식 수정
					int x;
					x = ndist + cut_start_x[nPos];

					nSearch_y = center_line_panel[nPos].a * x + center_line_panel[nPos].b;
					nSearch_y = nSearch_y - cut_start_y[nPos] - 1;

					//만나는 점 찾기
					if (Raw[nSearch_y * imgCut_ThreshodImage.cols + ndist] == 255)
					{
						nSearch_x =ndist + cut_start_x[nPos];
						nSearch_y = nSearch_y + cut_start_y[nPos] + 1;
						
 						pCenter[nPos].x = nSearch_x;
						pCenter[nPos].y = nSearch_y;

						break;
					}
					
				}
				
			}	
		}
#pragma endregion

#pragma region 노치곡선 위쪽 선에 수직하고 X,Y을 지나는 직선 찾기
		center_to_panel_line[nPos].a = -1.0 / line_info[0].a;
		// y = ax + b
		// ax=y-b
		// x= (y-b)/a;
		// b= y - ax
		center_to_panel_line[nPos].b = pCenter[nPos].y - (pCenter[nPos].x * center_to_panel_line[nPos].a);
#pragma endregion

#pragma region 위쪽 선과 수직한 직선의 교점 찾기
		cv::Point2f p_result;

		// y = m1*x + b1, y = m2*x + b2 두 직선의 교차점을 구하는 함수
		p_result =IntersectionPoint2(line_info[0].a, line_info[0].b, center_to_panel_line[nPos].a, center_to_panel_line[nPos].b);

		m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[0] = p_result.x;
		m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[0] = p_result.y;

		GetMatching(nJob).getFindInfo(nCam, nPos).SetXPos(m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[0]);
		GetMatching(nJob).getFindInfo(nCam, nPos).SetYPos(m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[0]);
#pragma endregion

		// KBJ 2022-07-18 필름검사 밀린 이미지 찍히는 원인인거 같은데 일단 release() 안되어 있어서 추가
		mat.release();
		imgCut_ThreshodImage.release();
	}

	if(bFind[0] && bFind[1]) return TRUE;
	else					 return FALSE;

}

// 캘리퍼 이용하여 필름 엣지 찾기
BOOL CLET_AlignClientDlg::find_pf_film_edge(BYTE* pImage, int nJob, int nCam, BOOL bUseManulMark)
{

	BOOL bFind = TRUE;

	CPatternMatching* pPattern = &GetMatching(nJob);
	int real_cam = vt_job_info[nJob].camera_index[nCam];

	int w = vt_job_info[nJob].camera_size[nCam].x;
	int h = vt_job_info[nJob].camera_size[nCam].y;

	for (int nPos = 2; nPos < 4; nPos++)
	{
		double dx=0, dy=0, dt = 0;

		BOOL bFixtureUse = vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();
		if (bFixtureUse)
		{
			BOOL bFindPattern = TRUE;

			if( bUseManulMark == FALSE ) bFindPattern=GetMatching(nJob).findPattern(pImage, nCam, nPos, w, h);

			if (bFindPattern)
			{
				double fixtureX = GetMatching(nJob).getFixtureX(nCam, nPos);
				double fixturY = GetMatching(nJob).getFixtureY(nCam, nPos);
				double posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
				double posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

				dx = posX - fixtureX;
				dy = posY - fixturY;
				dt = 0.0;
			}
			else bFind = FALSE;
		}

		m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].processCaliper(pImage, w, h, dx, dy, dt, TRUE);
		m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_2].processCaliper(pImage, w, h, dx, dy, dt, TRUE);
	
		BOOL bFindLine[2];
		bFindLine[0] = false;
		bFindLine[1] = false;
		sLine line_info[2];

		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].m_lineInfo;
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_2].m_lineInfo;
		bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].getIsMakeLine();
		bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_2].getIsMakeLine();

		if (bFindLine[0] && bFindLine[1])
		{
			sLine lineHori = line_info[0];
			sLine lineVert = line_info[1];

			CCaliper::cramersRules(-lineHori.a, 1, -lineVert.a, 1, lineHori.b, lineVert.b, &m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[1], &m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[1]);

			double dAngle = calcIncludedAngle(lineHori, lineVert);

			GetMatching(nJob).getFindInfo(nCam, nPos).SetXPos(m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[1]);
			GetMatching(nJob).getFindInfo(nCam, nPos).SetYPos(m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[1]);
		}
		else bFind = false;
	}

	return bFind;
}

// 캘리퍼 이용하여 스테이지 엣지 찾기
BOOL CLET_AlignClientDlg::find_pf_film_stagedge(BYTE* pImage, int nJob, int nCam,double cx,double cy, double a, double b, double& distance)
{
	BOOL bFind = TRUE;
	double dx = 0, dy = 0, dt = 0;

	int nPos = 0;
	int real_cam = vt_job_info[nJob].camera_index[nCam];
	int w = vt_job_info[nJob].camera_size[nCam].x;
	int h = vt_job_info[nJob].camera_size[nCam].y;

	m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_6].processCaliper(pImage, w, h, dx, dy, dt, TRUE);

	BOOL bFindLine=false;
	sLine line_info;
	
	line_info = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_6].m_lineInfo;
	bFindLine = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_6].getIsMakeLine();

	if (bFindLine)
	{
		if (a != 0)
		{
			//cx = (Type_Left Point.x + Type Rihgt Point.x /2)
			//cy = (Type_Left Point.y + Type Rihgt Point.y /2)

			double _A, _B;

			cv::Point point_stage = cv::Point(cx, line_info.a * cx + line_info.b);

			_A = -1 / a;
			_B = point_stage.x / a + point_stage.y;

			cv::Point2f pt = IntersectionPoint2(a, b, _A, _B);

			distance = GetDistance(pt, point_stage);
		}
		else
		{
			distance = fabs(line_info.sy-cy);
		}
	}
	else bFind = false;

	return bFind;
}
//kmb 230112 패턴과 켈리퍼의 만나는점 찾기
BOOL CLET_AlignClientDlg::find_panel_mark_edge_line(BYTE* pImage, int nJob, int nCam, double *PosX, double *PosY) {
	BOOL bFind[2] = { TRUE, TRUE };
	BOOL bFindLine[2] = { TRUE,TRUE };
	sLine line_info;
	sPoint pts;
	sPoint pln;
	int nPos = 0;
	int real_cam = vt_job_info[nJob].camera_index[nCam];

	CPatternMatching* pPattern = &GetMatching(nJob);
	CFindInfo find = GetMatching(nJob).getFindInfo(nCam, nPos);

	int W = vt_job_info[nJob].camera_size[nCam].x;
	int H = vt_job_info[nJob].camera_size[nCam].y;

#pragma region 마크 정보
	pts.x = *PosX;
	pts.y = *PosY;

	pPattern->findPattern(pImage, nCam, nPos, W, H);
	if (find.GetFound() != FIND_OK)
		bFind[nPos] = FALSE;
#pragma endregion
#pragma region 켈리퍼 정보 받기
	m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].processCaliper(pImage, W, H, 0, 0, 0, TRUE);

	line_info = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].m_lineInfo;

	bFindLine[nPos] = m_pDlgCaliper->m_Caliper[real_cam][nPos][C_CALIPER_POS_1].getIsMakeLine();

	m_pDlgCaliper->m_pCaliperParam->updateUIFromData();
	m_pDlgCaliper->m_pCaliperParam->updateCoordinates();

#pragma endregion
#pragma region 만나는점 수선의발 내리기
	GetMatching(nJob).compute_orthogonal_point_on_line(line_info, pts, pln);
	*PosX = pln.x;
	*PosY = pln.y;
#pragma endregion
	if (bFind[0] == TRUE && bFind[1] == TRUE) return TRUE;
	else									  return FALSE;
}
// 패턴 이용하여 패널 마크 찾기
BOOL CLET_AlignClientDlg::find_pf_panel_pattern(BYTE* pImage, int nJob, int nCam)
{
	BOOL bFind[2] = { TRUE, TRUE };

	CPatternMatching* pPattern = &GetMatching(nJob);
	int real_cam = vt_job_info[nJob].camera_index[nCam];

	int W = vt_job_info[nJob].camera_size[nCam].x;
	int H = vt_job_info[nJob].camera_size[nCam].y;


	for (int nPos = 0; nPos < 2; nPos++)
	{
		pPattern->findPattern(pImage, nCam, nPos, W, H);
		CFindInfo find = GetMatching(nJob).getFindInfo(nCam, nPos);

		m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[0] = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[0] = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

		if (find.GetFound() != FIND_OK)
			bFind[nPos] = FALSE;
	}

#ifdef _SDV_VAT  // Mark Search 실패시 VAT 활용 22021011 Tkyuha
	if (m_classSamsungVATWraper.Agent_Disconnect())
	{
		CString error = "Normal", posName;
		CString model = vt_job_info[nJob].model_info.getModelID();
		CString cellId = vt_job_info[nJob].main_object_id.c_str();

		int timeout = 5000;
		for (int nPos = 0; nPos < 2; nPos++)
		{
			if (bFind[nPos] == FALSE)
			{
				posName = (nPos == 0) ? "LEFT" : "RIGHT";
				DLRst result0 = m_classSamsungVATWraper.Agent_ReqDL_Bytes((LPSTR)(LPCTSTR)cellId, ToolType_Mark, (LPSTR)(LPCTSTR)model, timeout, (LPSTR)(LPCTSTR)posName, pImage, W*H, W, W, H, error);

				if (error == "None")
				{
					CFindInfo pFindInfo = GetMatching(nJob).getFindInfo(nCam, nPos);
					pFindInfo.SetXPos(result0.X);
					pFindInfo.SetYPos(result0.Y);
					pFindInfo.SetAngle(result0.T);
					pFindInfo.SetScore(result0.Score);

					pFindInfo.SetFound(FIND_OK);
					GetMatching(nJob).setFindInfo(nCam, nPos, pFindInfo);

					m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[0] = result0.X;
					m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[0] = result0.Y;

					bFind[nPos] = TRUE;

					CString str;
					str.Format("_VAT_ [ panel find ]");
					add_process_history(str);
				}
			}
		}
	}
#endif

	if (vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING_LINE_THETA)
	{
		double dx = 0.0, dy = 0.0, dt = 0.0, posx = 0.0, posy = 0.0;

		BOOL bFixtureUse = vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();

		// panel mark 정보 이용하여 fixture로 활용
		for (int nPos = 0; nPos < 2; nPos++)
		{
			if (bFixtureUse)
			{
				double refX = GetMatching(nJob).getFixtureX(nCam, nPos);
				double refY = GetMatching(nJob).getFixtureY(nCam, nPos);
				double posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
				double posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

				CFindInfo pFindInfo = GetMatching(nJob).getFindInfo(nCam, nPos);
				pFindInfo.SetMatchingXPos(posX);
				pFindInfo.SetMatchingYPos(posY);
				GetMatching(nJob).setFindInfo(nCam, nPos, pFindInfo);

				dx = posX - refX;
				dy = posY - refY;
				dt = 0.0;
			}

			m_pDlgCaliper->m_Caliper[real_cam][nPos][0].processCaliper(pImage, W, H, dx, dy, dt);
		}
	}
	if (bFind[0] == TRUE && bFind[1] == TRUE) return TRUE;
	else									  return FALSE;
}

// 패턴 이용하여 필름 마크 찾기
BOOL CLET_AlignClientDlg::find_pf_film_pattern2(BYTE* pImage, int nJob, int nCam)
{
	BOOL bFind[2] = { TRUE, TRUE };

	CPatternMatching* pPattern = &GetMatching(nJob);
	int real_cam = vt_job_info[nJob].camera_index[nCam];

	int W = vt_job_info[nJob].camera_size[nCam].x;
	int H = vt_job_info[nJob].camera_size[nCam].y;


	for (int nPos = 2; nPos < 4; nPos++)
	{
		pPattern->findPattern(pImage, nCam, nPos, W, H);
		CFindInfo find = GetMatching(nJob).getFindInfo(nCam, nPos);

		m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[0] = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[0] = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

		if (find.GetFound() != FIND_OK)
			bFind[nPos-2] = FALSE;
	}

#ifdef _SDV_VAT  // Mark Search 실패시 VAT 활용 22021011 Tkyuha
	if (m_classSamsungVATWraper.Agent_Disconnect())
	{
		CString error = "Normal", posName;
		CString model = vt_job_info[nJob].model_info.getModelID();
		CString cellId = vt_job_info[nJob].main_object_id.c_str();

		int timeout = 5000;
		for (int nPos = 2; nPos < 4; nPos++)
		{
			if (bFind[nPos - 2] == FALSE)
			{
				posName = (nPos == 2) ? "TOP" : "BOTTOM";
				DLRst result0 = m_classSamsungVATWraper.Agent_ReqDL_Bytes((LPSTR)(LPCTSTR)cellId, ToolType_Mark, (LPSTR)(LPCTSTR)model, timeout, (LPSTR)(LPCTSTR)posName, pImage, W * H, W, W, H, error);

				if (error == "None")
				{
					CFindInfo pFindInfo = GetMatching(nJob).getFindInfo(nCam, nPos);
					pFindInfo.SetXPos(result0.X);
					pFindInfo.SetYPos(result0.Y);
					pFindInfo.SetAngle(result0.T);
					pFindInfo.SetScore(result0.Score);

					pFindInfo.SetFound(FIND_OK);
					GetMatching(nJob).setFindInfo(nCam, nPos, pFindInfo);
					CString str;
					str.Format("_VAT_ [ film find ]");
					add_process_history(str);

					m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[0] = result0.X;
					m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[0] = result0.Y;
					bFind[nPos - 2] = TRUE;
				}
			}
		}
	}
#endif

	if (vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING_LINE_THETA)
	{
		double dx = 0.0, dy = 0.0, dt = 0.0, posx = 0.0, posy = 0.0;

		BOOL bFixtureUse = vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();

		// panel mark 정보 이용하여 fixture로 활용
		for (int nPos = 0; nPos < 2; nPos++)
		{
			if (bFixtureUse)
			{
				double refX = GetMatching(nJob).getFixtureX(nCam, nPos);
				double refY = GetMatching(nJob).getFixtureY(nCam, nPos);
				double posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
				double posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

				CFindInfo pFindInfo = GetMatching(nJob).getFindInfo(nCam, nPos);
				pFindInfo.SetMatchingXPos(posX);
				pFindInfo.SetMatchingYPos(posY);
				GetMatching(nJob).setFindInfo(nCam, nPos, pFindInfo);

				dx = posX - refX;
				dy = posY - refY;
				dt = 0.0;
			}

			m_pDlgCaliper->m_Caliper[real_cam][nPos][0].processCaliper(pImage, W, H, dx, dy, dt);
		}
	}
	if (bFind[0] == TRUE && bFind[1] == TRUE)	return TRUE;
	else										return FALSE;
}

// hsj 2022-02-08 필름검사 L check 기능 추가
int CLET_AlignClientDlg::Panel_length_check_process(int nJob,BOOL prealign_test)
{
	BOOL ret = TRUE;
	CString str;

	int nCam = 0;
	int nPos = 0;
	double pixel_x[2] = { 0, };
	double pixel_y[2] = { 0, };
	double world_x[2] = { 0, };
	double world_y[2] = { 0, };

	pixel_x[0] = GetMatching(nJob).getFindInfo(nCam, nPos + 0).GetXPos();
	pixel_y[0] = GetMatching(nJob).getFindInfo(nCam, nPos + 0).GetYPos();
	pixel_x[1] = GetMatching(nJob).getFindInfo(nCam, nPos + 1).GetXPos();
	pixel_y[1] = GetMatching(nJob).getFindInfo(nCam, nPos + 1).GetYPos();

	GetMachine(nJob).PixelToWorld(0, 0, pixel_x[0], pixel_y[0], &world_x[0], &world_y[0]);
	GetMachine(nJob).PixelToWorld(0, 0, pixel_x[1], pixel_y[1], &world_x[1], &world_y[1]);

	double dx = world_x[1] - world_x[0];
	double dy = world_y[1] - world_y[0];
	double dist = sqrt(dx * dx + dy * dy);

	double dist_tor = vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelLcheckTorr();
	double dist_spec =vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelLcheckLength();
	//int target_dir = pModel->getAlignInfo().getAlignmentTargetDir();	// vertical or horizontal

	//if (target_dir == 1)	// vertical
	//	dist_spec = pModel->getAlignInfo().getLCheckSpecY();

	str.Format("length : %.3f", dist);
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	vt_result_info[nJob].length_check[nCam][nPos] = dist;
	vt_result_info[nJob].length_check_judge[nCam][nPos] = TRUE;

	if (fabs(dist_spec - dist) > dist_tor)
	{
		str.Format("[%s] L Check NG!!  limit : %.3f, tor : %.3f", vt_job_info[nJob].get_job_name(), dist_spec, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		//vt_result_info[nJob].each_Judge[nCam][nPos] = FALSE;
		vt_result_info[nJob].length_check_judge[nCam][nPos] = FALSE;
		ret = FALSE;
	}

	return ret;
}

int CLET_AlignClientDlg::Film_length_check_process(int nJob,BOOL prealign_test)
{
	BOOL ret = TRUE;
	CString str;

	int nCam = 0;
	int nPos = 2;
	double pixel_x[2] = { 0, };
	double pixel_y[2] = { 0, };
	double world_x[2] = { 0, };
	double world_y[2] = { 0, };

	pixel_x[0] = GetMatching(nJob).getFindInfo(nCam, nPos + 0).GetXPos();
	pixel_y[0] = GetMatching(nJob).getFindInfo(nCam, nPos + 0).GetYPos();
	pixel_x[1] = GetMatching(nJob).getFindInfo(nCam, nPos + 1).GetXPos();
	pixel_y[1] = GetMatching(nJob).getFindInfo(nCam, nPos + 1).GetYPos();

	GetMachine(nJob).PixelToWorld(0, 0, pixel_x[0], pixel_y[0], &world_x[0], &world_y[0]);
	GetMachine(nJob).PixelToWorld(0, 0, pixel_x[1], pixel_y[1], &world_x[1], &world_y[1]);

	double dx = world_x[1] - world_x[0];
	double dy = world_y[1] - world_y[0];
	double dist = sqrt(dx * dx + dy * dy);

	double dist_tor = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLcheckTorr();
	double dist_spec = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLcheckLength();
	//int target_dir = pModel->getAlignInfo().getAlignmentTargetDir();	// vertical or horizontal

	//if (target_dir == 1)	// vertical
	//	dist_spec = pModel->getAlignInfo().getLCheckSpecY();

	str.Format("length : %.3f", dist);
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	vt_result_info[nJob].length_check[nCam][nPos] = dist;
	vt_result_info[nJob].length_check_judge[nCam][nPos] = TRUE;

	if (fabs(dist_spec - dist) > dist_tor)
	{
		str.Format("[%s] L Check NG!!  limit : %.3f, tor : %.3f", vt_job_info[nJob].get_job_name(), dist_spec, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		//vt_result_info[nJob].each_Judge[nCam][nPos] = FALSE;
		vt_result_info[nJob].length_check_judge[nCam][nPos] = FALSE;
		ret = FALSE;
	}

	return ret;
}

BOOL CLET_AlignClientDlg::algorithm_PF_Film_insp(BYTE* pImage, int nJob, int nCam)
{
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
	BOOL bResult = TRUE;

	int nManualMark_count = 0;
	vt_result_info[nJob].pf_film_insp_data.clear();

	// 패널과 필름의 마크를 찾자.
	// kbj 2022-01-12
	/*	
	int nMethod = vt_job_info[nJob].model_info.getAlignInfo().getInspectionMethod();
	if(nMethod == DISTANCE_INSP_METHOD_M_TO_M)			find_pf_film_pattern(pImage, nJob, nCam);
	else if (nMethod == DISTANCE_INSP_METHOD_M_TO_E)	find_pf_film_edge_pattern(pImage, nJob, nCam);
	else if (nMethod == DISTANCE_INSP_METHOD_E_TO_E)
	{
		find_pf_panel_edge(pImage, nJob, nCam);
		find_pf_film_edge(pImage, nJob, nCam);
	}
	*/

	// hsj 2022-01-17 필름검사 마크 찾을 시 캘리퍼 사용 유무에 따른 마크찾기
	bool bPanel_caliper =vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelCaliperEnable();
	bool bFilme_caliper = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmCaliperEnable();

	// KBJ 2022-07-05 Film Insp Manual 기능 추가
	BOOL bFind[2] = { FALSE, FALSE };

	bFind[0] = find_pf_panel_pattern(pImage, nJob, nCam); 
	if (bPanel_caliper) find_pf_panel_edge(pImage, nJob, nCam);
	
	bFind[1] = find_pf_film_pattern2(pImage, nJob, nCam);
	if(bFilme_caliper) find_pf_film_edge(pImage, nJob, nCam);

jumpManualMark: // 22.07.05 PJH 위치 변경 

	// 부착 간격 및 각도등을 계산해보자.
	calculate_film_distance(pImage, nJob, nCam);

	// hsj 2022-02-08 필름검사 L check 기능 추가
	//사용안함 :0, false:1, true:2 
	if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelLcheckEnable())
	{
		if (Panel_length_check_process(nJob, FALSE))
			nFilmInspect[nJob][0] = 2;
		else nFilmInspect[nJob][0] = 1;
	}
	else nFilmInspect[nJob][0] = 0;

	if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLcheckEnable())
	{
		if (Film_length_check_process(nJob, FALSE))
			nFilmInspect[nJob][1] = 2;
		else nFilmInspect[nJob][1] = 1;
	}
	else nFilmInspect[nJob][1] = 0;

	//HSJ 2021-12-25 결과창 추가
	//시간 전달
	CString strTime;
	SYSTEMTIME time;
	GetLocalTime(&time);

	/*if (m_strResultTime[nJob].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
	else											strTime.Format("%s", m_strResultTime[nJob]);*/
	
	if (m_strResultTime[nJob].IsEmpty() == TRUE)	strTime.Format("%02d:%02d:%02d.%03d ", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
	else											strTime.Format("%s:%s:%s", m_strResultTime[nJob].Left(2), m_strResultTime[nJob].Mid(3, 2), m_strResultTime[nJob].Right(2));
	
	// 판정을 해보자
	bResult = judge_film_inspection(nJob, nCam);

	// HSJ 2022-02-14 thread_process로 위치변경
	//결과값 띄우기
	/*::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)nJob);
	::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(bResult, nJob));
	::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(nJob));*/

	//KBJ
	if (bResult == TRUE)
	{
		m_nManualInputMarkCount[nJob] = 0;

		CString strTemp;
		strTemp.Format("%.3f", vt_result_info[nJob].pf_film_insp_data.dist_lx[1]);
		m_pPFScaleCalc->GetDlgItem(IDC_EDIT_INSP_LX)->SetWindowTextA(strTemp);

		strTemp.Format("%.3f", vt_result_info[nJob].pf_film_insp_data.dist_ly[1]);
		m_pPFScaleCalc->GetDlgItem(IDC_EDIT_INSP_LY)->SetWindowTextA(strTemp);

		strTemp.Format("%.3f", vt_result_info[nJob].pf_film_insp_data.dist_rx[2]);
		m_pPFScaleCalc->GetDlgItem(IDC_EDIT_INSP_RX)->SetWindowTextA(strTemp);

		strTemp.Format("%.3f", vt_result_info[nJob].pf_film_insp_data.dist_ry[2]);
		m_pPFScaleCalc->GetDlgItem(IDC_EDIT_INSP_RY)->SetWindowTextA(strTemp);
	}
	else
	{
		int real_cam = vt_job_info[nJob].camera_index[nCam];
		int nview = vt_job_info[nJob].viewer_index[nCam];

		m_nManualInputMarkCount[nJob]++;

		// KBJ 2022-07-05 Film Insp Manual 기능 추가.
		if (vt_job_info[nJob].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudge() &&
			m_nManualInputMarkCount[nJob] > vt_job_info[nJob].model_info.getAlignInfo().getEnableAlignMeasureSpecOutJudgeCount())
		{
			// KBJ 2022-10-11 Manual Mark Bit 추가
			g_CommPLC.SetBit(vt_job_info[nJob].plc_addr_info.write_bit_start + 9, TRUE);

			//KJH 2022-07-16 Film Insp algorithm Camera ProcBuffer 변경 --> 시뮬레이션이 안되서 다시 수정 했어요 
			display_PF_Film_insp(pImage, nJob, nCam, &pFormMain->m_pDlgViewerMain[nview]->GetViewer());

			m_nManualInputMarkCount[nJob] = 0;

			/*if (nManualMark_count == 2)
			{
				m_nManualInputMarkCount[nJob] = 0;

				CString str;
				str.Format("Setting Again!!");
				pFormMain->HideErrorMessageBlink();
				pFormMain->ShowErrorMessageBlink(str);
				return bResult;
			}

			if (nManualMark_count == 1)
			{
				Delay(500);
			}*/

			Delay(500);

			CString str;
			str.Format("Manual Mark Input [ panel find %s ] [ film find %s ]", bFind[0] == TRUE ? "OK" : "NG", bFind[1] == TRUE ? "OK" : "NG");
			add_process_history(str);
			::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SHOW_MANUAL_INPUT_MARK_1CAM, MAKELPARAM(nJob, TRUE));
		}
		else
		{
			return bResult;
		}

		// 메뉴얼 마크 완료 체크.. 3분 이후는 그냥 끝냄
		if (wait_flag_over_time(180000, &m_nManualInputMarkResult[nJob], FALSE, 0, 1) == -1)
		{
			CString str;
			str.Format("TimeOut to Manual Mark.");
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			return bResult;
		}

		// KBJ 2022-10-11 Manual Mark Bit 추가
		g_CommPLC.SetBit(vt_job_info[nJob].plc_addr_info.write_bit_start + 9, FALSE);

		if (m_nManualInputMarkResult[nJob] == 1)
		{
			BOOL bUseManulMark = TRUE;
			//if (bPanel_caliper && bFind[0] == FALSE)
			if(0)
			{
				if (find_pf_panel_edge(pImage, nJob, nCam, bUseManulMark) == FALSE)
				{
					CString str;
					str.Format("Check Panel Caliper !!");
					pFormMain->HideErrorMessageBlink();
					pFormMain->ShowErrorMessageBlink(str);
					return bResult;
				}
			}
			else 
			{
				m_stInsp_DistanceResult[real_cam][0].film_insp_pos_x[0] = GetMatching(nJob).getFindInfo(nCam, 0).GetXPos();
				m_stInsp_DistanceResult[real_cam][0].film_insp_pos_y[0] = GetMatching(nJob).getFindInfo(nCam, 0).GetYPos();
				m_stInsp_DistanceResult[real_cam][0].film_insp_pos_x[1] = GetMatching(nJob).getFindInfo(nCam, 1).GetXPos();
				m_stInsp_DistanceResult[real_cam][0].film_insp_pos_y[1] = GetMatching(nJob).getFindInfo(nCam, 1).GetYPos();
			}

			//if (bFilme_caliper && bFind[1] != TRUE)
			if(0)
			{
				if (find_pf_film_edge(pImage, nJob, nCam, bUseManulMark) == FALSE)
				{
					CString str;
					str.Format("Check Film Caliper !!");
					pFormMain->HideErrorMessageBlink();
					pFormMain->ShowErrorMessageBlink(str);
					return bResult;
				}
			}
			else
			{
				m_stInsp_DistanceResult[real_cam][0].film_insp_pos_x[2] = GetMatching(nJob).getFindInfo(nCam, 2).GetXPos();
				m_stInsp_DistanceResult[real_cam][0].film_insp_pos_y[2] = GetMatching(nJob).getFindInfo(nCam, 2).GetYPos();
				m_stInsp_DistanceResult[real_cam][0].film_insp_pos_x[3] = GetMatching(nJob).getFindInfo(nCam, 3).GetXPos();
				m_stInsp_DistanceResult[real_cam][0].film_insp_pos_y[3] = GetMatching(nJob).getFindInfo(nCam, 3).GetYPos();
			}
			m_pManualInputMark1Cam[nJob]->KillTimer(TIMER_MANUAL_MARK);
			
			nManualMark_count++;
			goto jumpManualMark;
		}
	}

	// YCS 2022-09-05 최종 검사데이터만 디스플레이하도록 위치 변경
#pragma region 검사 결과 디스플레이 및 DB저장
	// YCS 2022-08-28 데이터 100개 이상이면 오래된 데이터부터 지운다
	if (m_vInspFilmResult[nJob].size() > 1000)
	{
		m_vInspFilmResult[nJob].erase(m_vInspFilmResult[nJob].begin());
	}

	// YCS 2022-08-20 필름 검사 결과값 저장
	_stInsp_FilmLength_Result temp;
	temp.dLX = vt_result_info[nJob].pf_film_insp_data.dist_lx[1]; // L <-> LX
	temp.dLY = vt_result_info[nJob].pf_film_insp_data.dist_ly[1]; // L <-> LY
	temp.dRX = vt_result_info[nJob].pf_film_insp_data.dist_rx[2]; // R <-> RX
	temp.dRY = vt_result_info[nJob].pf_film_insp_data.dist_ry[2]; // R <-> RY

	m_vInspFilmResult[nJob].push_back(temp);

	//SJB 2022-08-26 LX,LY,RX,RY 데이터 전달
	m_pCInspChartDlg[nJob]->DBInsertInspData(temp.dLX, temp.dLY, temp.dRX, temp.dRY);

	// YCS 2022-08-25 검사 데이터 차트에 디스플레이
	m_pCInspChartDlg[nJob]->UpdateScatterGraph(m_vInspFilmResult[nJob], int(m_vInspFilmResult[nJob].size()));
#pragma endregion

	return bResult;
}
BOOL CLET_AlignClientDlg::display_PF_Film_insp_save(BYTE* pImage, int nJob, int nCam, CViewerEx* pViewer, _stSaveImageInfo* pInfo)
{
	auto pDC = pViewer->getOverlayDC();

	cv::Scalar color_ok = cv::Scalar(64, 128, 64); //COLOR_DARK_LIME
	cv::Scalar color_ng = cv::Scalar(64, 64, 255); //COLOR_RED
	cv::Scalar color_match = cv::Scalar(64, 255, 255);// COLOR_YELLOW
	cv::Scalar color_spec = cv::Scalar(255, 64, 255);// COLOR_PURPLE
	cv::Scalar color_panel_center = cv::Scalar(255, 216, 0);// COLOR_SKY_BLUE
	cv::Scalar color;

	int w = vt_job_info[nJob].camera_size[nCam].x;
	int h = vt_job_info[nJob].camera_size[nCam].y;

	//stFigure temp_figure;
	//stFigureText tempFigText;
	//temp_figure.isDot = false;

	int real_cam = vt_job_info[nJob].camera_index[nCam];
	int nIndex = pInfo->nIndex;
	cv::Mat matGrayImage(h, w, CV_8UC1, pImage);
	cv::Mat matColorImage;
	cv::cvtColor(matGrayImage, matColorImage, CV_GRAY2BGR);

	// panel 및 film mark display
	for (int nPos = 0; nPos < 4; nPos++)
	{
		if (GetMatching(nJob).getFindInfo(nCam, nPos).GetFound() == FIND_OK)
		{
			if (nPos < 2)			color = color_ok;
			else					color = color_panel_center;
		}
		else if (GetMatching(nJob).getFindInfo(nCam, nPos).GetFound() == FIND_MATCH)	color = color_match;
		else																			color = color_ng;

		auto x0 = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		auto y0 = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();
		auto x1 = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		auto y1 = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();
		line(matColorImage, cv::Point(x0 - 30, y0), cv::Point(x1 + 30, y1), color, 5);
		line(matColorImage, cv::Point(x0, y0 - 30), cv::Point(x1, y1 + 30), color, 5);
	}

	// 가상 스펙선 디스 플레이 하자.
	double res_x = GetMachine(nJob).getCameraResolutionX(nCam, 0);
	double res_y = GetMachine(nJob).getCameraResolutionY(nCam, 0);

	double spec_lx = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(0);
	double spec_lx_tor = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(0);
	double spec_rx = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(1);
	double spec_rx_tor = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(1);

	double spec_ly = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(2);
	double spec_ly_tor = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(2);
	double spec_ry = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(3);
	double spec_ry_tor = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(3);

	sLine line_panel = vt_result_info[nJob].pf_film_insp_data.line_panel;

	sLine normal_line_panel[3];

	for (int i = 0; i < 3; i++)
		normal_line_panel[i] = vt_result_info[nJob].pf_film_insp_data.normal_line_panel[i];

	//temp_figure.isDot = true;

	//KJH 2022-03-15 고객 요청으로 각 L, R 에서의 거리로 스펙 판정 변경
	int method = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmInspMethod();
	double pnl_x[3], pnl_y[3];

	pnl_x[0] = (vt_result_info[nJob].pf_film_insp_data.panel_pos_x[0] + vt_result_info[nJob].pf_film_insp_data.panel_pos_x[1]) / 2.0;
	pnl_y[0] = (vt_result_info[nJob].pf_film_insp_data.panel_pos_y[0] + vt_result_info[nJob].pf_film_insp_data.panel_pos_y[1]) / 2.0;

	pnl_x[1] = vt_result_info[nJob].pf_film_insp_data.panel_pos_x[0];
	pnl_y[1] = vt_result_info[nJob].pf_film_insp_data.panel_pos_y[0];

	pnl_x[2] = vt_result_info[nJob].pf_film_insp_data.panel_pos_x[1];
	pnl_y[2] = vt_result_info[nJob].pf_film_insp_data.panel_pos_y[1];

	/*
	pnl_cx = (vt_result_info[nJob].pf_film_insp_data.panel_pos_x[0] + vt_result_info[nJob].pf_film_insp_data.panel_pos_x[1]) / 2.0;
	pnl_cy = (vt_result_info[nJob].pf_film_insp_data.panel_pos_y[0] + vt_result_info[nJob].pf_film_insp_data.panel_pos_y[1]) / 2.0;
	*/

	CPoint pt_start, pt_end;
	double dx = (vt_result_info[nJob].pf_film_insp_data.panel_pos_x[1] - vt_result_info[nJob].pf_film_insp_data.panel_pos_x[0]);
	double dy = (vt_result_info[nJob].pf_film_insp_data.panel_pos_y[1] - vt_result_info[nJob].pf_film_insp_data.panel_pos_y[0]);
	double theta_rad = 0.0;
	if (dx != 0) theta_rad = atan(dy / dx);

	sLine spec_line;
	sLine spec_left_normal_line;
	sLine spec_right_normal_line;
	sPoint pt[2];

	// 패널 center에서 패널 각도를 고려하여  스펙 위치의 좌표를 계산.
	/*
	GetPrealign(nJob).calcRotate(pnl_cx, pnl_cy, pnl_cx - (spec_lx / res_x), pnl_cy - (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
	GetPrealign(nJob).calcRotate(pnl_cx, pnl_cy, pnl_cx + (spec_rx / res_x), pnl_cy - (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);
	*/

	//HSJ 2022-01-07 카메라 플립(고객사요청)으로 인한 스펙 위치표시 수정
	if (method == 4)
	{
		GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[1] - (spec_lx / res_x), pnl_y[1] + (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
		GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[2] + (spec_rx / res_x), pnl_y[2] + (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);
	}
	else
	{
		GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[0] - (spec_lx / res_x), pnl_y[0] + (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
		GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[0] + (spec_rx / res_x), pnl_y[0] + (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);
	}

	//GetPrealign(nJob).calcRotate(pnl_cx, pnl_cy, pnl_cx - (spec_lx / res_x), pnl_cy + (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
	//GetPrealign(nJob).calcRotate(pnl_cx, pnl_cy, pnl_cx + (spec_rx / res_x), pnl_cy + (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);

	GetMatching(nJob).compute_model_parameter(pt, 2, spec_line);

	// 좌측 스펙 위치를 지나는 법선 계산
	spec_left_normal_line.a = -1.0 / spec_line.a;
	spec_left_normal_line.b = pt[0].y - spec_left_normal_line.a * pt[0].x;

	// 우측 스펙 위치를 지나는 법선 계산
	spec_right_normal_line.a = -1.0 / spec_line.a;
	spec_right_normal_line.b = pt[1].y - spec_left_normal_line.a * pt[1].x;


	// 패널 중심 표시
	auto x0 = pnl_x[0];
	auto y0 = pnl_y[0];
	auto x1 = pnl_x[0];
	auto y1 = pnl_y[0];
	line(matColorImage, cv::Point(x0 - 30, y0), cv::Point(x1 + 30, y1), color, 5);
	line(matColorImage, cv::Point(x0, y0 - 30), cv::Point(x1, y1 + 30), color, 5);

	// Y 스펙 표시
	pt_start.x = 0;
	pt_start.y = pt_start.x * spec_line.a + spec_line.b;
	pt_end.x = w;
	pt_end.y = spec_line.a * pt_end.x + spec_line.b;

	//temp_figure.ptBegin = pt_start;
	//temp_figure.ptEnd = pt_end;
	line(matColorImage, cv::Point(pt_start.x, pt_start.y), cv::Point(pt_end.x, pt_end.y), color_spec, 5);

	// 좌측 X 스펙 표시
	pt_start.y = 0;
	pt_start.x = (pt_start.y - spec_left_normal_line.b) / spec_left_normal_line.a;
	pt_end.y = h;
	pt_end.x = (pt_end.y - spec_left_normal_line.b) / spec_left_normal_line.a;

	//temp_figure.ptBegin = pt_start;
	//temp_figure.ptEnd = pt_end;
	line(matColorImage, cv::Point(pt_start.x, pt_start.y), cv::Point(pt_end.x, pt_end.y), color_spec, 5);

	// 우측 X 스펙 표시
	pt_start.y = 0;
	pt_start.x = (pt_start.y - spec_right_normal_line.b) / spec_right_normal_line.a;
	pt_end.y = h;
	pt_end.x = (pt_end.y - spec_right_normal_line.b) / spec_right_normal_line.a;

	//temp_figure.ptBegin = pt_start;
	//temp_figure.ptEnd = pt_end;

	line(matColorImage, cv::Point(pt_start.x, pt_start.y), cv::Point(pt_end.x, pt_end.y), color_spec, 5);

	if (vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING_LINE_THETA)
	{
		int real_cam = vt_job_info[nJob].camera_index[nCam];

		sLine line_info[2];
		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][0][0].m_lineInfo;
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][1][0].m_lineInfo;

		if (m_pDlgCaliper->m_Caliper[real_cam][0][0].getIsMakeLine())
		{
			auto x0 = line_info[0].sx;
			auto y0 = line_info[0].sy;
			auto x1 = line_info[0].sx;
			auto y1 = line_info[0].sy;
			line(matColorImage, cv::Point(x0 - 30, y0), cv::Point(x1 + 30, y1), color_panel_center, 5);
			line(matColorImage, cv::Point(x0, y0 - 30), cv::Point(x1, y1 + 30), color_panel_center, 5);
		}

		if (m_pDlgCaliper->m_Caliper[real_cam][1][0].getIsMakeLine())
		{
			auto x0 = line_info[1].sx;
			auto y0 = line_info[1].sy;
			auto x1 = line_info[1].sx;
			auto y1 = line_info[1].sy;
			line(matColorImage, cv::Point(x0 - 30, y0), cv::Point(x1 + 30, y1), color_panel_center, 5);
			line(matColorImage, cv::Point(x0, y0 - 30), cv::Point(x1, y1 + 30), color_panel_center, 5);
		}
	}


	PF_FILM_INSP *pData = &vt_result_info[nJob].pf_film_insp_data;
	CString strText;
	//tempFigText.is_show_bkg = TRUE;

	// hsj 2022-01-12 이미지 저장 시 method에 따라 값 다르게 저장 ____START
	int iFilmInspMethod = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmInspMethod();
	CString strMethod = "";

	int nStart, nEnd;
	nStart = 100;
	nEnd = 100;

	switch (iFilmInspMethod)
	{
	case 0: strMethod = "C"; break;
	case 1: strMethod = "L"; break;
	case 2: strMethod = "R"; break;
	case 3: strMethod = "M"; break;
	case 4: strMethod = "A"; break;
	}

	// 패널을 찾지 못할 경우 디스플레이 할게 없음
	if (GetMatching(nJob).getFindInfo(nCam, 0).GetFound() != FIND_OK || GetMatching(nJob).getFindInfo(nCam, 1).GetFound() != FIND_OK)
	{
		strText.Format("NG!!");
		//tempFigText.ptBegin.x = nStart;
		//tempFigText.ptBegin.y = nEnd;
		//tempFigText.ptBeginFit.x = nStart;
		//tempFigText.ptBeginFit.y = nEnd;
		//tempFigText.textString = strText;

		putText(matColorImage, std::string(strText), cv::Point(100, 100), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);
	}
	else
	{
		if (iFilmInspMethod == 4)
		{
			for (int i = 0; i < 3; i++)
			{
				switch (i)
				{
				case 0:
					strMethod = "C";
					nStart = w / 2 - 400;
					nEnd = 100;
					break;
				case 1:
					strMethod = "L";
					nStart = 100;
					nEnd = 100;
					break;
				case 2:
					strMethod = "R";
					nStart = w - 1300;
					nEnd = 100;
					break;
				}

				strText.Format("%s <-> LX: %.3f mm", strMethod, pData->dist_lx[i]);
				//tempFigText.ptBegin.x = nStart;
				//tempFigText.ptBegin.y = nEnd;
				//tempFigText.ptBeginFit.x = nStart;
				//tempFigText.ptBeginFit.y = nEnd;
				//tempFigText.textString = strText;
				if (pData->judge[0]) putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
				else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

				nEnd += 150;

				strText.Format("%s <-> LY: %.3f mm", strMethod, pData->dist_ly[i]);
				//tempFigText.ptBegin.x = nStart;
				//tempFigText.ptBegin.y = nEnd;
				//tempFigText.ptBeginFit.x = nStart;
				//tempFigText.ptBeginFit.y = nEnd;
				//tempFigText.textString = strText;
				if (pData->judge[2]) putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
				else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

				nEnd += 150;

				strText.Format("%s <-> RX: %.3f mm", strMethod, pData->dist_rx[i]);
				//tempFigText.ptBegin.x = nStart;
				//tempFigText.ptBegin.y = nEnd;
				//tempFigText.ptBeginFit.x = nStart;
				//tempFigText.ptBeginFit.y = nEnd;
				//tempFigText.textString = strText;
				if (pData->judge[1]) putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
				else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

				nEnd += 150;

				strText.Format("%s <-> RY: %.3f mm", strMethod, pData->dist_ry[i]);
				//tempFigText.ptBegin.x = nStart;
				//tempFigText.ptBegin.y = nEnd;
				//tempFigText.ptBeginFit.x = nStart;
				//tempFigText.ptBeginFit.y = nEnd;
				//tempFigText.textString = strText;
				if (pData->judge[3])putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
				else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

			}


			strText.Format("Panel Angle: %.3f, Attach Angle: %.3f", pData->panel_angle, pData->attach_angle);
			//tempFigText.ptBegin.x = 100;
			//tempFigText.ptBegin.y = h - 200;
			//tempFigText.ptBeginFit.x = 100;
			//tempFigText.ptBeginFit.y = h - 200;
			//tempFigText.textString = strText;

			putText(matColorImage, std::string(strText), cv::Point(100, h - 200), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
		}
		else if (iFilmInspMethod == 3)
		{
			strMethod = "L";

			strText.Format("%s <-> LX: %.3f mm", strMethod, pData->dist_lx[1]);
			//tempFigText.ptBegin.x = nStart;
			//tempFigText.ptBegin.y = nEnd;
			//tempFigText.ptBeginFit.x = nStart;
			//tempFigText.ptBeginFit.y = nEnd;
			//tempFigText.textString = strText;
			if (pData->judge[0]) putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
			else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

			nEnd += 150;

			strText.Format("%s <-> LY: %.3f mm", strMethod, pData->dist_ly[1]);
			//tempFigText.ptBegin.x = nStart;
			//tempFigText.ptBegin.y = nEnd;
			//tempFigText.ptBeginFit.x = nStart;
			//tempFigText.ptBeginFit.y = nEnd;
			//tempFigText.textString = strText;
			if (pData->judge[2]) putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
			else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

			nEnd += 150;

			strMethod = "R";

			strText.Format("%s <-> RX: %.3f mm", strMethod, pData->dist_rx[2]);
			//tempFigText.ptBegin.x = nStart;
			//tempFigText.ptBegin.y = nEnd;
			//tempFigText.ptBeginFit.x = nStart;
			//tempFigText.ptBeginFit.y = nEnd;
			//tempFigText.textString = strText;
			if (pData->judge[1]) putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
			else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

			nEnd += 150;

			strText.Format("%s <-> RY: %.3f mm", strMethod, pData->dist_ry[2]);
			//tempFigText.ptBegin.x = nStart;
			//tempFigText.ptBegin.y = nEnd;
			//tempFigText.ptBeginFit.x = nStart;
			//tempFigText.ptBeginFit.y = nEnd;
			//tempFigText.textString = strText;
			if (pData->judge[3])putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
			else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

			nEnd += 150;

			strText.Format("Panel Angle: %.3f, Attach Angle: %.3f", pData->panel_angle, pData->attach_angle);
			//tempFigText.ptBegin.x = nStart;
			//tempFigText.ptBegin.y = nEnd;
			//tempFigText.ptBeginFit.x = nStart;
			//tempFigText.ptBeginFit.y = nEnd;
			//tempFigText.textString = strText;

			putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
		}
		else
		{
			strText.Format("%s <-> LX: %.3f mm", strMethod, pData->dist_lx[iFilmInspMethod]);
			//tempFigText.ptBegin.x = nStart;
			//tempFigText.ptBegin.y = nEnd;
			//tempFigText.ptBeginFit.x = nStart;
			//tempFigText.ptBeginFit.y = nEnd;
			//tempFigText.textString = strText;
			if (pData->judge[0]) putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
			else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

			nEnd += 150;

			strText.Format("%s <-> LY: %.3f mm", strMethod, pData->dist_ly[iFilmInspMethod]);
			//tempFigText.ptBegin.x = nStart;
			//tempFigText.ptBegin.y = nEnd;
			//tempFigText.ptBeginFit.x = nStart;
			//tempFigText.ptBeginFit.y = nEnd;
			//tempFigText.textString = strText;
			if (pData->judge[2]) putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
			else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

			nEnd += 150;

			strText.Format("%s <-> RX: %.3f mm", strMethod, pData->dist_rx[iFilmInspMethod]);
			//tempFigText.ptBegin.x = nStart;
			//tempFigText.ptBegin.y = nEnd;
			//tempFigText.ptBeginFit.x = nStart;
			//tempFigText.ptBeginFit.y = nEnd;
			//tempFigText.textString = strText;
			if (pData->judge[1]) putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
			else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

			nEnd += 150;

			strText.Format("%s <-> RY: %.3f mm", strMethod, pData->dist_ry[iFilmInspMethod]);
			//tempFigText.ptBegin.x = nStart;
			//tempFigText.ptBegin.y = nEnd;
			//tempFigText.ptBeginFit.x = nStart;
			//tempFigText.ptBeginFit.y = nEnd;
			//tempFigText.textString = strText;
			if (pData->judge[3])putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);
			else putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ng, 5);

			nEnd += 150;

			strText.Format("Panel Angle: %.3f, Attach Angle: %.3f", pData->panel_angle, pData->attach_angle);
			//tempFigText.ptBegin.x = nStart;
			//tempFigText.ptBegin.y = nEnd;
			//tempFigText.ptBeginFit.x = nStart;
			//tempFigText.ptBeginFit.y = nEnd;
			//tempFigText.textString = strText;

			putText(matColorImage, std::string(strText), cv::Point(nStart, nEnd), cv::FONT_HERSHEY_SIMPLEX, 2, color_ok, 5);

		}

	}
	////////// END

	// kbj 2022-01-05 SaveImage systemOption
	if (vt_system_option[nJob].jpg_compress_rate_Result < 90 && vt_system_option[nJob].jpg_compress_rate_Raw < 90) // 영상 압축해서 저장
	{
		vector<int> params_jpg;
		params_jpg.push_back(IMWRITE_JPEG_QUALITY);

		if (vt_system_option[nJob].result_image_save == TRUE)
			params_jpg.push_back(vt_system_option[nJob].jpg_compress_rate_Result);
		else
			params_jpg.push_back(vt_system_option[nJob].jpg_compress_rate_Raw);

		// result image save on/off
		if (vt_system_option[nJob].result_image_save == TRUE)
		{
			if (pInfo->bJudge == TRUE && vt_system_option[nJob].ok_image_save == TRUE)	cv::imwrite(m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage, params_jpg);
			if (pInfo->bJudge == FALSE && vt_system_option[nJob].ng_image_save == TRUE)	cv::imwrite(m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage, params_jpg);
		}
		// Raw image save on/off
		if (vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage, params_jpg);
	}
	else // 영상 압축 x
	{
		// result image save on/off
		if (vt_system_option[nJob].result_image_save == TRUE)
		{
			if (pInfo->bJudge == TRUE && vt_system_option[nJob].ok_image_save == TRUE)	cv::imwrite(m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);
			if (pInfo->bJudge == FALSE && vt_system_option[nJob].ng_image_save == TRUE)	cv::imwrite(m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);
		}

		// Raw image save on/off
		if (vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage);
	}

	matColorImage.release();
	matGrayImage.release(); // kbj 2021-01-05 Add grayimage Release()

	CString str;
	str.Format("[%s] Cam : %d - %d Image Save Complete ", vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}
BOOL CLET_AlignClientDlg::display_PF_Film_insp_save_capture(BYTE* pImage, int nJob, int nCam, CViewerEx* pViewer, _stSaveImageInfo* pInfo)
{
	int w = vt_job_info[nJob].camera_size[nCam].x;
	int h = vt_job_info[nJob].camera_size[nCam].y;
	int real_cam = vt_job_info[nJob].camera_index[nCam];
	int nIndex = pInfo->nIndex;
	cv::Mat matGrayImage(h, w, CV_8UC1, pImage);
	
	// kbj 2022-01-05 SaveImage systemOption
	if (vt_system_option[nJob].jpg_compress_rate_Result < 90 && vt_system_option[nJob].jpg_compress_rate_Raw < 90) // 영상 압축해서 저장
	{
		vector<int> params_jpg;
		params_jpg.push_back(IMWRITE_JPEG_QUALITY);

			if(vt_system_option[nJob].result_image_save == TRUE)
				params_jpg.push_back(vt_system_option[nJob].jpg_compress_rate_Result);
			else
				params_jpg.push_back(vt_system_option[nJob].jpg_compress_rate_Raw);

		// result image save on/off
		if (vt_system_option[nJob].result_image_save == TRUE)
		{
			if (pInfo->bJudge == TRUE && vt_system_option[nJob].ok_image_save == TRUE)	pViewer->saveScreenCapture(m_cSaveImageRingBufPath[nJob][nCam][nIndex]);
			if (pInfo->bJudge == FALSE && vt_system_option[nJob].ng_image_save == TRUE)	pViewer->saveScreenCapture(m_cSaveImageRingBufPath[nJob][nCam][nIndex]);
		}
		// Raw image save on/off
		if (vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage, params_jpg);
	}
	else // 영상 압축 x
	{
		// result image save on/off
		if (vt_system_option[nJob].result_image_save == TRUE)
		{
			if (pInfo->bJudge == TRUE && vt_system_option[nJob].ok_image_save == TRUE)	pViewer->saveScreenCapture(m_cSaveImageRingBufPath[nJob][nCam][nIndex]);
			if (pInfo->bJudge == FALSE && vt_system_option[nJob].ng_image_save == TRUE)	pViewer->saveScreenCapture(m_cSaveImageRingBufPath[nJob][nCam][nIndex]);
		}

		// Raw image save on/off
		if (vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage);
	}

	matGrayImage.release(); // kbj 2021-01-05 Add grayimage Release()

	CString str;
	str.Format("[%s] Cam : %d - %d Image Capture Complete ", vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}
BOOL CLET_AlignClientDlg::display_PF_Film_insp(BYTE* pImage, int nJob, int nCam, CViewerEx* pViewer, BOOL bAgain)
{
	auto pDC = pViewer->getOverlayDC();
	pViewer->ClearOverlayDC();

	COLORREF color_ok = COLOR_DARK_LIME;
	COLORREF color_ng = COLOR_RED;
	COLORREF color_match = COLOR_YELLOW;
	COLORREF color_spec = COLOR_PURPLE;
	COLORREF color_panel_center = COLOR_SKY_BLUE;
	COLORREF color_spec_tor = COLOR_BLUE;
	COLORREF color;

	int w = vt_job_info[nJob].camera_size[nCam].x;
	int h = vt_job_info[nJob].camera_size[nCam].y;

	int nFit = 10;
	int nOrg = 10;

	// panel 및 film mark display
	for (int nPos = 0; nPos < 4; nPos++)
	{
		if (GetMatching(nJob).getFindInfo(nCam, nPos).GetFound() == FIND_OK)
		{
			if (nPos < 2)			color = color_ok;
			else					color = COLOR_SKY_BLUE;
		}
		else if (GetMatching(nJob).getFindInfo(nCam, nPos).GetFound() == FIND_MATCH)	color = color_match;
		else																			color = color_ng;

		auto x = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		auto y = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();;
		pViewer->AddSoftGraphic(new GraphicPoint(x, y, Gdiplus::Color(0xff00ff00), 7, 2));
	}

	// 가상 스펙선 디스 플레이 하자.
	double res_x = GetMachine(nJob).getCameraResolutionX(nCam, 0);
	double res_y = GetMachine(nJob).getCameraResolutionY(nCam, 0);

	double spec_lx = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(0);
	double spec_lx_tor = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(0);
	double spec_rx = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(1);
	double spec_rx_tor = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(1);

	double spec_ly = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(2);
	double spec_ly_tor = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(2);
	double spec_ry = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(3);
	double spec_ry_tor = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(3);

	sLine line_panel = vt_result_info[nJob].pf_film_insp_data.line_panel;

	//HSJ 2022-01-08 고객요청으로 필름검사 모든 기준(Center,Left,Right)에서 나타날 수 있게 디스플레이 변경 _____START 
	sLine normal_line_panel[3];

	for (int i = 0; i < 3; i++)
		normal_line_panel[i] = vt_result_info[nJob].pf_film_insp_data.normal_line_panel[i];

	//temp_figure.isDot = true;

	double pnl_x[3], pnl_y[3];

	pnl_x[0] = (vt_result_info[nJob].pf_film_insp_data.panel_pos_x[0] + vt_result_info[nJob].pf_film_insp_data.panel_pos_x[1]) / 2.0;
	pnl_y[0] = (vt_result_info[nJob].pf_film_insp_data.panel_pos_y[0] + vt_result_info[nJob].pf_film_insp_data.panel_pos_y[1]) / 2.0;

	pnl_x[1] = vt_result_info[nJob].pf_film_insp_data.panel_pos_x[0];
	pnl_y[1] = vt_result_info[nJob].pf_film_insp_data.panel_pos_y[0];

	pnl_x[2] = vt_result_info[nJob].pf_film_insp_data.panel_pos_x[1];
	pnl_y[2] = vt_result_info[nJob].pf_film_insp_data.panel_pos_y[1];

	CPoint pt_start, pt_end;
	double dx = (vt_result_info[nJob].pf_film_insp_data.panel_pos_x[1] - vt_result_info[nJob].pf_film_insp_data.panel_pos_x[0]);
	double dy = (vt_result_info[nJob].pf_film_insp_data.panel_pos_y[1] - vt_result_info[nJob].pf_film_insp_data.panel_pos_y[0]);
	double theta_rad = 0.0;

	//hsj 2022-01-15 dy가 0일때 아주 근사한 선으로 만들기
	if (dy == 0) dy = 0.000001;
	if (dx != 0) theta_rad = atan(dy / dx);

	sLine spec_line;
	sLine spec_left_normal_line;
	sLine spec_right_normal_line;
	sPoint pt[2];

	// 패널 center에서 패널 각도를 고려하여  스펙 위치의 좌표를 계산.
	/*GetPrealign(nJob).calcRotate(pnl_cx, pnl_cy, pnl_cx - (spec_lx / res_x), pnl_cy - (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
	GetPrealign(nJob).calcRotate(pnl_cx, pnl_cy, pnl_cx + (spec_rx / res_x), pnl_cy - (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);*/

	//HSJ 2022-01-07 카메라 플립(고객사요청)으로 인한 스펙 위치표시 수정
	//HSJ 2022-01-08 우선 스펙선은 센터기준으로만...
	//hsj 2022-02-16 켈리브레이션 방향으로 스펙 위치표시

	int method = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmInspMethod();

	//if (GetMachine(nJob).getCalibDirectionY(nCam, 0) == DIRECTION_DOWN)
	// 220414 KBJ
	//2022-04-19
	BOOL b_film_position_reverse = vt_job_info[nJob].model_info.getInspSpecParaInfo().getUseFilmReversePosition();

	if (b_film_position_reverse == FALSE)
	{
		//KJH 2022-03-15 고객 요청으로 각 L, R 에서의 거리로 스펙 판정 변경
		/*
		GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[0] - (spec_lx / res_x), pnl_y[0] + (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
		GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[0] + (spec_rx / res_x), pnl_y[0] + (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);
		*/

		//hsj 2022-03-16 method 따라 스펙선 위치 나눔
		if (method == 4)
		{
			GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[1] - (spec_lx / res_x), pnl_y[1] + (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
			GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[2] + (spec_rx / res_x), pnl_y[2] + (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);
		}
		else
		{
			GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[0] - (spec_lx / res_x), pnl_y[0] + (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
			GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[0] + (spec_rx / res_x), pnl_y[0] + (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);
		}
	}
	else
	{
		//KJH 2022-03-15 고객 요청으로 각 L, R 에서의 거리로 스펙 판정 변경
		/*
		GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[0] - (spec_lx / res_x), pnl_y[0] - (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
		GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[0] + (spec_rx / res_x), pnl_y[0] - (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);
		*/

		//hsj 2022-03-16 method 따라 스펙선 위치 나눔
		if (method == 4)
		{
			GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[1] - (spec_lx / res_x), pnl_y[1] - (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
			GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[2] + (spec_rx / res_x), pnl_y[2] - (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);
		}
		else
		{
			GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[0] - (spec_lx / res_x), pnl_y[0] - (spec_ly / res_y), theta_rad, &pt[0].x, &pt[0].y);
			GetPrealign(nJob).calcRotate(pnl_x[0], pnl_y[0], pnl_x[0] + (spec_rx / res_x), pnl_y[0] - (spec_ry / res_y), theta_rad, &pt[1].x, &pt[1].y);
		}
	}

	GetMatching(nJob).compute_model_parameter(pt, 2, spec_line);

	// 좌측 스펙 위치를 지나는 법선 계산
	spec_left_normal_line.a = -1.0 / spec_line.a;
	spec_left_normal_line.b = pt[0].y - spec_left_normal_line.a * pt[0].x;

	// 우측 스펙 위치를 지나는 법선 계산
	spec_right_normal_line.a = -1.0 / spec_line.a;
	spec_right_normal_line.b = pt[1].y - spec_left_normal_line.a * pt[1].x;

	// 패널 중심 표시
	auto x = pnl_x[0];
	auto y = pnl_y[0];
	pViewer->AddSoftGraphic(new GraphicPoint(x, y, Gdiplus::Color(0xff00ff00), 5, 2));

	//HSJ END

	// Y 스펙 표시
	pt_start.x = 0;
	pt_start.y = pt_start.x * spec_line.a + spec_line.b;
	pt_end.x = w;
	pt_end.y = spec_line.a * pt_end.x + spec_line.b;
	pViewer->AddSoftGraphic(new GraphicLine(pt_start, pt_end, Gdiplus::Color(0xff00ff00), 1, Gdiplus::DashStyle::DashStyleDash, Gdiplus::SmoothingModeNone));

	//hsj 2022-01-10 스펙 편차 선 표시
	double spec_lx_tor_pixel = spec_lx_tor / res_x;
	double spec_rx_tor_pixel = spec_rx_tor / res_x;
	double spec_ly_tor_pixel = spec_ly_tor / res_y;

	pt_start.x = 0;
	pt_start.y = (pt_start.x * spec_line.a + spec_line.b) + spec_ly_tor_pixel;
	pt_end.x = w;
	pt_end.y = (spec_line.a * pt_end.x + spec_line.b) + spec_ly_tor_pixel;
	pViewer->AddSoftGraphic(new GraphicLine(pt_start, pt_end, Gdiplus::Color(0xffff0000), 1, Gdiplus::DashStyle::DashStyleDash, Gdiplus::SmoothingModeNone));

	pt_start.x = 0;
	pt_start.y = (pt_start.x * spec_line.a + spec_line.b) - spec_ly_tor_pixel;
	pt_end.x = w;
	pt_end.y = (spec_line.a * pt_end.x + spec_line.b) - spec_ly_tor_pixel;
	pViewer->AddSoftGraphic(new GraphicLine(pt_start, pt_end, Gdiplus::Color(0xffff0000), 1, Gdiplus::DashStyle::DashStyleDash, Gdiplus::SmoothingModeNone));

	// 좌측 X 스펙 표시
	pt_start.y = 0;
	pt_start.x = (pt_start.y - spec_left_normal_line.b) / spec_left_normal_line.a;
	pt_end.y = h;
	pt_end.x = (pt_end.y - spec_left_normal_line.b) / spec_left_normal_line.a;
	pViewer->AddSoftGraphic(new GraphicLine(pt_start, pt_end, Gdiplus::Color(0xff00ff00), 1, Gdiplus::DashStyle::DashStyleDash, Gdiplus::SmoothingModeNone));

	//hsj 2022-01-10 스펙 편차 선 표시
	pt_start.y = 0;
	pt_start.x = ((pt_start.y - spec_left_normal_line.b) / spec_left_normal_line.a) + spec_lx_tor_pixel;
	pt_end.y = h;
	pt_end.x = ((pt_end.y - spec_left_normal_line.b) / spec_left_normal_line.a) + spec_lx_tor_pixel;
	pViewer->AddSoftGraphic(new GraphicLine(pt_start, pt_end, Gdiplus::Color(0xffff0000), 1, Gdiplus::DashStyle::DashStyleDash, Gdiplus::SmoothingModeNone));

	pt_start.y = 0;
	pt_start.x = ((pt_start.y - spec_left_normal_line.b) / spec_left_normal_line.a) - spec_lx_tor_pixel;
	pt_end.y = h;
	pt_end.x = ((pt_end.y - spec_left_normal_line.b) / spec_left_normal_line.a) - spec_lx_tor_pixel;
	pViewer->AddSoftGraphic(new GraphicLine(pt_start, pt_end, Gdiplus::Color(0xffff0000), 1, Gdiplus::DashStyle::DashStyleDash, Gdiplus::SmoothingModeNone));

	// 우측 X 스펙 표시
	pt_start.y = 0;
	pt_start.x = (pt_start.y - spec_right_normal_line.b) / spec_right_normal_line.a;
	pt_end.y = h;
	pt_end.x = (pt_end.y - spec_right_normal_line.b) / spec_right_normal_line.a;
	pViewer->AddSoftGraphic(new GraphicLine(pt_start, pt_end, Gdiplus::Color(0xff00ff00), 1, Gdiplus::DashStyle::DashStyleDash, Gdiplus::SmoothingModeNone));

	//hsj 2022-01-10 스펙 편차 선 표시
	pt_start.y = 0;
	pt_start.x = ((pt_start.y - spec_right_normal_line.b) / spec_right_normal_line.a) + spec_rx_tor_pixel;
	pt_end.y = h;
	pt_end.x = ((pt_end.y - spec_right_normal_line.b) / spec_right_normal_line.a) + spec_rx_tor_pixel;
	pViewer->AddSoftGraphic(new GraphicLine(pt_start, pt_end, Gdiplus::Color(0xffff0000), 1, Gdiplus::DashStyle::DashStyleDash, Gdiplus::SmoothingModeNone));

	//hsj 2022-01-10 스펙 편차 선 표시
	pt_start.y = 0;
	pt_start.x = ((pt_start.y - spec_right_normal_line.b) / spec_right_normal_line.a) - spec_rx_tor_pixel;
	pt_end.y = h;
	pt_end.x = ((pt_end.y - spec_right_normal_line.b) / spec_right_normal_line.a) - spec_rx_tor_pixel;
	pViewer->AddSoftGraphic(new GraphicLine(pt_start, pt_end, Gdiplus::Color(0xffff0000), 1, Gdiplus::DashStyle::DashStyleDash, Gdiplus::SmoothingModeNone));

	//if (vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING_LINE_THETA)
	//{
	//	int real_cam = vt_job_info[nJob].camera_index[nCam];

	//	sLine line_info[2];
	//	line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][0][0].m_lineInfo;
	//	line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][1][0].m_lineInfo;

	//	if (m_pDlgCaliper->m_Caliper[real_cam][0][0].getIsMakeLine())
	//		pViewer->AddSoftGraphic(new GraphicPoint(line_info[0].sx, line_info[0].sy, Gdiplus::Color(0xffff00ff), 5, 2));

	//	if (m_pDlgCaliper->m_Caliper[real_cam][1][0].getIsMakeLine())
	//		pViewer->AddSoftGraphic(new GraphicPoint(line_info[1].sx, line_info[1].sy, Gdiplus::Color(0xffff00ff), 5, 2));
	//}

	for (int nPos = 0; nPos < vt_job_info[nJob].num_of_position; nPos++)
	{
		auto rect = GetMatching(nJob).getSearchROI(nCam, nPos);
		pViewer->AddSoftGraphic(new GraphicRectangle(rect, Gdiplus::Color(0xffff00ff)));
	}


	PF_FILM_INSP* pData = &vt_result_info[nJob].pf_film_insp_data;
	CString strText;
	//tempFigText.is_show_bkg = TRUE;

	//HSJ 2022-01-08 0:center, 1:left, 2:right, 3:multi, 4:All
	int iFilmInspMethod = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmInspMethod();
	CString strMethod = "";

	int nStart = 100;
	int nEnd = 100;

	switch (iFilmInspMethod)
	{
	case 0: strMethod = "C"; break;
	case 1: strMethod = "L"; break;
	case 2: strMethod = "R"; break;
	case 3: strMethod = "M"; break;
	case 4: strMethod = "A"; break;
	}

	// 패널을 찾지 못할 경우 디스플레이 할게 없음
	if (GetMatching(nJob).getFindInfo(nCam, 0).GetFound() != FIND_OK || GetMatching(nJob).getFindInfo(nCam, 1).GetFound() != FIND_OK)
	{
		strText.Format("NG!!");
		pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color::Red));
	}
	else
	{
		if (iFilmInspMethod == 4)
		{
			Gdiplus::Color col0 = pData->judge[0] ? Gdiplus::Color::Lime : Gdiplus::Color::Red;
			Gdiplus::Color col1 = pData->judge[1] ? Gdiplus::Color::Lime : Gdiplus::Color::Red;
			Gdiplus::Color col2 = pData->judge[2] ? Gdiplus::Color::Lime : Gdiplus::Color::Red;
			Gdiplus::Color col3 = pData->judge[3] ? Gdiplus::Color::Lime : Gdiplus::Color::Red;

			pViewer->AddHardGraphic(new GraphicLabel(10, 10 + (20 * 0), fmt("C <-> LX: %.3fmm", pData->dist_lx[0]), col0, Anchor::XCenterMiddleBottom));
			pViewer->AddHardGraphic(new GraphicLabel(10, 10 + (20 * 1), fmt("C <-> LY: %.3fmm", pData->dist_ly[0]), col2, Anchor::XCenterMiddleBottom));
			pViewer->AddHardGraphic(new GraphicLabel(10, 10 + (20 * 2), fmt("C <-> RX: %.3fmm", pData->dist_rx[0]), col1, Anchor::XCenterMiddleBottom));
			pViewer->AddHardGraphic(new GraphicLabel(10, 10 + (20 * 3), fmt("C <-> RY: %.3fmm", pData->dist_ry[0]), col3, Anchor::XCenterMiddleBottom));

			pViewer->AddHardGraphic(new GraphicLabel(10, 10 + (20 * 0), fmt("L <-> LX: %.3fmm", pData->dist_lx[1]), col0));
			pViewer->AddHardGraphic(new GraphicLabel(10, 10 + (20 * 1), fmt("L <-> LY: %.3fmm", pData->dist_ly[1]), col2));
			pViewer->AddHardGraphic(new GraphicLabel(10, 10 + (20 * 2), fmt("L <-> RX: %.3fmm", pData->dist_rx[1]), col1));
			pViewer->AddHardGraphic(new GraphicLabel(10, 10 + (20 * 3), fmt("L <-> RY: %.3fmm", pData->dist_ry[1]), col3));

			pViewer->AddHardGraphic(new GraphicLabel(-10, 10 + (20 * 0), fmt("R <-> LX: %.3fmm", pData->dist_lx[2]), col0, Anchor::BottomLeft));
			pViewer->AddHardGraphic(new GraphicLabel(-10, 10 + (20 * 1), fmt("R <-> LY: %.3fmm", pData->dist_ly[2]), col2, Anchor::BottomLeft));
			pViewer->AddHardGraphic(new GraphicLabel(-10, 10 + (20 * 2), fmt("R <-> RX: %.3fmm", pData->dist_rx[2]), col1, Anchor::BottomLeft));
			pViewer->AddHardGraphic(new GraphicLabel(-10, 10 + (20 * 3), fmt("R <-> RY: %.3fmm", pData->dist_ry[2]), col3, Anchor::BottomLeft));

			strText.Format("Panel Angle: %.3f, Attach Angle: %.3f", pData->panel_angle, pData->attach_angle);
			pViewer->AddHardGraphic(new GraphicLabel(10, -10, strText, Gdiplus::Color::Lime, Anchor::TopRight));
		}
		else if (iFilmInspMethod == 3)
		{
			strMethod = "L";
			strText.Format("%s <-> LX: %.3fmm", strMethod, pData->dist_lx[1]);
			auto color = pData->judge[0] ? COLOR_DARK_LIME : COLOR_RED;
			pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color(color | 0xff000000)));

			nEnd += 150;
			strText.Format("%s <-> LY: %.3fmm", strMethod, pData->dist_ly[1]);
			color = pData->judge[2] ? COLOR_DARK_LIME : COLOR_RED;
			pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color(color | 0xff000000)));

			nEnd += 150;
			strMethod = "R";
			strText.Format("%s <-> RX: %.3fmm", strMethod, pData->dist_rx[2]);
			color = pData->judge[1] ? COLOR_DARK_LIME : COLOR_RED;
			pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color(color | 0xff000000)));

			nEnd += 150;
			strText.Format("%s <-> RY: %.3fmm", strMethod, pData->dist_ry[2]);
			color = pData->judge[3] ? COLOR_DARK_LIME : COLOR_RED;
			pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color(color | 0xff000000)));

			nEnd += 150;
			strText.Format("Panel Angle: %.3f, Attach Angle: %.3f", pData->panel_angle, pData->attach_angle);
			pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color(COLOR_DARK_LIME | 0xff000000)));
		}
		else
		{
			strText.Format("%s <-> LX: %.3fmm", strMethod, pData->dist_lx[iFilmInspMethod]);
			auto color = pData->judge[0] ? COLOR_DARK_LIME : COLOR_RED;
			pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color(color | 0xff000000)));

			nEnd += 150;
			strText.Format("%s <-> LY: %.3fmm", strMethod, pData->dist_ly[iFilmInspMethod]);
			color = pData->judge[2] ? COLOR_DARK_LIME : COLOR_RED;
			pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color(color | 0xff000000)));

			nEnd += 150;
			if (iFilmInspMethod == 3) iFilmInspMethod = 2;
			strText.Format("%s <-> RX: %.3fmm", strMethod, pData->dist_rx[iFilmInspMethod]);
			color = pData->judge[1] ? COLOR_DARK_LIME : COLOR_RED;
			pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color(color | 0xff000000)));

			nEnd += 150;
			strText.Format("%s <-> RY: %.3fmm", strMethod, pData->dist_ry[iFilmInspMethod]);
			color = pData->judge[3] ? COLOR_DARK_LIME : COLOR_RED;
			pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color(color | 0xff000000)));

			nEnd += 150;
			strText.Format("Panel Angle: %.3f, Attach Angle: %.3f", pData->panel_angle, pData->attach_angle);
			pViewer->AddSoftGraphic(new GraphicLabel(nStart, nEnd, strText, Gdiplus::Color(COLOR_DARK_LIME | 0xff000000)));
		}
	}
	//HSJ 2022-01-08 고객요청으로 필름검사 모든 기준(Center,Left,Right)에서 나타날 수 있게 디스플레이 변경 _____END

	Gdiplus::Color cl;
	// hsj 2022-02-08 필름검사 L check 기능 추가
	if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelLcheckEnable())
	{
		if (vt_result_info[nJob].length_check_judge[nCam][0])
		{
			cl = 0xff00ff00;
			color = color_ok;
			strText.Format("Panel length : %.3f", vt_result_info[nJob].length_check[nCam][0]);
		}
		else
		{
			cl = 0xffff0000;
			color = color_ng;
			//KJH 2022-04-14 PF Attach Align L Check 디버깅
			double dPanelLengthMin = vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelLcheckLength() - vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelLcheckTorr();
			double dPanelLengthMax = vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelLcheckLength() + vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelLcheckTorr();
			strText.Format("Panel length : %.3f, Panel length Range : %.3f ~ %.3f", vt_result_info[nJob].length_check[nCam][0], dPanelLengthMin, dPanelLengthMax);
		}

		pViewer->AddHardGraphic(new GraphicLabel(10, -30, strText, cl, Anchor::TopRight));
	}

	if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLcheckEnable())
	{
		if (vt_result_info[nJob].length_check_judge[nCam][2])
		{
			cl = 0xff00ff00;
			color = color_ok;
			strText.Format("Film length : %.3f", vt_result_info[nJob].length_check[nCam][2]);
		}
		else
		{
			cl = 0xffff0000;
			color = color_ng;
			//KJH 2022-04-14 PF Attach Align L Check 디버깅
			double dFilmLengthMin = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLcheckLength() - vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLcheckTorr();
			double dFilmLengthMax = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLcheckLength() + vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLcheckTorr();
			strText.Format("Film length : %.3f, Film length Range : %.3f ~ %.3f", vt_result_info[nJob].length_check[nCam][2], dFilmLengthMin, dFilmLengthMax);
		}

		pViewer->AddHardGraphic(new GraphicLabel(10, -50, strText, cl, Anchor::TopRight));
	}

	pViewer->OnLoadImageFromPtr(pImage);
	pViewer->DirtyRefresh();

	return TRUE;
}

BOOL CLET_AlignClientDlg::Exception_Film_Insp_Judge(int nJob, CViewerEx* pViewer)
{
	double exception_spec = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmInspExceptionSpec();
	int nSpecCount = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmInspExceptionCount();

	// 앞선에서 NG 판정시 Count Reset 하고 Return;
	if (vt_result_info[nJob].pf_film_insp_data.final_judge == FALSE || nSpecCount == 0)
	{
		m_nExceptionJudgeCount = 0;
		return vt_result_info[nJob].pf_film_insp_data.final_judge;
	}

	CString strText;
	COLORREF color_red = COLOR_RED;
	COLORREF color_orange = COLOR_ORANGE;

	stFigureText tempFigText;
	int w = vt_job_info[nJob].camera_size[0].x;
	int h = vt_job_info[nJob].camera_size[0].y;

	double spec_lx = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(0);
	double spec_rx = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(1);
	double spec_ly = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(2);
	double spec_ry = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(3);

	spec_lx = abs(spec_lx);
	spec_ly = abs(spec_ly);
	spec_rx = abs(spec_rx);
	spec_ry = abs(spec_ry);

	double spec_lx_min = spec_lx - exception_spec;
	double spec_lx_max = spec_lx + exception_spec;
	double spec_rx_min = spec_rx - exception_spec;
	double spec_rx_max = spec_rx + exception_spec;
	double spec_ly_min = spec_ly - exception_spec;
	double spec_ly_max = spec_ly + exception_spec;
	double spec_ry_min = spec_ry - exception_spec;
	double spec_ry_max = spec_ry + exception_spec;
	
	bool bSepcNG = FALSE;

	// ============================ Check ===================================
	if (vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[0] < spec_lx_min ||
		vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[0] > spec_lx_max)
	{
		m_nExceptionJudgeCount++;
		strText.Format("[ LX Continue Spec(%.3f ~ %.3f) - NG ] - Counting : %d", spec_lx_min, spec_lx_max, m_nExceptionJudgeCount);
		bSepcNG = TRUE;  
	}
	else if (vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[1] < spec_rx_min ||
		vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[1] > spec_rx_max )
	{
		m_nExceptionJudgeCount++;
		strText.Format("[ RX Continue Spec(%.3f ~ %.3f) - NG ] - Counting : %d", spec_rx_min, spec_rx_max, m_nExceptionJudgeCount);
		bSepcNG = TRUE;
	}
	else if (vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[2] < spec_ly_min ||
		vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[2] > spec_ly_max )
	{
		m_nExceptionJudgeCount++;
		strText.Format("[ LY Continue Spec(%.3f ~ %.3f) - NG ] - Counting : %d", spec_ly_min, spec_ly_max, m_nExceptionJudgeCount);
		bSepcNG = TRUE;
	}
	else if (vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[3] < spec_ry_min ||
		vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[3] > spec_ry_max)
	{
		m_nExceptionJudgeCount++;
		strText.Format("[ RY Continue Spec(%.3f ~ %.3f) - NG ] - Counting : %d", spec_ry_min, spec_ry_max, m_nExceptionJudgeCount);
		bSepcNG = TRUE;
	}

	if(bSepcNG == TRUE)
	{
		//tempFigText.is_show_bkg = TRUE;
		//tempFigText.ptBegin.x = w / 4;
		//tempFigText.ptBegin.y = h * 2 / 3 + 100;
		//tempFigText.ptBeginFit.x = w / 4;
		//tempFigText.ptBeginFit.y = h * 2 / 3 + 100;
		//tempFigText.textString = strText;

		//pViewer->addFigureText(tempFigText, 10, 10, color_orange);
		pViewer->AddSoftGraphic(new GraphicLabel(w / 4, h * 2 / 3 + 100, strText, COLOR_ORANGE | 0xff000000));
	}
	else
	{
		m_nExceptionJudgeCount = 0;
		return vt_result_info[nJob].pf_film_insp_data.final_judge;
	}

	if (m_nExceptionJudgeCount >= nSpecCount)
	{
		// YCS 2022-10-27 필름 연속 3회 틀어지면 판정 NG에서 경알람 발생으로 변경
		if (m_bSimulationStart != TRUE) g_CommPLC.SetBit(m_nInspOkWrite[nJob] + 3, TRUE);

		CString strLog;
		strLog.Format(_T("[%s]Continuous Film Attachment Shift Occured"), vt_job_info[nJob].job_name.c_str());

		add_process_history(strLog);
	}
	// ============================ End Check ===============================
	
	// ============================ Draw ====================================
	if (m_nExceptionJudgeCount >= nSpecCount)
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
		pFormMain->HideErrorMessageBlink();

		strText.Format("[ Continue Spec(%.3f) NG InterLock !! ] - Counting : %d", exception_spec, m_nExceptionJudgeCount);

		/*tempFigText.ptBegin.x = w / 4;
		tempFigText.ptBegin.y = h * 2 / 3;
		tempFigText.ptBeginFit.x = w / 4;
		tempFigText.ptBeginFit.y = h * 2 / 3;
		tempFigText.textString = strText;

		pViewer->addFigureText(tempFigText, 10, 10, color_red);*/
		pViewer->AddSoftGraphic(new GraphicLabel(w / 4, h * 2 / 3, strText, COLOR_RED | 0xff000000));
		pFormMain->ShowErrorMessageBlink(strText);
	}
	// ============================ End Draw ================================
	if (bSepcNG == TRUE)
	{
		pViewer->Invalidate();
	}

	return vt_result_info[nJob].pf_film_insp_data.final_judge;
}

#pragma region 필름 검사 Tkyuha 20211015
BOOL CLET_AlignClientDlg::algorithm_Film_insp_assemble(BYTE* pImage, int nJob, int nCam, CViewerEx* mViewer)
{
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	int nview = vt_job_info[nJob].viewer_index[nCam];

	BOOL bNG = TRUE;

	stFigure tempFig;
	stFigureText tempFigText;
	tempFigText.is_show_bkg = TRUE;

	if (mViewer == NULL)
	{
		mViewer = &pFormMain->m_pDlgViewerMain[nview]->GetViewer();
	}

	auto pDC = mViewer->getOverlayDC();
	mViewer->ClearOverlayDC();
	mViewer->clearAllFigures();

	CPen penOK(PS_SOLID, 5, COLOR_GREEN);
	CPen penNG(PS_SOLID, 5, COLOR_RED);
	CPen penSum(PS_SOLID, 5, COLOR_BLUE);
	CPen penCut(PS_SOLID, 5, COLOR_YELLOW);
	CPen* pOldPen;
	CFont font, * oldFont;
	font.CreateFont(30, 30, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET,
		OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Arial");
	oldFont = pDC->SelectObject(&font);

	pDC->SetTextColor(COLOR_RED);
	pOldPen = pDC->SelectObject(&penOK);

	int real_cam = vt_job_info[nJob].camera_index[nCam];
	int W = m_stCamInfo[real_cam].w;
	int H = m_stCamInfo[real_cam].h;
	
	CString strText;

	cv::Mat img(H, W, CV_8UC1, pImage);
	////////////
	// Caliper를 사용 하여 검사 진행
	// 기준점 좌우 두점을 기준으로 하고 양쪽 거리 측정
	///////////
	int nPos = 0;
	double _px = 0.0, _py = 0.0;
	double posx[4], posy[4];
	double dx = 0.0, dy = 0.0, dt = 0.0;	
	double _x = 0, _y = 0;
	double xres = GetMachine(nJob).getCameraResolutionX(0, 0);
	double yres = GetMachine(nJob).getCameraResolutionY(0, 0);
	int bMethod = vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod();	

	BOOL bFindLine[2];
	sLine line_info[2];
	double _calcAngle[2] = { 0., };

	if (bMethod == METHOD_CALIPER) // 켈리퍼를 사용 하여 기준 마크를 찾는 경우
	{		
		for (int nC = 0; nC < 2; nC++)  // 2개 기준 포인트를 찾아 중앙점을 기준으로 잡는다.
		{
			m_pDlgCaliper->m_Caliper[real_cam][nPos + nC][C_CALIPER_POS_1].processCaliper(pImage, W, H, dx, dy, dt, TRUE);
			m_pDlgCaliper->m_Caliper[real_cam][nPos + nC][C_CALIPER_POS_2].processCaliper(pImage, W, H, dx, dy, dt, TRUE);

			line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos + nC][C_CALIPER_POS_1].m_lineInfo;
			line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos + nC][C_CALIPER_POS_2].m_lineInfo;
			bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos + nC][C_CALIPER_POS_1].getIsMakeLine();
			bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos + nC][C_CALIPER_POS_2].getIsMakeLine();

			if (bFindLine[0] && bFindLine[1])
			{
				sLine lineHori = line_info[0];
				sLine lineVert = line_info[1];
				CCaliper::cramersRules(-lineHori.a, 1, -lineVert.a, 1, lineHori.b, lineVert.b, &_px, &_py);

				_x = _x + _px;	_y = _y + _py;

				tempFig.ptBegin.x = int(_px - 40);
				//tempFig.ptBegin.x = int(_px - 40);
				//tempFig.ptBegin.y = int(_py);
				//tempFig.ptEnd.x = int(_px + 40);
				//tempFig.ptEnd.y = int(_py);
				//mViewer->addFigureLine(tempFig, 3, 2, COLOR_GREEN);

				//tempFig.ptBegin.x = int(_px);
				//tempFig.ptBegin.y = int(_py - 40);
				//tempFig.ptEnd.x = int(_px);
				//tempFig.ptEnd.y = int(_py + 40);
				//mViewer->addFigureLine(tempFig, 3, 2, COLOR_GREEN);

				mViewer->AddSoftGraphic(new GraphicPoint(_px, _py, Gdiplus::Color(COLOR_GREEN | 0xff000000), 5));

				/*pDC->MoveTo(int(_px - 40), int(_py));
				pDC->LineTo(int(_px + 40), int(_py));
				pDC->MoveTo(int(_px), int(_py - 40));
				pDC->LineTo(int(_px), int(_py + 40));*/
			}
			else 	bNG = FALSE; // 에러 발생
		}

		posx[POINT_PANEL] = _x / 2.;
		posy[POINT_PANEL] = _y / 2.;
		double x = 2 * _px - _x;
		double y = 2 * _py - _y;
		double radian = atan2(y, x);
		_calcAngle[0] = radian * 180. / CV_PI; // 라디안 -> 디그리 변환
	}
	else  // 패턴 매칭을 사용 하여 기준 마크를 찾는 경우
	{
		CPatternMatching* pPattern = &GetMatching(nJob);

		for (int nC = 0; nC < 2; nC++)  // 2개 기준 포인트를 찾아 중앙점을 기준으로 잡는다.
		{
			pPattern->findPattern(img.data, nCam, nC, W, H);
			CFindInfo find = GetMatching(nJob).getFindInfo(nCam, nC);

			m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[nC] = GetMatching(nJob).getFindInfo(nCam, nC).GetXPos();
			m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[nC] = GetMatching(nJob).getFindInfo(nCam, nC).GetYPos();

			if (find.GetFound() == FIND_OK || find.GetFound() == FIND_MATCH)
			{
				int find_index = find.GetFoundPatternNum();
				double mark_offset_x = GetMatching(nJob).getMarkOffsetX(nCam, nC, find_index);
				double mark_offset_y = GetMatching(nJob).getMarkOffsetY(nCam, nC, find_index);

				_px = find.GetXPos() + mark_offset_x;
				_py = find.GetYPos() + mark_offset_y;

				_x = _x + _px;	_y = _y + _py;

				//tempFig.ptBegin.x = int(_px);
				//tempFig.ptBegin.y = int(_py - 40);
				//tempFig.ptEnd.x = int(_px);
				//tempFig.ptEnd.y = int(_py + 40);
				//mViewer->addFigureLine(tempFig, 3, 2, COLOR_GREEN);

				//tempFig.ptBegin.x = int(_px - 40);
				//tempFig.ptBegin.y = int(_py);
				//tempFig.ptEnd.x = int(_px + 40);
				//tempFig.ptEnd.y = int(_py);
				//mViewer->addFigureLine(tempFig, 3, 2, COLOR_GREEN);
				/*pDC->MoveTo(int(_px - 40), int(_py));
				pDC->LineTo(int(_px + 40), int(_py));
				pDC->MoveTo(int(_px), int(_py - 40));
				pDC->LineTo(int(_px), int(_py + 40));*/

				mViewer->AddSoftGraphic(new GraphicPoint(_px, _py, Gdiplus::Color(COLOR_GREEN | 0xff000000), 5));
			}
			else bNG = FALSE;
		}

		posx[POINT_PANEL] = _x / 2.;
		posy[POINT_PANEL] = _y / 2.;
		double x = 2*_px -_x;
		double y = 2 * _py - _y;
		double radian = atan2(y, x);
		_calcAngle[0] = radian * 180. / CV_PI; // 라디안 -> 디그리 변환
	}

	if (bNG)	m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[POINT_PANEL] = TRUE;
	else
	{
		posx[POINT_PANEL] = 0;
		posy[POINT_PANEL] = 0;
		m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[POINT_PANEL] = FALSE;
	}

	//  기준점 저장
	m_stInsp_DistanceResult[real_cam][nPos].nCam = real_cam;
	m_stInsp_DistanceResult[real_cam][nPos].nPos = nPos;
	m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL] = posx[POINT_PANEL];
	m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL] = posy[POINT_PANEL];


	

	if (bNG) // 기준 마크를 찾은 경우에만 검사 시작
	{
		CPatternMatching* pPattern = &GetMatching(nJob);
		// 필름 좌우 2포인트 찾기
		// 켈리퍼 POS2 와 POS3 사용
		for (int i = 0; i < 2; i++)
		{
			_py = _px = -1;

			pPattern->findPattern(img.data, nCam, 2+i, W, H);

			m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_x[2+i] = GetMatching(nJob).getFindInfo(nCam, 2 + i).GetXPos();
			m_stInsp_DistanceResult[real_cam][nPos].film_insp_pos_y[2 + i] = GetMatching(nJob).getFindInfo(nCam, 2 + i).GetYPos();

			CFindInfo find = GetMatching(nJob).getFindInfo(nCam, 2 + i); //위치는 POS 2와 3에 등록 해서 사용
			if (find.GetFound() == FIND_OK || find.GetFound() == FIND_MATCH) // 마크로 등록 되어 있는 경우 처리 하기 위함
			{
				int find_index = find.GetFoundPatternNum();
				double mark_offset_x = GetMatching(nJob).getMarkOffsetX(nCam, 2 + i, find_index);
				double mark_offset_y = GetMatching(nJob).getMarkOffsetY(nCam, 2 + i, find_index);

				_px = find.GetXPos() + mark_offset_x;
				_py = find.GetYPos() + mark_offset_y;
			}

			pDC->SelectObject(&penSum);

			m_pDlgCaliper->m_Caliper[real_cam][nPos + i + 2][C_CALIPER_POS_1].processCaliper(pImage, W, H, dx, dy, dt, TRUE);
			m_pDlgCaliper->m_Caliper[real_cam][nPos + i + 2][C_CALIPER_POS_2].processCaliper(pImage, W, H, dx, dy, dt, TRUE);

			line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos + i + 2][C_CALIPER_POS_1].m_lineInfo;
			line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos + i + 2][C_CALIPER_POS_2].m_lineInfo;
			bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos + i + 2][C_CALIPER_POS_1].getIsMakeLine();
			bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos + i + 2][C_CALIPER_POS_2].getIsMakeLine();

			if (bFindLine[0] && bFindLine[1])
			{
				sLine lineHori = line_info[0];
				sLine lineVert = line_info[1];
				CCaliper::cramersRules(-lineHori.a, 1, -lineVert.a, 1, lineHori.b, lineVert.b, &posx[POINT_PANEL + i + 1], &posy[POINT_PANEL + i + 1]);
				m_stInsp_DistanceResult[real_cam][nPos + 1].bFindLine[i] = TRUE;

				if (fmod(fabs(line_info[0].a), 90) > vt_job_info[nJob].model_info.getMachineInfo().getRevisionLimit(AXIS_T) ||
					fmod(fabs(line_info[1].a), 90) > vt_job_info[nJob].model_info.getMachineInfo().getRevisionLimit(AXIS_T))
				{
					if (_py != -1 && _px != -1)
					{
						posx[POINT_PANEL + i + 1] = _px;
						posy[POINT_PANEL + i + 1] = _py;
					}
				}

				_px = posx[POINT_PANEL + i + 1];
				_py = posy[POINT_PANEL + i + 1];


				//tempFig.ptBegin.x = int(_px);
				//tempFig.ptBegin.y = int(_py - 40);
				//tempFig.ptEnd.x = int(_px);
				//tempFig.ptEnd.y = int(_py + 40);
				//mViewer->addFigureLine(tempFig, 3, 2, COLOR_BLUE);

				//tempFig.ptBegin.x = int(_px - 40);
				//tempFig.ptBegin.y = int(_py);
				//tempFig.ptEnd.x = int(_px + 40);
				//tempFig.ptEnd.y = int(_py);
				//mViewer->addFigureLine(tempFig, 3, 2, COLOR_BLUE);

				mViewer->AddSoftGraphic(new GraphicPoint(_px, _py, Gdiplus::Color(COLOR_BLUE | 0xff000000), 5));

				/*pDC->MoveTo(_px - 40, _py);
				pDC->LineTo(_px + 40, _py);
				pDC->MoveTo(_px, _py - 40);
				pDC->LineTo(_px, _py + 40);*/
			}
			else // 에러 발생
			{
				if (_py == -1 && _px == -1)
				{
					posx[POINT_PANEL + i + 1] = 0;
					posy[POINT_PANEL + i + 1] = 0;
					m_stInsp_DistanceResult[real_cam][nPos + 1].bFindLine[i] = FALSE;
					bNG = FALSE;
				}
				else  // 매칭 결과를 사용 하기 위함
				{
					posx[POINT_PANEL + i + 1] = _px;
					posy[POINT_PANEL + i + 1] = _py;
					m_stInsp_DistanceResult[real_cam][nPos + 1].bFindLine[i] = TRUE;
					_px = posx[POINT_PANEL + i + 1];
					_py = posy[POINT_PANEL + i + 1];
					/*pDC->MoveTo(_px - 40, _py);
					pDC->LineTo(_px + 40, _py);
					pDC->MoveTo(_px, _py - 40);
					pDC->LineTo(_px, _py + 40);*/


					//tempFig.ptBegin.x = int(_px);
					//tempFig.ptBegin.y = int(_py - 40);
					//tempFig.ptEnd.x = int(_px);
					//tempFig.ptEnd.y = int(_py + 40);
					//mViewer->addFigureLine(tempFig, 2, 2, COLOR_BLUE);

					//tempFig.ptBegin.x = int(_px - 40);
					//tempFig.ptBegin.y = int(_py);
					//tempFig.ptEnd.x = int(_px + 40);
					//tempFig.ptEnd.y = int(_py);
					//mViewer->addFigureLine(tempFig, 2, 2, COLOR_BLUE);

					mViewer->AddSoftGraphic(new GraphicPoint(_px, _py, Gdiplus::Color(COLOR_BLUE | 0xff000000), 5));

				}
			}

			//  기준점 저장
			m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL + i + 1] = posx[POINT_PANEL + i + 1];
			m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL + i + 1] = posy[POINT_PANEL + i + 1];

			double x = posx[2] - posx[1];
			double y = posy[2] - posy[1];
			double radian = atan2(y, x);
			_calcAngle[1] = radian * 180. / CV_PI; // 라디안 -> 디그리 변환

			if (bNG)
			{
				pDC->SelectObject(&penCut);
				
				_px = posx[POINT_PANEL + i + 1];
				_py = posy[POINT_PANEL + i + 1];
				/*pDC->MoveTo(posx[POINT_PANEL], posy[POINT_PANEL]);
				pDC->LineTo(_px , _py);*/


				//tempFig.ptBegin.x = posx[POINT_PANEL];
				//tempFig.ptBegin.y = posy[POINT_PANEL];
				//tempFig.ptEnd.x = int(_px);
				//tempFig.ptEnd.y = int(_py);
				//mViewer->addFigureLine(tempFig, 2, 2, COLOR_YELLOW);

				mViewer->AddSoftGraphic(new GraphicLine(posx[POINT_PANEL], posy[POINT_PANEL], _px, _py, Gdiplus::Color(COLOR_YELLOW | 0xff0000)));

				CPointF<int> p11(_px, _py);
				CPointF<int> p10(posx[POINT_PANEL], posy[POINT_PANEL]);
				double s_1 = GetDistance(p10, p11);

				if(i==0) m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance = s_1 * ((xres + yres) / 2.);
				else m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance = s_1 * ((xres + yres) / 2.);

				
				m_stInsp_DistanceResult[real_cam][nPos].film_insp_dist_x[i] = abs(p11.x - p10.x) * xres;
				m_stInsp_DistanceResult[real_cam][nPos].film_insp_dist_y[i] = abs(p11.y - p10.y) * yres;



				//strText.Format("(%d,%d)(%.3fmm,%.3fmm):%.3fmm", p10.x, p10.y, abs(p11.x- p10.x)* xres, abs(p11.y - p10.y)* yres, s_1 * ((xres+ yres)/2.));
				//pDC->TextOutA(_px - i * 100, i*40 + _py+40, strText);

				if (i == 0)
				{
					strText.Format("C <-> LX: %.3f, C <-> LY: %.3f", m_stInsp_DistanceResult[real_cam][nPos].film_insp_dist_x[i], m_stInsp_DistanceResult[real_cam][nPos].film_insp_dist_y[i]);
					//tempFigText.ptBegin.x = 100;
					//tempFigText.ptBegin.y = 100;
					//tempFigText.ptBeginFit.x = 100;
					//tempFigText.ptBeginFit.y = 100;
					//tempFigText.textString = strText;
					//mViewer->addFigureText(tempFigText, 16, 16, COLOR_DARK_LIME);
					mViewer->AddSoftGraphic(new GraphicLabel(100, 100, strText, Gdiplus::Color::Lime));
				}
				else
				{
					strText.Format("C <-> RX: %.3f, C <-> RY: %.3f", m_stInsp_DistanceResult[real_cam][nPos].film_insp_dist_x[i], m_stInsp_DistanceResult[real_cam][nPos].film_insp_dist_y[i]);
					//tempFigText.ptBegin.x = 100;
					//tempFigText.ptBegin.y = 300;
					//tempFigText.ptBeginFit.x = 100;
					//tempFigText.ptBeginFit.y = 300;
					//tempFigText.textString = strText;
					//mViewer->addFigureText(tempFigText, 16, 16, COLOR_DARK_LIME);
					mViewer->AddSoftGraphic(new GraphicLabel(100, 300, strText, Gdiplus::Color::Lime));
				}
			}
			else
			{
				if (i == 0) m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance = 0;
				else m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance = 0;
			}	
			
		}

		// L-check 예외처리
		//필름 좌우 거리로 길이 체크
		CPointF<int> p11(posx[POINT_PANEL+1], posy[POINT_PANEL+1]);
		CPointF<int> p10(posx[POINT_PANEL+2], posy[POINT_PANEL+2]);
		double s_1 = GetDistance(p10, p11) * ((xres + yres) / 2.);
	
		m_dLcheckCurrentValue[nJob] = s_1;
			
		double lcheckscale = vt_job_info[nJob].model_info.getAlignInfo().getLCheckScale();

		s_1 *= lcheckscale;


		double maxV = vt_job_info[nJob].model_info.getAlignInfo().getLCheckSpecX() + vt_job_info[nJob].model_info.getAlignInfo().getLCheckTor();
		double minV = vt_job_info[nJob].model_info.getAlignInfo().getLCheckSpecX() - vt_job_info[nJob].model_info.getAlignInfo().getLCheckTor();
		BOOL blcheck = vt_job_info[nJob].model_info.getAlignInfo().getEnableLCheck();

		if (blcheck && (maxV<s_1 || minV>s_1))
		{
			strText.Format("L-Check Error: %.3fmm (%.3f< V < %.3f)", s_1, minV, maxV);
			//pDC->TextOutA(posx[1], posy[1] + 120, strText);
			mViewer->AddSoftGraphic(new GraphicLabel(posx[1], posy[1] + 120, strText, Gdiplus::Color::Red));
			bNG = FALSE;
		}


		m_stInsp_DistanceResult[real_cam][nPos].film_insp_film_angle = _calcAngle[0];
		m_stInsp_DistanceResult[real_cam][nPos].film_insp_panel_angle = _calcAngle[1];


		CPointF<int> p12(posx[POINT_PANEL], posy[POINT_PANEL]);
		//strText.Format("diff(L-R)(%d,%d) -  %.3fmm \n PanelAngle: %.3f°", p12.x, p12.y,
		//	(m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance - m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance) * ((xres + yres) / 2.), _calcAngle[0]);
		//pDC->TextOutA(p12.x, p12.y - 40, strText);
		//strText.Format("Film Angle: %.3f°", _calcAngle[1]);
		//pDC->TextOutA(posx[1], posy[1] + 80, strText);
		CStringW str;
		str.Format(L"diff(L-R)(%d, %d) - %.3fmm\nPanelAngle: %.3f°", p12.x, p12.y, (m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance - m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance) * ((xres + yres) / 2.), _calcAngle[0]);

		mViewer->AddSoftGraphic(new GraphicLabel(cv::Point2f(p12.x, p12.y - 40),
			str, pDC->GetTextColor()));

		str.Format(L"Film Angle: %.3f°", _calcAngle[1]);
		mViewer->AddSoftGraphic(new GraphicLabel(cv::Point2f(posx[1], posy[1] + 80),
			str, pDC->GetTextColor()));

		strText.Format("Panel Angle: %.3f, Film Angle: %.3f", m_stInsp_DistanceResult[real_cam][nPos].film_insp_panel_angle, m_stInsp_DistanceResult[real_cam][nPos].film_insp_film_angle);
		//tempFigText.ptBegin.x = 100;
		//tempFigText.ptBegin.y = 500;
		//tempFigText.ptBeginFit.x = 100;
		//tempFigText.ptBeginFit.y = 500;
		//tempFigText.textString = strText;
		//mViewer->addFigureText(tempFigText, 16, 16, COLOR_DARK_LIME);
		mViewer->AddSoftGraphic(new GraphicLabel(100, 500, strText, Gdiplus::Color::Lime));
	}
	else
	{
		strText.Format("Inspection Error !!)");
		//pDC->TextOutA(20, 20 + nJob * 120, strText);
		//tempFigText.ptBegin.x = 100;
		//tempFigText.ptBegin.y = 100;
		//tempFigText.ptBeginFit.x = 100;
		//tempFigText.ptBeginFit.y = 100;
		//tempFigText.textString = strText;
		//mViewer->addFigureText(tempFigText, 16, 16, COLOR_RED);

		mViewer->AddSoftGraphic(new GraphicLabel(100, 100, strText, Gdiplus::Color::Red));
	}

	
	mViewer->OnLoadImageFromPtr(img.data);
	mViewer->Invalidate();

	penOK.DeleteObject();
	penNG.DeleteObject();
	penSum.DeleteObject();
	penCut.DeleteObject();
	font.DeleteObject();

	img.release();

	CPointF<int> p13(posx[0], posy[0]); // 중심
	CPointF<int> p14;
	CPointF<int> p15;

	for (int i = 0; i < 2; i++)
	{
		double Spec = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(0 + 2 * i);
		double Spec_Tolerance = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(0 + 2 * i);
		double Spec_2 = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(1 + 2 * i);
		double Spec_Tolerance_2 = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(1 + 2 * i);

		double smin = Spec - Spec_Tolerance;
		double smax = Spec + Spec_Tolerance;
		double smin2 = Spec_2 - Spec_Tolerance_2;
		double smax2 = Spec_2 + Spec_Tolerance_2;
		double res = 0;
		if (i == 0)
		{
			p14.x = posx[1];
			p14.y = posy[0];

			p15.x = posx[2];
			p15.y = posy[0];
			res = xres;
		}
		else
		{
			p14.x = posx[0];
			p14.y = posy[1];

			p15.x = posx[0];
			p15.y = posy[2];
			res = yres;
		}

		double s_1 = GetDistance(p13, p14) * res;
		double s_2 = GetDistance(p13, p15) * res;

		if (bNG && ((s_1 < smin || s_1 > smax) || (s_2 < smin2 || s_2 > smax2)))		bNG = FALSE;
	}

	if (theApp.m_bEnforceOkFlag) bNG = TRUE;

	::SendMessageA(m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_JUDGE_DISPLAY, MAKELPARAM(nJob, bNG));

	return bNG;
}
#pragma endregion

BOOL CLET_AlignClientDlg::algorithm_WetOut_Insp(BYTE* pImage, int nJob, int nCam, BOOL bManual)
{
	BOOL bNG = TRUE;
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	int nPos = 0;
	int W = m_stCamInfo[nCam].w;
	int H = m_stCamInfo[nCam].h;	
	double xres = GetMachine(nJob).getCameraResolutionX(nCam, 0);
	double yres = GetMachine(nJob).getCameraResolutionY(nCam, 0);
	int x = vt_job_info[nJob].model_info.getAlignInfo().getInspRangeX() / xres / 2; //  중심점 기준 좌우 분리
	int y = vt_job_info[nJob].model_info.getAlignInfo().getInspRangeY() / yres / 2;  //  중심점 기준 상하 분리
	double l = vt_job_info[nJob].model_info.getAlignInfo().getInspRangeLength() / xres / 2; //도포 길이

	cv::Mat img(H, W, CV_8UC1, getProcBuffer(nCam, nJob));
	cv::Mat *srcPtr = &img;

	// 거리 측정 클리어
	for (int i = 0; i < 5; i++) m_ELB_DiffInspResult[nCam].m_vTraceProfile[i].clear();

loop:
	if (m_nSeqScanInspGrabCount[nJob] != 1)
	{
		double scanlength = (m_dScanImageLength[1] - m_dScanImageLength[0]) / yres;
		double scanlength2 = (m_dScanImageLength[3] - m_dScanImageLength[2]) / yres;

		if (nPos == 0) // 첫번째 이미지
		{
			cv::Mat first_img = img(cv::Rect(0, 0, W, scanlength)).clone();
			srcPtr = &first_img;
		}
		else  // 두번째 이미지
		{
			cv::Mat second_img = img(cv::Rect(0, H- scanlength2-1, W, scanlength2)).clone();
			srcPtr = &second_img;
		}

		W = srcPtr->cols;
		H = srcPtr->rows;
	}
	
	int cx = W / 2, cy = H / 2;	
	double ax=1, bc=0,dist=0;

	CPoint ptStart = CPoint(MAX(0,cx - l), MAX(0, cy - y));
	CPoint ptEnd = CPoint(MIN(W,cx + l), MIN(H, cy + y));

	m_ELB_DiffInspResult[nCam].m_ELB_InspRoi[nPos] = CRect(ptStart, ptEnd);

	if (ptEnd.x - ptStart.x > 0 && ptEnd.y - ptStart.y > 0)
	{
		//기준선 찾기
		//pFormMain->InspLineEdgeDetection(nJob, img, ptStart, ptEnd, l);

		BOOL bFindLine[2];
		sLine line_info[2];
		double dx = 0.0, dy = 0.0, dt = 0.0, posx = 0.0, posy = 0.0;
	
		m_pDlgCaliper->m_Caliper[nCam][nPos][C_CALIPER_POS_1].processCaliper(pImage, W, H, dx, dy, dt, TRUE);
		m_pDlgCaliper->m_Caliper[nCam][nPos][C_CALIPER_POS_2].processCaliper(pImage, W, H, dx, dy, dt, TRUE);

		line_info[0] = m_pDlgCaliper->m_Caliper[nCam][nPos][C_CALIPER_POS_1].m_lineInfo;
		line_info[1] = m_pDlgCaliper->m_Caliper[nCam][nPos][C_CALIPER_POS_2].m_lineInfo;
		bFindLine[0] = m_pDlgCaliper->m_Caliper[nCam][nPos][C_CALIPER_POS_1].getIsMakeLine();
		bFindLine[1] = m_pDlgCaliper->m_Caliper[nCam][nPos][C_CALIPER_POS_2].getIsMakeLine();

		if (bFindLine[0] && bFindLine[1])
		{
			sLine lineLeft = line_info[0];
			sLine lineRight = line_info[1];

			double y1 = lineLeft.a* ptStart.x + lineLeft.b;
			double y2 = lineRight.a* ptEnd.x + lineRight.b;

			GetLineCoef(ptStart.x, y1, ptEnd.x, y2, ax, bc);

			m_ELB_TraceResult.m_ELB_ResultLine[nPos].a = ax;
			m_ELB_DiffInspResult[nCam].m_ELB_ResultLine[nPos].b = bc;
		}
		else // 에러 발생
		{
			m_ELB_DiffInspResult[nCam].m_ELB_ResultLine[nPos].a = 0;
			m_ELB_DiffInspResult[nCam].m_ELB_ResultLine[nPos].b = 0;
			bNG = FALSE;
		}

		const uchar* dataptr = srcPtr->data;
		for (int i = ptStart.x; i < ptEnd.x; i++)
		{
			y = int(i * ax + bc);
			dist = y;
			for (int j = y; j < ptEnd.y; j++)
			{
				if (dataptr[j * W + i] > 200) // 기준 Thresh 배경이 white 인경우//  임시 사용
				{
					dist = j;
					break;
				}
			}

			m_ELB_DiffInspResult[nCam].m_vTraceProfile[0].push_back(i);
			m_ELB_DiffInspResult[nCam].m_vTraceProfile[1].push_back(dist);
			m_ELB_DiffInspResult[nCam].m_vTraceProfile[2].push_back((dist-y)* yres);
		}

		if (m_nSeqScanInspGrabCount[nJob] != 1 && nPos< m_nSeqScanInspGrabCount[nJob]) // 2개의 이미지 인경우 처리
		{
			nPos++;
			goto loop;
		}

		double Spec = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(0);
		double Spec_Tolerance = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(0);
		double smin = Spec - Spec_Tolerance;
		double smax = Spec + Spec_Tolerance;
		// OK NG 판정
		for (int i = 0; i < m_ELB_DiffInspResult[nCam].m_vTraceProfile[0].size(); i++)
		{
			double v = m_ELB_DiffInspResult[nCam].m_vTraceProfile[2].at(i);
			if (v < smin || v > smax)
			{
				bNG = TRUE;
				break;
			}
		}

		if (theApp.m_bEnforceOkFlag) bNG = TRUE;
	}

	return bNG;
}
int CLET_AlignClientDlg::algorithm_AlignExist(BYTE *pImage, int nAlgo, int nCam, BOOL bManual)
{
	BOOL bNG = FALSE;
	int nSubResult[2] = { 0, };
	BOOL bPatternFind = TRUE;
	BOOL bInspResult = 3;
	CString strTemp;	

	double avgLimit			= vt_job_info[nAlgo].model_info.getInspSpecParaInfo().getExistPanelGray();
	double avgDummyLimit	= vt_job_info[nAlgo].model_info.getInspSpecParaInfo().getExistDummyGray();
	int real_cam			= vt_job_info[nAlgo].camera_index[nCam];

	int W = m_stCamInfo[real_cam].w;
	int H = m_stCamInfo[real_cam].h;

	cv::Mat img(H, W, CV_8UC1, pImage);

	cv::Scalar scalar = cv::mean(img);
	if (scalar.val[0] < 10)
	{
		bInspResult = -1;
		strTemp.Format("Averge Gray(%.1f) less than 10!! NG!!!", scalar.val[0]);
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
		return bInspResult;
	}

	CRect rectROI = GetMatching(nAlgo).getSearchROI(nCam, 0);
	cv::Mat InspImg = img(cv::Rect(rectROI.left, rectROI.top, rectROI.Width(), rectROI.Height()));

	scalar = cv::mean(InspImg);

	CPatternMatching *pPattern = &GetMatching(nAlgo);
	pPattern->findPattern(img.data, nCam, 0, W, H);
	
	CFindInfo find = GetMatching(nAlgo).getFindInfo(nCam, 0);
	
	if (scalar.val[0] > avgDummyLimit)		bInspResult = 3;
	else if (scalar.val[0] < avgLimit)		bInspResult = 1;
	else									bInspResult = 2;

	// 0 : Empty
	// 1 : UTG
	// 2 : 간지	
	CString strObject;

	if (bInspResult == 3)			strObject = "Empty";
	else if (bInspResult == 1)		strObject = "GLASS";
	else if (bInspResult == 2)		strObject = "Separator";
	else if (bInspResult == -1)		strObject = "Light Error";

	strTemp.Format("Result : %s - %s", strObject, bNG ? "NG" : "OK");
	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
		
	m_nExistResult = bInspResult;
	m_dExistResultData = scalar.val[0];

	return bInspResult;
}
BOOL CLET_AlignClientDlg::algorithm_pcb_Insp(BYTE *pImage, _stFindPattern *pPattern, int nInspMethod, BOOL bSubDir)
{
	BOOL bInspResult = TRUE;
	CString strTemp;

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;
	int nJob = pPattern->nJob;
	int nSCount = pPattern->nSearchCount;

	int real_cam = vt_job_info[nJob].camera_index[nCam];

	m_stInsp_DistanceResult[real_cam][nPos].nCam = real_cam;
	m_stInsp_DistanceResult[real_cam][nPos].nPos = nPos;

	int W = m_stCamInfo[real_cam].w;
	int H = m_stCamInfo[real_cam].h;

	// 평균 밝기를 구하자.
	cv::Mat img(H, W, CV_8UC1, pImage);
	cv::Scalar gray = cv::mean(img);
	m_stInsp_DistanceResult[real_cam][nPos].avg_image_gray = gray.val[0];

	/*
	cv::Mat img(H, W, CV_8UC1, pImage);

	CString strFile;

	strFile.Format("D:\\img_%d_%d_%d.bmp", real_cam, nPos, nJob);
	imwrite((LPCTSTR)strFile, img);
	*/

	int bMethod = vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod();
	int target_dir = vt_job_info[nJob].model_info.getAlignInfo().getAlignmentTargetDir();

	BOOL bFindLine[2];								// 찾은 여부확인
	sLine line_info[2];								// 라인
	double posx[4], posy[4];						// { POINT_PANEL, POINT_PCB_BOTTOM, POINT_CROSS_1, POINT_CROSS_2}
	double dx = 0.0, dy = 0.0, dt = 0.0;			// Panel Mark Fixture
	double dx2 = 0.0, dy2 = 0.0, dt2 = 0.0;			// PCB_BOTTOM Mark Fixture

	BOOL bLineDir = vt_job_info[nJob].model_info.getAlignInfo().getAlignmentTargetDir();
	if (bSubDir) {
		bLineDir = vt_job_info[nJob].model_info.getAlignInfo().getInspectionSubDir();
	}
	m_stInsp_DistanceResult[real_cam][nPos].nInspMethodType = nInspMethod;
	m_stInsp_DistanceResult[real_cam][nPos].bInspMethodDir = bLineDir;

	strTemp.Format("[%s]Cam %d - %d algo Start ", vt_job_info[nJob].job_name.c_str(), nCam+1, nPos+1);
	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

#pragma region 첫번째 위치(PANEL)찾기
	/////////////////////////////////////////////////////////////////////////////////////
	////////////////////////// 첫번째 위치(PANEL)찾기

	switch (nInspMethod)
	{
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark ( Panel )
	case DISTANCE_INSP_METHOD_M_TO_E: // Mark ( Panel )
	{
#pragma region MARK를 찾자!! M_TO_E는 아래에서 EDGE 찾을꺼임.
		////////////////// Position 1 Mark 찾기
		if (GetMatching(nJob).findPattern(pImage, nCam, POINT_PANEL, W, H))
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = TRUE;
			double posX1 = GetMatching(nJob).getFindInfo(nCam, POINT_PANEL).GetXPos();
			double posY1 = GetMatching(nJob).getFindInfo(nCam, POINT_PANEL).GetYPos();

			m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL] = posX1;
			m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL] = posY1;
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = FALSE;
		}
#pragma endregion
	}
	break;
	case DISTANCE_INSP_METHOD_E_TO_E: //Edge ( Panel ) 
	{
#pragma region FIxture 구하는 부분
		int nMethod = vt_job_info[nJob].algo_method;
		//if (nMethod != CLIENT_TYPE_PCB_DISTANCE_INSP)
		{
			// Bending 검사 Panel 찾을 때는 Fixture 반영 하지 않도록.
			double fixtureX = 0, fixtureY = 0, posX = 0, posY = 0;
			GetMatching(nJob).findPattern(pImage, nCam, nPos, W, H); //panel
			fixtureX = GetMatching(nJob).getFixtureX(nCam, nPos);
			fixtureY = GetMatching(nJob).getFixtureY(nCam, nPos);
			posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
			posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

			if (fixtureX != 0.0 && fixtureY != 0.0)
			{
				dx = posX - fixtureX; dy = posY - fixtureY;
				dt = 0.0;
			}
		}
#pragma endregion

#pragma region 패널 엣지를 찾자 (CALIPER)
		// 일단 fixture 반영 되지 않도록 강제로 0.0 적용	21.03.06
		/*m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].processCaliper(pImage, W, H, dx, dy, dt, FALSE);
		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].processCaliper(pImage, W, H, dx, dy, dt, FALSE);*/

		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].processCaliper(pImage, W, H, 0.0, 0.0, dt, FALSE);
		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].processCaliper(pImage, W, H, 0.0, 0.0, dt, FALSE);

		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].m_lineInfo;
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].m_lineInfo;
		bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].getIsMakeLine();
		bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].getIsMakeLine();

		if (bFindLine[0] && bFindLine[1])
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = TRUE;

			sLine lineHori = line_info[0];
			sLine lineVert = line_info[1];

			m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_VERT] = line_info[0];
			m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_HORI] = line_info[1];

			CCaliper::cramersRules(-lineHori.a, 1, -lineVert.a, 1, lineHori.b, lineVert.b, &posx[POINT_PANEL], &posy[POINT_PANEL]);

			double dAngle = calcIncludedAngle(lineHori, lineVert);
			m_stInsp_DistanceResult[real_cam][nPos].included_angle[FIND_PANEL] = dAngle;
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = FALSE;
			break;
		}
#pragma endregion

		// PANEL 찾은 교차점 저장
		m_stInsp_DistanceResult[real_cam][nPos].nPos = nPos;
		m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL] = posx[POINT_PANEL];
		m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL] = posy[POINT_PANEL];
	}
	break;
	case DISTANCE_INSP_METHOD_L_TO_M: //Line ( Panel )
	case DISTANCE_INSP_METHOD_L_TO_E: //Line ( Panel )
	{	
		{
			// Bending 검사 Panel 찾을 때는 Fixture 반영 하지 않도록.
#pragma region FIXTURE 구하자

			double fixtureX = 0, fixtureY = 0, posX = 0, posY = 0;
			GetMatching(nJob).findPattern(pImage, nCam, nPos, W, H); //panel
			fixtureX = GetMatching(nJob).getFixtureX(nCam, nPos);
			fixtureY = GetMatching(nJob).getFixtureY(nCam, nPos);
			posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
			posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

			if (fixtureX != 0.0 && fixtureY != 0.0)
			{
				dx = posX - fixtureX; dy = posY - fixtureY;
				dt = 0.0;
			}
		}
#pragma endregion

#pragma region PANEL EDGE 찾자(CALIPER - 단방향)
		if (bLineDir == TRUE)	// 설정한 방향이 Verticla 일때
		{
			m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].processCaliper(pImage, W, H, dx, dy, dt, FALSE);
			line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].m_lineInfo;
			bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].getIsMakeLine();

			if (bFindLine[0])
			{
				m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = TRUE;
				m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PANEL_VERT] = TRUE;
				m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_VERT] = line_info[0];
			}
			else
			{
				m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = FALSE;
				m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PANEL_VERT] = FALSE;
			}
		}
		else   // 설정한 방향이 Horizontal 일때
		{
			//m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].processCaliper(pImage, W, H, dx, dy, dt, FALSE);
			// fixuture 0.0으로 21.03.06

			m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].processCaliper(pImage, W, H, 0.0, 0.0, dt, FALSE);
			line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].m_lineInfo;
			bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].getIsMakeLine();

			if (bFindLine[1])
			{
				m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = TRUE;
				m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PANEL_HORI] = TRUE;
				m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_HORI] = line_info[1];
			}
			else
			{
				m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = FALSE;
				m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PANEL_HORI] = FALSE;
			}
		}
#pragma endregion

	}
	break;
	}

	if (m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] == FALSE)
	{
		bInspResult = FALSE;
	}
#pragma endregion

	/////////////////////////////////////////////////////////////////////////////////////
	////////////////////////// 두번째 위치(PCB or Bottom)찾기
	double posX1 = m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL];		// 첫번째 찾은 X 좌표
	double posY1 = m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL];		// 첫번째 찾은 Y 좌표

	switch (nInspMethod)
	{
#pragma region DISTANCE_INSP_METHOD_M_TO_M
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark ( PCB )
	{
		if (GetMatching(nJob).findPattern(pImage, nCam, nPos, W, H))
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = TRUE;
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = FALSE;
			break;
		}

		double posX2 = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		double posY2 = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

		m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PCB_BOTTOM] = posX2;
		m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PCB_BOTTOM] = posY2;

		GetMachine(nJob).PixelToWorld(nCam, 0, posX1, posY1, &posX1, &posY1);
		GetMachine(nJob).PixelToWorld(nCam, 0, posX2, posY2, &posX2, &posY2);

		// Point To Point 거리 계산
		m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance = fabs(posX2 - posX1);
		m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance = fabs(posY2 - posY1);

		m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 0);
		m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 1);

//		m_stInsp_DistanceResult[real_cam][nPos].dDistance = sqrt(pow(posX2 - posX1, 2) + pow(posY2 - posY1, 2));
		m_stInsp_DistanceResult[real_cam][nPos].dDistance = sqrt(pow(m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance, 2) + pow(m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance, 2));

	}
	break;
#pragma endregion

#pragma region DISTANCE_INSP_METHOD_M_TO_E, E_TO_E, L_TO_M, L_TO_E

	case DISTANCE_INSP_METHOD_M_TO_E: // Edge ( PCB )
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge ( PCB )
	case DISTANCE_INSP_METHOD_L_TO_M: // Line ( PCB )
	case DISTANCE_INSP_METHOD_L_TO_E: // Line ( PCB )
	{

#pragma region Fixture 구하자
		//if (bMarkUse)//Pos 1번 마크 기준
		{
			double fixtureX = 0, fixtureY = 0, posX = 0, posY = 0;
			GetMatching(nJob).findPattern(pImage, nCam, nPos, W, H); //panel
			fixtureX = GetMatching(nJob).getFixtureX(nCam, nPos);
			fixtureY = GetMatching(nJob).getFixtureY(nCam, nPos);
			posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
			posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

			if (fixtureX != 0.0 && fixtureY != 0.0)
			{
				dx2 = posX - fixtureX; dy2 = posY - fixtureY;
				dt2 = 0.0;
			}
		}
#pragma endregion

#pragma region Find PCB Vertical (Caliper)
		// Find PCB Vertical
		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_VERT].processCaliper(pImage, W, H, dx2, dy2, dt2, TRUE);
		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_VERT].m_lineInfo;
		bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_VERT].getIsMakeLine();

		if (bFindLine[0])
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = TRUE;
			m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PCB_VERT] = TRUE;
			m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PCB_VERT] = line_info[0];
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = FALSE;
			m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PCB_VERT] = FALSE;
		}
#pragma endregion

#pragma region Find PCB Horizontal (Caliper)
		// Find PCB Horizontal
		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_HORI].processCaliper(pImage, W, H, dx2, dy2, dt2, TRUE);
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_HORI].m_lineInfo;
		bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_HORI].getIsMakeLine();
		if (bFindLine[1])
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = TRUE;
			m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PCB_HORI] = TRUE;
			m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PCB_HORI] = line_info[1];
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = FALSE;
			m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PCB_HORI] = FALSE;
		}
#pragma endregion

#pragma region PCB Edge 교차점 구하기
		////////// PCB Edge 교차점 구하기
		sLine lineHori = m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PCB_HORI];
		sLine lineVert = m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PCB_VERT];
		CCaliper::cramersRules(-lineHori.a, 1, -lineVert.a, 1, lineHori.b, lineVert.b, &posx[POINT_PCB_BOTTOM], &posy[POINT_PCB_BOTTOM]);

		m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PCB_BOTTOM] = posx[POINT_PCB_BOTTOM];
		m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PCB_BOTTOM] = posy[POINT_PCB_BOTTOM];
#pragma endregion

		if (bFindLine[0] != TRUE || bFindLine[1] != TRUE)	break;

		double dAngle = calcIncludedAngle(lineHori, lineVert);
		m_stInsp_DistanceResult[real_cam][nPos].included_angle[FIND_PCB_BOTTOM] = dAngle;

		//////////////////////////////////////////
#pragma region 계산하는 부분
		/////////  계산	
		switch (nInspMethod)
		{
		case DISTANCE_INSP_METHOD_M_TO_E: // Point(PANEL) To Point(PCB_BOTTOM) 거리 계산
		{
			GetMachine(nJob).PixelToWorld(nCam, 0, posX1, posY1, &posx[POINT_PANEL], &posy[POINT_PANEL]);
			GetMachine(nJob).PixelToWorld(nCam, 0, posx[POINT_PCB_BOTTOM], posy[POINT_PCB_BOTTOM], &posx[POINT_PCB_BOTTOM], &posy[POINT_PCB_BOTTOM]);

			m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance = fabs(posx[POINT_PCB_BOTTOM] - posx[POINT_PANEL]);
			m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance = fabs(posy[POINT_PCB_BOTTOM] - posy[POINT_PANEL]);
			m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 0);
			m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 1);
			m_stInsp_DistanceResult[real_cam][nPos].dDistance = sqrt(pow(m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance, 2) + pow(m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance, 2));
		}
		break;
		case DISTANCE_INSP_METHOD_E_TO_E: // Point(PCB_BOTTOM) To Point(PANEL과 PCB_BOTTOM 교차점) 거리 계산
		{
			double robot_x[3];
			double robot_y[3];

			//POINT_CROSS_1 다시 구하자.
			sPoint point_on_line = { 0, };

			int nMetho = vt_job_info[nJob].algo_method;
			if (nMetho == CLIENT_TYPE_ASSEMBLE_INSP)
			{
				sPoint point = { m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PCB_BOTTOM], m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PCB_BOTTOM] };
				GetMatching(nJob).compute_orthogonal_point_on_line(m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_HORI], point, point_on_line);
				posx[POINT_CROSS_1] = point_on_line.x;
				posy[POINT_CROSS_1] = point_on_line.y;

				m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_CROSS_1] = point_on_line.x;
				m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_CROSS_1] = point_on_line.y;


				GetMatching(nJob).compute_orthogonal_point_on_line(m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_VERT], point, point_on_line);
				posx[POINT_CROSS_2] = point_on_line.x;
				posy[POINT_CROSS_2] = point_on_line.y;

				m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_CROSS_2] = point_on_line.x;
				m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_CROSS_2] = point_on_line.y;
			}
			else
			{
				sPoint point = { m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL], m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL] };
				GetMatching(nJob).compute_orthogonal_point_on_line(m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PCB_VERT], point, point_on_line);
				posx[POINT_CROSS_1] = point_on_line.x;
				posy[POINT_CROSS_1] = point_on_line.y;

				m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_CROSS_1] = point_on_line.x;
				m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_CROSS_1] = point_on_line.y;


				GetMatching(nJob).compute_orthogonal_point_on_line(m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PCB_HORI], point, point_on_line);
				posx[POINT_CROSS_2] = point_on_line.x;
				posy[POINT_CROSS_2] = point_on_line.y;

				m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_CROSS_2] = point_on_line.x;
				m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_CROSS_2] = point_on_line.y;
			}

			// 로봇 좌표계로 변환
			GetMachine(nJob).PixelToWorld(nCam, 0, posx[POINT_PCB_BOTTOM], posy[POINT_PCB_BOTTOM], &robot_x[0], &robot_y[0]);
			GetMachine(nJob).PixelToWorld(nCam, 0, posx[POINT_CROSS_1], posy[POINT_CROSS_1], &robot_x[1], &robot_y[1]);	// y계산
			GetMachine(nJob).PixelToWorld(nCam, 0, posx[POINT_CROSS_2], posy[POINT_CROSS_2], &robot_x[2], &robot_y[2]);	// x계산

			double dx_height = robot_x[0] - robot_x[1];
			double dy_height = robot_y[0] - robot_y[1];
			double dx_width = robot_x[0] - robot_x[2];
			double dy_width = robot_y[0] - robot_y[2];

			// Line 교차점과 두번 Point 거리 결과
			double dHeightDistance = sqrt(dx_height * dx_height + dy_height * dy_height);
			double dWidthDistance = sqrt(dx_width * dx_width + dy_width * dy_width);

			m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance = dHeightDistance;
			m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance = dWidthDistance;
			m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 0);
			m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 1);
		}
		break;
		case DISTANCE_INSP_METHOD_L_TO_M:	// Point(PCB_BOTTOM)와 Line(PANEL) 거리 계산
		case DISTANCE_INSP_METHOD_L_TO_E:
		{
			double robot_x[2];
			double robot_y[2];
			sPoint point_on_line = { 0, };

			// PCB Edge 찾은 Point
			sPoint point = { m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PCB_BOTTOM], m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PCB_BOTTOM] };

			if (bLineDir == TRUE)
			{
				// PANEL 수직선과 PCB Point 수선의발 찾기
				GetMatching(nJob).compute_orthogonal_point_on_line(m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_VERT], point, point_on_line);
			}
			else
			{
				// PANEL 수평선과 PCB Point 수선의발 찾기
				GetMatching(nJob).compute_orthogonal_point_on_line(m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_HORI], point, point_on_line);
			}

			// 로봇 좌표계로 변환
			// 두 점간의 길이를 계산하자
			GetMachine(nJob).PixelToWorld(nCam, 0, point.x, point.y, &robot_x[0], &robot_y[0]);
			GetMachine(nJob).PixelToWorld(nCam, 0, point_on_line.x, point_on_line.y, &robot_x[1], &robot_y[1]);

			double dx = robot_x[0] - robot_x[1];
			double dy = robot_y[0] - robot_y[1];

			m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_CROSS_1] = point_on_line.x;
			m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_CROSS_1] = point_on_line.y;

			double dDistance = sqrt(dx * dx + dy * dy);

			if (bLineDir == TRUE) // 방향 Vertical 일때
			{
				//m_stInsp_DistanceResult[real_cam][nPos].dDistance = dDistance;
				m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance = dDistance; 
				m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 0);

				m_stInsp_DistanceResult[real_cam][nPos].dDistance = m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance;
			}
			else
			{
				//m_stInsp_DistanceResult[real_cam][nPos].dDistance = dDistance;
				m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance = dDistance;

				m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 1);
				m_stInsp_DistanceResult[real_cam][nPos].dDistance = m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance;
			}
		}

		break;
#pragma endregion
		}
		break;
	}
	break;
#pragma endregion

	}

	if (m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] == FALSE || m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] == FALSE)
	{
		bInspResult = FALSE;
	}

	strTemp.Format("[%s]Cam %d - %d (%s) algo End ", vt_job_info[nJob].job_name.c_str(), nCam+1, nPos+1, bInspResult == TRUE ? "OK" : "NG");
	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

	m_pDlgCaliper->m_pCaliperParam->updateUIFromData();
	m_pDlgCaliper->m_pCaliperParam->updateCoordinates();

	return bInspResult;
}
BOOL CLET_AlignClientDlg::algorithm_assemble_Insp(BYTE *pImage, _stFindPattern *pPattern, int nInspMethod, BOOL bSubDir)
{
	BOOL bInspResult = TRUE;
	CString strTemp;

	int nCam = pPattern->nCam;
	int nPos = 0;
	int nJob = pPattern->nJob;
	int nSCount = pPattern->nSearchCount;

	int real_cam = vt_job_info[nJob].camera_index[nCam];

	m_stInsp_DistanceResult[real_cam][nPos].nCam = real_cam;
	m_stInsp_DistanceResult[real_cam][nPos].nPos = nPos;

	int W = m_stCamInfo[real_cam].w;
	int H = m_stCamInfo[real_cam].h;

	
	cv::Mat img(H, W, CV_8UC1, pImage);
	cv::Scalar gray = cv::mean(img);
	m_stInsp_DistanceResult[real_cam][nPos].avg_image_gray = gray.val[0];
		

	/*
	cv::Mat img(H, W, CV_8UC1, pImage);

	CString strFile;

	strFile.Format("D:\\img_%d_%d_%d.bmp", real_cam, nPos, nJob);
	imwrite((LPCTSTR)strFile, img);
	*/

	int bMethod = vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod();
	int target_dir = vt_job_info[nJob].model_info.getAlignInfo().getAlignmentTargetDir();

	BOOL bFindLine[2];								// 찾은 여부확인
	sLine line_info[2];								// 라인
	double posx[4], posy[4];						// { POINT_PANEL, POINT_PCB_BOTTOM, POINT_CROSS_1, POINT_CROSS_2}
	double dx = 0.0, dy = 0.0, dt = 0.0;			// Panel Mark Fixture
	double dx2 = 0.0, dy2 = 0.0, dt2 = 0.0;			// PCB_BOTTOM Mark Fixture

	BOOL bLineDir = vt_job_info[nJob].model_info.getAlignInfo().getAlignmentTargetDir();
	if (bSubDir) {
		bLineDir = vt_job_info[nJob].model_info.getAlignInfo().getInspectionSubDir();
	}
	m_stInsp_DistanceResult[real_cam][nPos].nInspMethodType = nInspMethod;
	m_stInsp_DistanceResult[real_cam][nPos].bInspMethodDir = bLineDir;

	strTemp.Format("[%s]Cam %d - %d algo Start ", vt_job_info[nJob].job_name.c_str(), nCam + 1, nPos + 1);
	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

#pragma region 첫번째 위치(PANEL)찾기
	/////////////////////////////////////////////////////////////////////////////////////
	////////////////////////// 첫번째 위치(PANEL)찾기

	switch (nInspMethod)
	{
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark ( Panel )
	case DISTANCE_INSP_METHOD_M_TO_E: // Mark ( Panel )
	{
#pragma region MARK를 찾자!! M_TO_E는 아래에서 EDGE 찾을꺼임.
		////////////////// Position 1 Mark 찾기
		if (GetMatching(nJob).findPattern(pImage, nCam, POINT_PANEL, W, H))
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = TRUE;
			double posX1 = GetMatching(nJob).getFindInfo(nCam, POINT_PANEL).GetXPos();
			double posY1 = GetMatching(nJob).getFindInfo(nCam, POINT_PANEL).GetYPos();

			m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL] = posX1;
			m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL] = posY1;
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = FALSE;
		}
#pragma endregion
	}
	break;
	case DISTANCE_INSP_METHOD_E_TO_E: //Edge ( Panel ) 
	{
#pragma region FIxture 구하는 부분
		int nMethod = vt_job_info[nJob].algo_method;

		double fixtureX = 0, fixtureY = 0, posX = 0, posY = 0;
		GetMatching(nJob).findPattern(pImage, nCam, nPos, W, H); //panel
		fixtureX = GetMatching(nJob).getFixtureX(nCam, nPos);
		fixtureY = GetMatching(nJob).getFixtureY(nCam, nPos);
		posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

		if (fixtureX != 0.0 && fixtureY != 0.0)
		{
			dx = posX - fixtureX; dy = posY - fixtureY;
			dt = 0.0;
		}
#pragma endregion

#pragma region 패널 엣지를 찾자 (CALIPER)
		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].processCaliper(pImage, W, H, dx, dy, dt, FALSE);
		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].processCaliper(pImage, W, H, dx, dy, dt, FALSE);

		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].m_lineInfo;
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].m_lineInfo;
		bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].getIsMakeLine();
		bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].getIsMakeLine();

		if (bFindLine[0] && bFindLine[1])
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = TRUE;

			sLine lineHori = line_info[0];
			sLine lineVert = line_info[1];

			m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_VERT] = line_info[0];
			m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_HORI] = line_info[1];

			CCaliper::cramersRules(-lineHori.a, 1, -lineVert.a, 1, lineHori.b, lineVert.b, &posx[POINT_PANEL], &posy[POINT_PANEL]);

			double dAngle = calcIncludedAngle(lineHori, lineVert);
			m_stInsp_DistanceResult[real_cam][nPos].included_angle[FIND_PANEL] = dAngle;
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = FALSE;
			break;
		}
#pragma endregion

		// PANEL 찾은 교차점 저장
		m_stInsp_DistanceResult[real_cam][nPos].nPos = nPos;
		m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL] = posx[POINT_PANEL];
		m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL] = posy[POINT_PANEL];
	}
	break;
	case DISTANCE_INSP_METHOD_L_TO_M: //Line ( Panel )
	case DISTANCE_INSP_METHOD_L_TO_E: //Line ( Panel )
	{
#pragma region FIXTURE 구하자
		double fixtureX = 0, fixtureY = 0, posX = 0, posY = 0;
		GetMatching(nJob).findPattern(pImage, nCam, nPos, W, H); //panel
		fixtureX = GetMatching(nJob).getFixtureX(nCam, nPos);
		fixtureY = GetMatching(nJob).getFixtureY(nCam, nPos);
		posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

		if (fixtureX != 0.0 && fixtureY != 0.0)
		{
			dx = posX - fixtureX; dy = posY - fixtureY;
			dt = 0.0;
		}
#pragma endregion

#pragma region PANEL EDGE 찾자(CALIPER - 단방향)
		if (bLineDir == TRUE)	// 설정한 방향이 Verticla 일때
		{
			m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].processCaliper(pImage, W, H, dx, dy, dt, FALSE);
			line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].m_lineInfo;
			bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].getIsMakeLine();

			if (bFindLine[0])
			{
				m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = TRUE;
				m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PANEL_VERT] = TRUE;
				m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_VERT] = line_info[0];
			}
			else
			{
				m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = FALSE;
				m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PANEL_VERT] = FALSE;
			}
		}
		else   // 설정한 방향이 Horizontal 일때
		{
			//m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].processCaliper(pImage, W, H, dx, dy, dt, FALSE);
			// fixuture 0.0으로 21.03.06

			m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].processCaliper(pImage, W, H, dx, dy, dt, FALSE);
			line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].m_lineInfo;
			bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].getIsMakeLine();

			if (bFindLine[1])
			{
				m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = TRUE;
				m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PANEL_HORI] = TRUE;
				m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_HORI] = line_info[1];
			}
			else
			{
				m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = FALSE;
				m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PANEL_HORI] = FALSE;
			}
		}
#pragma endregion

	}
	break;
	}

	if (m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] == FALSE)
	{
		bInspResult = FALSE;
	}
#pragma endregion

#pragma region 두번째 위치(Bottom)찾기
	/////////////////////////////////////////////////////////////////////////////////////
	////////////////////////// 두번째 위치(PCB or Bottom)찾기
	double posX1 = m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL];		// 첫번째 찾은 X 좌표
	double posY1 = m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL];		// 첫번째 찾은 Y 좌표

	switch (nInspMethod)
	{
#pragma region DISTANCE_INSP_METHOD_M_TO_M
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark ( PCB )
	{
		if (GetMatching(nJob).findPattern(pImage, nCam, nPos, W, H))
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = TRUE;
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = FALSE;
			break;
		}

		double posX2 = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		double posY2 = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

		m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PCB_BOTTOM] = posX2;
		m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PCB_BOTTOM] = posY2;

		GetMachine(nJob).PixelToWorld(nCam, 0, posX1, posY1, &posX1, &posY1);
		GetMachine(nJob).PixelToWorld(nCam, 0, posX2, posY2, &posX2, &posY2);

		// Point To Point 거리 계산
		m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance = fabs(posX2 - posX1);
		m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance = fabs(posY2 - posY1);

		m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 0);
		m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 1);

		//		m_stInsp_DistanceResult[real_cam][nPos].dDistance = sqrt(pow(posX2 - posX1, 2) + pow(posY2 - posY1, 2));
		m_stInsp_DistanceResult[real_cam][nPos].dDistance = sqrt(pow(m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance, 2) + pow(m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance, 2));

	}
	break;
#pragma endregion

#pragma region DISTANCE_INSP_METHOD_M_TO_E, E_TO_E, L_TO_M, L_TO_E

	case DISTANCE_INSP_METHOD_M_TO_E: // Edge ( PCB )
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge ( PCB )
	case DISTANCE_INSP_METHOD_L_TO_M: // Line ( PCB )
	case DISTANCE_INSP_METHOD_L_TO_E: // Line ( PCB )
	{
#pragma region Fixture 구하자
		double fixtureX = 0, fixtureY = 0, posX = 0, posY = 0;
		GetMatching(nJob).findPattern(pImage, nCam, nPos, W, H); 
		fixtureX = GetMatching(nJob).getFixtureX(nCam, nPos);
		fixtureY = GetMatching(nJob).getFixtureY(nCam, nPos);
		posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
		posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

		if (fixtureX != 0.0 && fixtureY != 0.0)
		{
			dx2 = posX - fixtureX; dy2 = posY - fixtureY;
			dt2 = 0.0;
		}
#pragma endregion

#pragma region Find BOTTOM Vertical (Caliper)
		// Find PCB Vertical
		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_VERT].processCaliper(pImage, W, H, dx2, dy2, dt2, TRUE);
		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_VERT].m_lineInfo;
		bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_VERT].getIsMakeLine();

		if (bFindLine[0])
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = TRUE;
			m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PCB_VERT] = TRUE;
			m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PCB_VERT] = line_info[0];
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = FALSE;
			m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PCB_VERT] = FALSE;
		}
#pragma endregion

#pragma region Find BOTTOM Horizontal (Caliper)
		// Find PCB Horizontal
		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_HORI].processCaliper(pImage, W, H, dx2, dy2, dt2, TRUE);
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_HORI].m_lineInfo;
		bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PCB_HORI].getIsMakeLine();
		if (bFindLine[1])
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = TRUE;
			m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PCB_HORI] = TRUE;
			m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PCB_HORI] = line_info[1];
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = FALSE;
			m_stInsp_DistanceResult[real_cam][nPos].bFindLine[FIND_CALIPER_PCB_HORI] = FALSE;
		}
#pragma endregion

#pragma region PCB Edge 교차점 구하기
		////////// PCB Edge 교차점 구하기
		sLine lineHori = m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PCB_HORI];
		sLine lineVert = m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PCB_VERT];
		CCaliper::cramersRules(-lineHori.a, 1, -lineVert.a, 1, lineHori.b, lineVert.b, &posx[POINT_PCB_BOTTOM], &posy[POINT_PCB_BOTTOM]);

		m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PCB_BOTTOM] = posx[POINT_PCB_BOTTOM];
		m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PCB_BOTTOM] = posy[POINT_PCB_BOTTOM];
#pragma endregion

		if (bFindLine[0] != TRUE || bFindLine[1] != TRUE)	break;
		//////////////////////////////////////////

		double dAngle = calcIncludedAngle(lineHori, lineVert);
		m_stInsp_DistanceResult[real_cam][nPos].included_angle[FIND_PCB_BOTTOM] = dAngle;

#pragma region 계산하는 부분
		/////////  계산	
		switch (nInspMethod)
		{
		case DISTANCE_INSP_METHOD_M_TO_E: // Point(PANEL) To Point(PCB_BOTTOM) 거리 계산
		{
			GetMachine(nJob).PixelToWorld(nCam, 0, posX1, posY1, &posx[POINT_PANEL], &posy[POINT_PANEL]);
			GetMachine(nJob).PixelToWorld(nCam, 0, posx[POINT_PCB_BOTTOM], posy[POINT_PCB_BOTTOM], &posx[POINT_PCB_BOTTOM], &posy[POINT_PCB_BOTTOM]);

			m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance = fabs(posx[POINT_PCB_BOTTOM] - posx[POINT_PANEL]);
			m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance = fabs(posy[POINT_PCB_BOTTOM] - posy[POINT_PANEL]);
			m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 0);
			m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 1);
			m_stInsp_DistanceResult[real_cam][nPos].dDistance = sqrt(pow(m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance, 2) + pow(m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance, 2));
		}
		break;
		case DISTANCE_INSP_METHOD_E_TO_E: // Point(PCB_BOTTOM) To Point(PANEL과 PCB_BOTTOM 교차점) 거리 계산
		{
			double robot_x[3];
			double robot_y[3];

			//POINT_CROSS_1 다시 구하자.
			sPoint point_on_line = { 0, };

			int nMetho = vt_job_info[nJob].algo_method;

			sPoint point = { m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PCB_BOTTOM], m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PCB_BOTTOM] };
			GetMatching(nJob).compute_orthogonal_point_on_line(m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_HORI], point, point_on_line);
			posx[POINT_CROSS_1] = point_on_line.x;
			posy[POINT_CROSS_1] = point_on_line.y;

			m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_CROSS_1] = point_on_line.x;
			m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_CROSS_1] = point_on_line.y;

			GetMatching(nJob).compute_orthogonal_point_on_line(m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_VERT], point, point_on_line);
			posx[POINT_CROSS_2] = point_on_line.x;
			posy[POINT_CROSS_2] = point_on_line.y;

			m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_CROSS_2] = point_on_line.x;
			m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_CROSS_2] = point_on_line.y;

			// 로봇 좌표계로 변환
			GetMachine(nJob).PixelToWorld(nCam, 0, posx[POINT_PCB_BOTTOM], posy[POINT_PCB_BOTTOM], &robot_x[0], &robot_y[0]);
			GetMachine(nJob).PixelToWorld(nCam, 0, posx[POINT_CROSS_1], posy[POINT_CROSS_1], &robot_x[1], &robot_y[1]);	// y계산
			GetMachine(nJob).PixelToWorld(nCam, 0, posx[POINT_CROSS_2], posy[POINT_CROSS_2], &robot_x[2], &robot_y[2]);	// x계산

			double dx_height = robot_x[0] - robot_x[1];
			double dy_height = robot_y[0] - robot_y[1];
			double dx_width = robot_x[0] - robot_x[2];
			double dy_width = robot_y[0] - robot_y[2];

			// Line 교차점과 두번 Point 거리 결과
			double dHeightDistance = sqrt(dx_height * dx_height + dy_height * dy_height);
			double dWidthDistance = sqrt(dx_width * dx_width + dy_width * dy_width);

			m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance = dHeightDistance;
			m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance = dWidthDistance;
			m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 0);
			m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 1);
		}
		break;
		case DISTANCE_INSP_METHOD_L_TO_M:	// Point(PCB_BOTTOM)와 Line(PANEL) 거리 계산
		case DISTANCE_INSP_METHOD_L_TO_E:
		{
			double robot_x[2];
			double robot_y[2];
			sPoint point_on_line = { 0, };

			// PCB Edge 찾은 Point
			sPoint point = { m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PCB_BOTTOM], m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PCB_BOTTOM] };

			if (bLineDir == TRUE)
			{
				// PANEL 수직선과 PCB Point 수선의발 찾기
				GetMatching(nJob).compute_orthogonal_point_on_line(m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_VERT], point, point_on_line);
			}
			else
			{
				// PANEL 수평선과 PCB Point 수선의발 찾기
				GetMatching(nJob).compute_orthogonal_point_on_line(m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_HORI], point, point_on_line);
			}

			// 로봇 좌표계로 변환
			// 두 점간의 길이를 계산하자
			GetMachine(nJob).PixelToWorld(nCam, 0, point.x, point.y, &robot_x[0], &robot_y[0]);
			GetMachine(nJob).PixelToWorld(nCam, 0, point_on_line.x, point_on_line.y, &robot_x[1], &robot_y[1]);

			double dx = robot_x[0] - robot_x[1];
			double dy = robot_y[0] - robot_y[1];

			m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_CROSS_1] = point_on_line.x;
			m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_CROSS_1] = point_on_line.y;

			double dDistance = sqrt(dx * dx + dy * dy);

			if (bLineDir == TRUE) // 방향 Vertical 일때
			{
				//m_stInsp_DistanceResult[real_cam][nPos].dDistance = dDistance;
				m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance = dDistance;
				m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 0);

				m_stInsp_DistanceResult[real_cam][nPos].dDistance = m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance;
			}
			else
			{
				//m_stInsp_DistanceResult[real_cam][nPos].dDistance = dDistance;
				m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance = dDistance;

				m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance += vt_job_info[nJob].model_info.getMachineInfo().get_insp_offset(nCam, nPos, 1);
				m_stInsp_DistanceResult[real_cam][nPos].dDistance = m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance;
			}
		}

		break;
#pragma endregion
		}
		break;
	}
	break;
#pragma endregion

	}

#pragma endregion
	if (m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] == FALSE || m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] == FALSE)
	{
		bInspResult = FALSE;
	}

	strTemp.Format("[%s]Cam %d - %d (%s) algo End ", vt_job_info[nJob].job_name.c_str(), nCam + 1, nPos + 1, bInspResult == TRUE ? "OK" : "NG");
	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

	m_pDlgCaliper->m_pCaliperParam->updateUIFromData();
	m_pDlgCaliper->m_pCaliperParam->updateCoordinates();

	return bInspResult;
}

void CLET_AlignClientDlg::save_result_image_2cam_2shot(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, str;
	CString strTime, str_modelID, str_algo, str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[algo].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";


	double posX = 0.0, posY = 0.0;
	int of = 20;

	//////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID \\ JOB이름 \\ OK/NG \\ PanelID \\ 

	//날짜
	strTime.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	strImageDir.Format("%s%s",m_strImageDir ,strTime);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	
	//모델ID
	str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format(_T("%s"), vt_job_info[algo].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else if (bJudge)
	{
		strImageDir.Format("%s\\OK", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		strImageDir.Format("%s\\NG", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}

	//PanelID
	strImageDir.Format("%s\\%s", strImageDir, vt_job_info[algo].main_object_id.c_str());
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//이미지저장 시간
	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int pos_count = vt_job_info[algo].num_of_position;
	int nCam = 0;
	int real_cam = 0;

	for (nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);

		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		int index = m_nSaveImageRingBufIndex[algo][nCam];
		
		m_stSaveImageInfo[algo][nCam][index].bUsing1Cam = FALSE;
		m_stSaveImageInfo[algo][nCam][index].b4Align = vt_job_info[algo].model_info.getAlignInfo().getUse4PointAlign();
		for (int nPos = 0; nPos < pos_count; nPos++)
		{
			m_stSaveImageInfo[algo][nCam][index].dPosX[0] = GetMatching(algo).getFindInfo(nCam, nPos).GetXPos();
			m_stSaveImageInfo[algo][nCam][index].dPosY[0] = GetMatching(algo).getFindInfo(nCam, nPos).GetYPos();
			m_stSaveImageInfo[algo][nCam][index].nFound[0] = GetMatching(algo).getFindInfo(nCam, nPos).GetFound();
			m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_X] = GetPrealign(algo).getRevisionX();
			m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Y] = GetPrealign(algo).getRevisionY();
			m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_T] = GetPrealign(algo).getRevisionT();
			m_stSaveImageInfo[algo][nCam][index].bJudge = bJudge;
			m_stSaveImageInfo[algo][nCam][index].nRetry = m_nRetryCount[algo] - 1;
			m_stSaveImageInfo[algo][nCam][index].bFinal = bRetryEnd;
			m_stSaveImageInfo[algo][nCam][index].nNumPos = 1;
			m_stSaveImageInfo[algo][nCam][index].nAlgorithm = algo;
			m_stSaveImageInfo[algo][nCam][index].nCam = nCam;

			for (int i = 0; i < 4; i++)
			{
				m_stSaveImageInfo[algo][nCam][index].dLineX[0][i] = GetMatching(algo).getFindInfo(nCam, nPos).GetLineX(i);
				m_stSaveImageInfo[algo][nCam][index].dLineY[0][i] = GetMatching(algo).getFindInfo(nCam, nPos).GetLineY(i);
			}

			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img%d.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName, nPos + 1);
			str.Format("%s\\%s_%s_%s_Img%d.%s",	strImageDir,									// 이미지 저장 디렉토리
													vt_job_info[algo].main_object_id.c_str(),		// 모델이름
													strTime,										// 시간
													m_stCamInfo[real_cam].cName,					// 카메라 이름
													nPos + 1,										// 포지션
													str_ImageType);									// Image Type
			copyMemory(getSaveImageBuffer(real_cam, index), getProcBuffer(real_cam, nPos), W * H);
			sprintf(m_cSaveImageRingBufPath[algo][nCam][index], "%s", (LPCTSTR)str);

			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw%d.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName, nPos + 1);
			str.Format("%s\\%s_%s_%s_ImgRaw%d.%s", strImageDir,									// 이미지 저장 디렉토리
													vt_job_info[algo].main_object_id.c_str(),		// 모델이름
													strTime,										// 시간
													m_stCamInfo[real_cam].cName,					// 카메라 이름
													nPos + 1,										// 포지션
													str_ImageType);									// Image Type
			sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index], "%s", (LPCTSTR)str);

			m_nSaveImageRingBufIndex[algo][nCam]++;
			m_nSaveImageRingBufIndex[algo][nCam] = m_nSaveImageRingBufIndex[algo][nCam] % MAX_SAVE_IMAGE_RING_BUF;
			index = m_nSaveImageRingBufIndex[algo][nCam];
		}
	}
}
void CLET_AlignClientDlg::save_result_image(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	if (vt_job_info[algo].algo_method == CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN)
	{
		save_result_image_2cam_2shot(bJudge, algo, bRetryEnd);
	}
	else if (vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_2POS_REFERENCE ||
			 vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_4POS_ROBOT) // Reel 얼라인 Tkyuha 20211018
	{
		save_result_image_1cam_2object(bJudge, algo, bRetryEnd);
	}
	else if(vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_1SHOT_ALIGN || vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_1SHOT_FILM || vt_job_info[algo].algo_method == CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP)
	{
		if(each_job_method)		g_Job_1Cam1ShotAlign[algo].save_result_image(bJudge, bRetryEnd);
		//else					SaveResultImageINFRA_Align(bJudge, algo, bRetryEnd);
		// 2121-12-27 kbj 1cam 1shot Align 이미지 저장 위치 따로 추가.
		else					save_result_image_1shot_align_infra(bJudge, algo, bRetryEnd);

	}
	else if (vt_job_info[algo].algo_method == CLIENT_TYPE_ELB_CENTER_ALIGN)
	{
		// KBJ 2022-02-23 Divide CenterAlign
		save_result_image_ELB_center_align(bJudge, algo, bRetryEnd);
	}
	else if (vt_job_info[algo].algo_method == CLIENT_TYPE_CENTER_NOZZLE_ALIGN)
	{
		//KJH 2022-05-13 Nozzle XYZ Insp Log 분리
		if (m_nSeqNozzleGrabCount == 100)
		{
			SaveResultImageNozzle_XYZ_Insp(bJudge, algo, bRetryEnd);
		}
		else
		{
			//SaveResultImageINFRA_Align(bJudge, algo, bRetryEnd);
		}
	}
	else
	{
		SaveResultImageINFRA_Align(bJudge, algo, bRetryEnd);
	}
}

BOOL CLET_AlignClientDlg::readAllModelData(int algo, CModel *model, CString model_path)
{
	BOOL bSuccess = TRUE;

	CString strPath;

	if (model_path.GetLength()) strPath = model_path;
	else
	{
		strPath.Format("%s%s\\%s", m_strModelDir, model->getModelID(), vt_job_info[algo].job_name.c_str());
	}

	if (_access(strPath, 0) != 0)	return  FALSE;

	if (readGlassInfoData(&model->getGlassInfo(), strPath) != TRUE)					bSuccess = FALSE;
	if (readAlignInfoData(algo, &model->getAlignInfo(), strPath) != TRUE)			bSuccess = FALSE;
	if (readMachineInfoData(algo, &model->getMachineInfo(), strPath) != TRUE)		bSuccess = FALSE;	
	if (readPanelExistInfoData(&model->getPanelExistInfo(), strPath) != TRUE)		bSuccess = FALSE;
	if (readLightInfoData(algo, &model->getLightInfo(), strPath) != TRUE)			bSuccess = FALSE;
	//KJH 2021-08-07 InspSpecPara Load 추가
	if (readInspSpecPara(algo, &model->getInspSpecParaInfo(), strPath) != TRUE)		bSuccess = FALSE;

#ifndef JOB_INFO
	GetMachine().readCalibInfoData(strPath);
	GetMachine().readRotateCenter(strPath);  //20180426 확인 필요	}
#else
	GetMachine(algo).readCalibInfoData(strPath);
	GetMachine(algo).readRotateCenter(strPath);  //20180426 확인 필요	}
#endif

	//if (m_pDlgCaliper != NULL)
	//{
	//	for (int nObject = 0; nObject < MAX_CALIPER_OBJECT; nObject++)
	//	{
	//		for (int nPos = 0; nPos < NUM_POS; nPos++)
	//		{
	//			for (int nLine = 0; nLine < MAX_CALIPER_LINES; nLine++)
	//			{
	//				m_pDlgCaliper->readCaliperInfo(m_strCurrentModelPath, &m_pDlgCaliper->m_Caliper[nObject][nPos][nLine], nObject, nPos, nLine);
	//				m_pDlgCaliper->m_Caliper[nObject][nPos][nLine].calcCaliperRect();
	//			}
	//		}
	//	}
	//}
	return bSuccess;
}
BOOL CLET_AlignClientDlg::readAllModelData(int algo, CString strPath)
{
	BOOL bSuccess = TRUE;
	if (_access(strPath, 0) != 0) return FALSE;

	if (readGlassInfoData(&vt_job_info[algo].model_info.getGlassInfo(), strPath) != TRUE)				bSuccess = FALSE;
	if (readAlignInfoData(algo, &vt_job_info[algo].model_info.getAlignInfo(), strPath) != TRUE)			bSuccess = FALSE;
	if (readMachineInfoData(algo, &vt_job_info[algo].model_info.getMachineInfo(), strPath) != TRUE)		bSuccess = FALSE;
	if (readPanelExistInfoData(&vt_job_info[algo].model_info.getPanelExistInfo(), strPath) != TRUE)		bSuccess = FALSE;
	if (readLightInfoData(algo, &vt_job_info[algo].model_info.getLightInfo(), strPath) != TRUE)			bSuccess = FALSE;

	GetMachine(algo).readCalibInfoData(strPath);
	GetMachine(algo).readRotateCenter(strPath);  //20180426 확인 필요	}

	INIReader _ini(fmt_("%s/CaliperInfo.ini", m_strCurrentModelPath.GetString())); // Tkyuha 20221227 속도 올리기 위함

	for (int nObject = 0; nObject < MAX_CALIPER_OBJECT; nObject++)
	{
		if (m_stCamInfo[nObject].buse == 0) continue; //Tkyuha 20221125 속도 올리기 위해 사용 하지 않는 카메라는 무시

		for (int nPos = 0; nPos < NUM_POS; nPos++)
		{
			for (int nLine = 0; nLine < MAX_CALIPER_LINES; nLine++)
			{
				m_pDlgCaliper->readCaliperInfo(&_ini, &m_pDlgCaliper->m_Caliper[nObject][nPos][nLine], nObject, nPos, nLine); // Tkyuha 20221227 속도 올리기 위함
				m_pDlgCaliper->m_Caliper[nObject][nPos][nLine].init_caliper_info();

				if (m_pDlgCaliper->m_Caliper[nObject][nPos][nLine].getCircleCaliper())		m_pDlgCaliper->m_Caliper[nObject][nPos][nLine].calcCaliperCircle();
				else																		m_pDlgCaliper->m_Caliper[nObject][nPos][nLine].calcCaliperRect();
			}
		}
	}

	return bSuccess;
}
BOOL CLET_AlignClientDlg::allModelChange(CString strModelName)
{
	BOOL bSuccess = TRUE;

	CModel tempModel;
	memset(&tempModel, 0, sizeof(CModel));

	memcpy(tempModel.getModelID(), strModelName, strModelName.GetLength());

	vector<CModel> temp_model;
	temp_model.assign(vt_job_info.size(), tempModel);

#ifndef JOB_INFO
	bSuccess = readAllModelData(&tempModel);
#else
	for (int nJob = 0; nJob < vt_job_info.size(); nJob++)
	{
		CString strPath;
		strPath.Format("%s%s\\%s", m_strModelDir, strModelName, vt_job_info[nJob].job_name.c_str());
		if (readAllModelData(nJob, &temp_model[nJob], strPath) != TRUE)
		{
			bSuccess = FALSE;
		}
	}
#endif

	if (bSuccess)
	{
		writeLastModel(strModelName);
		setCurrModelName(strModelName);
		setCurrModelPath(strModelName);	//2017.09.23 jsh Mark View 및 ROI 관련 CurrModelPath 경로 사용됨.
		
		CString trace_file, metal_file, mask_range_file;
		for (int nJob = 0; nJob < vt_job_info.size(); nJob++)
		{
			memcpy(&vt_job_info[nJob].model_info, &temp_model[nJob], sizeof(CModel));
			vt_job_info[nJob].model_info.setModelID(strModelName);
			
			if (vt_job_info[nJob].algo_method == CLIENT_TYPE_ELB_CENTER_ALIGN)
			{
				trace_file.Format("%s%s\\%s_%d%s", m_strCurrentModelPath, vt_job_info[nJob].job_name.c_str(), "Trace", 0, "Data.ini");
				metal_file.Format("%s%s\\%s_%d%s", m_strCurrentModelPath, vt_job_info[nJob].job_name.c_str(), "MetalTrace", 0, "Data.ini");
				mask_range_file.Format("%s%s\\%s_%d%s", m_strCurrentModelPath, vt_job_info[nJob].job_name.c_str(), "Trace_AreaMask", 0,
					(vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod() == METHOD_NOTCH) ? "Notch.bin" : "Circle.bin");

				read_trace_data(trace_file);
				read_metal_trace_data(metal_file);
				read_trace_mask_data(mask_range_file);
			}
		}

		setDispModelName(strModelName);
		m_strCurrModelDir.Format("%s%s\\", m_strModelDir, getCurrModelName());		
	}

	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_MODEL_CHANGE, NULL, NULL);
	::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_SET_MODELNAME, (LPARAM)&getCurrModelName());
	::SendMessageA(m_pForm[FORM_MODEL]->m_hWnd, WM_VIEW_CONTROL, MSG_MV_DISP_MODEL_ID, (LPARAM)&getCurrModelName());
	::SendMessageA(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_MV_DISP_MODEL_LIST, NULL);
	//KJH 2022-06-30 Machine창 Origin Box Display 삭제
	//::SendMessageA(m_pForm[FORM_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_TRAGER_VIEW, NULL);

	//현재 모델 PLC R영역에 저장 21.03.10
	SendMessage(WM_VIEW_CONTROL, MSG_MV_SEND_CURR_MODEL, NULL);

	return bSuccess;
}
BOOL CLET_AlignClientDlg::process_model_copy(CString src_model_name, CString dst_model_name)
{
	CString str_temp;
	if (_access(m_strModelDir + dst_model_name, 0) == 0)
	{
		str_temp.Format("%s - Model Already Exist", dst_model_name);
		fnSetMessage(1, str_temp);

		return FALSE;
	}
	else
	{
		CreateDirectory(m_strModelDir + dst_model_name, NULL);
	}

	CSimpleSplashWnd _splash(this, IDB_BMP_LOADING);

	for (int algo = 0; algo < vt_job_info.size(); algo++)
	{
		str_temp.Format("   %s - coping.....", vt_job_info[algo].get_job_name());
		_splash.SetStatusText(str_temp, ((algo + 1) / (double)vt_job_info.size()) * 100.0);

		CString src_model_path;
		CString dst_model_path;

		src_model_path.Format("%s%s\\%s", m_strModelDir, src_model_name, vt_job_info[algo].get_job_name());
		dst_model_path.Format("%s%s\\%s", m_strModelDir, dst_model_name, vt_job_info[algo].get_job_name());

		if (_access(dst_model_path, 0) != 0)	CreateDirectory(dst_model_path, NULL);

		if (_access(src_model_path, 0) != 0)
		{
			str_temp.Format("%s - Model Not Exist", src_model_name);
			fnSetMessage(1, str_temp);
		}
		else
		{
			copyModelFiles(src_model_path, dst_model_path, src_model_name, dst_model_name);
		}
	}

	return TRUE;
}
BOOL CLET_AlignClientDlg::copyModelFiles(CString strSrcDir, CString strDstDir, CString src_model_name, CString dst_model_name)
{
	BOOL bSuccess = FALSE;

	if (_access(strSrcDir, 0) != 0)	return bSuccess;

	::CreateDirectoryA(strDstDir, 0);

	BOOL bFind = FALSE;
	CFileFind findModel;
	CString strTempModel;

	bFind = findModel.FindFile(strSrcDir + _T("\\*.*"));
	CString str;
	while (bFind)
	{
		bFind = findModel.FindNextFile();

		if (findModel.IsDots() || findModel.IsDirectory())	// '.', '..', 디렉토리인 경우 무시
			continue;

		CString strFileName = findModel.GetFileName();
		CString strFilePath;

		// 모든 파일 복사....
		strFilePath = strDstDir + "\\" + strFileName;

		// 모든 파일 복사....
		strFilePath = strDstDir + "\\" + strFileName;
		::CopyFileA(findModel.GetFilePath(), strFilePath, FALSE);

		if (strFileName.GetLength() > 0 && strFileName.Find(src_model_name) != -1)
		{
			CString refile = strFileName;
			refile.Replace(src_model_name, dst_model_name);
			CString strFilePath2 = strDstDir + "\\" + refile;
			::rename(strFilePath, strFilePath2);
		}
		else
		{
			if (::CopyFileA(findModel.GetFilePath(), strFilePath, FALSE) == FALSE)
			{
				str.Format("File Copy Fail: %s", strFilePath);
				::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
				theLog.logmsg(LOG_PROCESS, str);
			}
		}
		Delay(10);
	}

	CString strTempModel2;
	int n = strSrcDir.ReverseFind('\\');
	CString ModelName = strSrcDir.Right(strSrcDir.GetLength() - n - 1);
	strTempModel.Format("%s\\%s.ini", strDstDir, ModelName);

	n = strDstDir.ReverseFind('\\');
	CString ModelNameDst = strDstDir.Right(strDstDir.GetLength() - n - 1);
	strTempModel2.Format("%s\\%s.ini", strDstDir, ModelNameDst);

	::CopyFileA(strTempModel, strTempModel2, FALSE);
	::DeleteFileA(strTempModel);
	
	// 보류
	//for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
	//{
	//	strTempModel.Format("%sCalibData%d.dat", m_strMachineDir, nCam + 1);
	//	if (_access(strTempModel, 0) == 0)
	//	{
	//		ModelNameDst.Format("CalibData%d.dat", nCam + 1);
	//		strTempModel2 = strDstDir + "\\" + ModelNameDst;
	//		::CopyFileA(strTempModel, strTempModel2, FALSE);
	//	}
	//}
	bSuccess = TRUE;
	return bSuccess;
}
BOOL CLET_AlignClientDlg::saveModelData(int algo, CModel model)
{
	BOOL bSuccess = TRUE;

	CString strModel;
	strModel.Format("%s", model.getModelID());	// 신규 모델

	CreateDirectory(m_strModelDir + strModel, 0);

	saveAllModelData(algo, &model);

	return bSuccess;
}
BOOL CLET_AlignClientDlg::saveModelData(int algo, CString strPath)
{
	BOOL bSuccess = TRUE;
	if (_access(strPath, 0) != 0) return FALSE;
#ifndef JOB_INFO
	if (saveGlassInfoData(&getModel().getGlassInfo(), strPath) != TRUE)		bSuccess = FALSE;
	if (saveAlignInfoData(&getModel().getAlignInfo(), strPath) != TRUE)		bSuccess = FALSE;
	if (saveMachineInfoData(algo, &getModel().getMachineInfo(), strPath) != TRUE)		bSuccess = FALSE;	
	if (savePanelExistInfoData(&getModel().getPanelExistInfo(), strPath) != TRUE)		bSuccess = FALSE;	
#else
	if (saveGlassInfoData(&vt_job_info[algo].model_info.getGlassInfo(), strPath) != TRUE)				bSuccess = FALSE;
	if (saveAlignInfoData(algo, &vt_job_info[algo].model_info.getAlignInfo(), strPath) != TRUE)			bSuccess = FALSE;
	if (saveMachineInfoData(algo, &vt_job_info[algo].model_info.getMachineInfo(), strPath) != TRUE)		bSuccess = FALSE;
	if (savePanelExistInfoData(&vt_job_info[algo].model_info.getPanelExistInfo(), strPath) != TRUE)		bSuccess = FALSE;
	if (saveLightInfoData(algo, &vt_job_info[algo].model_info.getLightInfo(), strPath) != TRUE)			bSuccess = FALSE;

	// dh.jung 2021-08-02 add 
	if (saveInspSpecPara(algo, &vt_job_info[algo].model_info.getInspSpecParaInfo(), strPath) != TRUE)	bSuccess = FALSE;
#endif

	return bSuccess;
}
BOOL CLET_AlignClientDlg::saveAllModelData(int algo, CModel *model)
{
	BOOL bSuccess = TRUE;

	CString strPath;
	strPath.Format("%s%s", m_strModelDir, model->getModelID());

	if (_access(strPath, 0) != 0)	CreateDirectory(strPath, 0);

	if (saveGlassInfoData(&model->getGlassInfo(), strPath) != TRUE)				bSuccess = FALSE;
	if (saveAlignInfoData(algo, &model->getAlignInfo(), strPath) != TRUE)		bSuccess = FALSE;
	if (saveMachineInfoData(algo, &model->getMachineInfo(), strPath) != TRUE)	bSuccess = FALSE;	
	if (savePanelExistInfoData(&model->getPanelExistInfo(), strPath) != TRUE)	bSuccess = FALSE;
	if (saveLightInfoData(algo, &model->getLightInfo(), strPath) != TRUE)		bSuccess = FALSE;

	return bSuccess;
}
void CLET_AlignClientDlg::writeLastModel(CString strLastModel)
{
	CString strPath;
	strPath.Format("%sLastModel.ini", m_strModelDir);
	::WritePrivateProfileString("MODEL", "LAST_MODEL", strLastModel, strPath);
	setLastModel(strLastModel);
}
void CLET_AlignClientDlg::readLastModel()
{
	CString strPath;
	TCHAR szValue[MAX_PATH];
	strPath.Format("%sLastModel.ini", m_strModelDir);
	::GetPrivateProfileStringA("MODEL", "LAST_MODEL", "DEFAULT", szValue, MAX_PATH, strPath);
	m_strLastModel.Format("%s", szValue);

}

void CLET_AlignClientDlg::save_result_insp_image(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	if (vt_job_info[algo].algo_method == CLIENT_TYPE_PCB_DISTANCE_INSP)
	{
		save_result_image_pcb_distance_insp(bJudge, algo, bRetryEnd);
	}
	else if (vt_job_info[algo].algo_method == CLIENT_TYPE_SCAN_INSP)
	{
		SaveResultImageScan_Insp(bJudge, algo, bRetryEnd);
	}
	else if (vt_job_info[algo].algo_method == CLIENT_TYPE_FILM_INSP) // 안에 내용물 채워줘야함 Film 검사용임 Tkyuha 20211018
	{
		SaveResultImageFilm_Insp(bJudge, algo, bRetryEnd);
	}
	else if (vt_job_info[algo].algo_method == CLIENT_TYPE_NOZZLE_SIDE_VIEW)
	{
		SaveResultImageNozzleView_Insp(bJudge, algo, bRetryEnd);
	}
	else
	{
		SaveResultImageInspection(bJudge, algo, bRetryEnd);
	}
}
void CLET_AlignClientDlg::save_result_image_pcb_distance_insp(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, str;
	CString strTime, str_modelID, str_algo, str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[algo].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID \\ JOB이름 \\ OK/NG \\ PanelID \\ 

	//날짜
	strTime.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	strImageDir.Format("%s%s", m_strImageDir, strTime);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format(_T("%s"), vt_job_info[algo].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		if (bJudge)
		{
			strImageDir.Format("%s\\OK", strImageDir);
			if (_access(str, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
		else
		{
			strImageDir.Format("%s\\NG", strImageDir);
			if (_access(str, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
	}
	

	//PanelID
	strImageDir.Format("%s\\%s", strImageDir, vt_job_info[algo].main_object_id.c_str());
	if (_access(str, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//이미지저장 시간
	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int pos_count = vt_job_info[algo].num_of_position;
	int nCam = 0;
	int real_cam = 0;

	for (nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);

		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;
		int index = m_nSaveImageRingBufIndex[algo][nCam];

		m_stSaveImageInfo[algo][nCam][index].bUsing1Cam = FALSE;
		m_stSaveImageInfo[algo][nCam][index].b4Align = vt_job_info[algo].model_info.getAlignInfo().getUse4PointAlign();
		
		for (int nPos = 0; nPos < m_nSeqTotalInspGrabCount; nPos++)
		{
			for (int i = 0; i < 2; i++)
			{
				m_stSaveImage_DistanceResult[real_cam][index].bFindPattern[i] = m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[i];
			}

			for (int i = 0; i < 4; i++)
			{
				m_stSaveImage_DistanceResult[real_cam][index].xPos[i] = m_stInsp_DistanceResult[real_cam][nPos].xPos[i];
				m_stSaveImage_DistanceResult[real_cam][index].yPos[i] = m_stInsp_DistanceResult[real_cam][nPos].yPos[i];
				m_stSaveImage_DistanceResult[real_cam][index].line[i] = m_stInsp_DistanceResult[real_cam][nPos].line[i];
				m_stSaveImage_DistanceResult[real_cam][index].bFindLine[i] = m_stInsp_DistanceResult[real_cam][nPos].bFindLine[i];
			}
			m_stSaveImage_DistanceResult[real_cam][index].nAlgorithm = algo;
			m_stSaveImage_DistanceResult[real_cam][index].nInspMethodType = m_stInsp_DistanceResult[real_cam][nPos].nInspMethodType;
			m_stSaveImage_DistanceResult[real_cam][index].bInspMethodDir = m_stInsp_DistanceResult[real_cam][nPos].bInspMethodDir;
			m_stSaveImage_DistanceResult[real_cam][index].bNG = m_stInsp_DistanceResult[real_cam][nPos].bNG;
			m_stSaveImage_DistanceResult[real_cam][index].dDistance = m_stInsp_DistanceResult[real_cam][nPos].dDistance;
			m_stSaveImage_DistanceResult[real_cam][index].dHeightDistance = m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance;
			m_stSaveImage_DistanceResult[real_cam][index].dWidthDistance = m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance;
			m_stSaveImage_DistanceResult[real_cam][index].nCam = nCam;
			m_stSaveImage_DistanceResult[real_cam][index].nPos = nPos;
			m_stSaveImage_DistanceResult[real_cam][index].nRetry = m_nRetryCount[algo] - 1;
			m_stSaveImage_DistanceResult[real_cam][index].bFinal = bRetryEnd;
			m_stSaveImage_DistanceResult[real_cam][index].nIndex = index;


			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img%d.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName, nPos + 1);
			str.Format("%s\\%s_%s_%s_Img%d.%s",	strImageDir,									// 이미지 저장 디렉토리
													vt_job_info[algo].main_object_id.c_str(),		// 모델이름
													strTime,										// 시간
													m_stCamInfo[real_cam].cName,					// 카메라 이름
													nPos + 1,										// 포지션
													str_ImageType);									// Image Type			
			copyMemory(getSaveImageBuffer(real_cam, index), getProcBuffer(real_cam, nPos), W * H);
			sprintf(m_cSaveImageRingBufPath[algo][nCam][index], "%s", (LPCTSTR)str);

			//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw%d.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName, nPos + 1);
			str.Format("%s\\%s_%s_%s_ImgRaw%d.%s", strImageDir,									// 이미지 저장 디렉토리
													vt_job_info[algo].main_object_id.c_str(),		// 모델이름
													strTime,										// 시간
													m_stCamInfo[real_cam].cName,					// 카메라 이름
													nPos + 1,										// 포지션
													str_ImageType);									// Image Type
			sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index], "%s", (LPCTSTR)str);

			m_nSaveImageRingBufIndex[algo][nCam]++;
			m_nSaveImageRingBufIndex[algo][nCam] = m_nSaveImageRingBufIndex[algo][nCam] % MAX_SAVE_IMAGE_RING_BUF;
			index = m_nSaveImageRingBufIndex[algo][nCam];
		}
	}
}
void CLET_AlignClientDlg::SaveResultImageInspection(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, str;;
	CString strTime, str_modelID, str_algo, str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (vt_system_option[algo].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID  \\ JOB이름 \\ OK/NG   \\ PanelID \\ 	변경전
	///  D:\\ Result \\ Image \\ 날짜 \\ JOB이름 \\ OK/NG   \\ PanelID \\ 				변경후

	//날짜
	strTime.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	strImageDir.Format("%s%s", m_strImageDir, strTime);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	////모델ID
	//str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	//strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	//if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format(_T("%s"), vt_job_info[algo].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//OK,NG,Simulation
	if (m_bSimulationStart)
	{
		strImageDir.Format("%s\\Simulation", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else if (bJudge)
	{
		strImageDir.Format("%s\\OK", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		strImageDir.Format("%s\\NG", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}

	//PanelID
	strImageDir.Format("%s\\%s", strImageDir, vt_job_info[algo].main_object_id.c_str());
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//이미지저장 시간
	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int nCam = 0;
	int real_cam = 0;

	for (int k = 0; k < camCount; k++)
	{
		real_cam = camBuf.at(k);
		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		int index = m_nSaveImageRingBufIndex[algo][nCam];
		index = m_nSaveImageRingBufIndex[algo][nCam];
		for (int i = 0; i < 2; i++)
		{
			m_stSaveImage_DistanceResult[real_cam][0].bFindPattern[i] = m_stInsp_DistanceResult[real_cam][0].bFindPattern[i];
		}
		for (int i = 0; i < 4; i++)
		{
			m_stSaveImage_DistanceResult[real_cam][0].xPos[i] = m_stInsp_DistanceResult[real_cam][0].xPos[i];
			m_stSaveImage_DistanceResult[real_cam][0].yPos[i] = m_stInsp_DistanceResult[real_cam][0].yPos[i];
			m_stSaveImage_DistanceResult[real_cam][0].line[i] = m_stInsp_DistanceResult[real_cam][0].line[i];
			m_stSaveImage_DistanceResult[real_cam][0].bFindLine[i] = m_stInsp_DistanceResult[real_cam][0].bFindLine[i];
		}

		m_stSaveImage_DistanceResult[real_cam][0].nInspMethodType = m_stInsp_DistanceResult[real_cam][0].nInspMethodType;
		m_stSaveImage_DistanceResult[real_cam][0].bInspMethodDir = m_stInsp_DistanceResult[real_cam][0].bInspMethodDir;
		m_stSaveImage_DistanceResult[real_cam][0].bNG = m_stInsp_DistanceResult[real_cam][0].bNG;
		m_stSaveImage_DistanceResult[real_cam][0].dDistance = m_stInsp_DistanceResult[real_cam][0].dDistance;
		m_stSaveImage_DistanceResult[real_cam][0].dHeightDistance = m_stInsp_DistanceResult[real_cam][0].dHeightDistance;
		m_stSaveImage_DistanceResult[real_cam][0].dWidthDistance = m_stInsp_DistanceResult[real_cam][0].dWidthDistance;
		m_stSaveImage_DistanceResult[real_cam][0].nCam = m_stInsp_DistanceResult[real_cam][0].nCam;
		m_stSaveImage_DistanceResult[real_cam][0].nPos = m_stInsp_DistanceResult[real_cam][0].nPos;
		m_stSaveImage_DistanceResult[real_cam][0].nRetry = m_nRetryCount[algo] - 1;
		m_stSaveImage_DistanceResult[real_cam][0].bFinal = bRetryEnd;

		//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
		str.Format("%s\\%s_%s_%s_Img%d.%s",	strImageDir,										// 이미지 저장 디렉토리
												vt_job_info[algo].main_object_id.c_str(),		// 모델이름
												strTime,										// 시간
												m_stCamInfo[real_cam].cName,					// 카메라 이름
												m_nSeqCurrentInspGrabCount+1,					// 포지션
												str_ImageType);									// Image Type

		copyMemory(getSaveImageBuffer(real_cam, index), getProcBuffer(real_cam, m_nSeqCurrentInspGrabCount), W * H);
		sprintf(m_cSaveImageRingBufPath[algo][nCam][index], "%s", (LPCTSTR)str);

		//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
		str.Format("%s\\%s_%s_%s_ImgRaw%d.%s",	strImageDir,									// 이미지 저장 디렉토리
												vt_job_info[algo].main_object_id.c_str(),		// 모델이름
												strTime,										// 시간
												m_stCamInfo[real_cam].cName,					// 카메라 이름
												m_nSeqCurrentInspGrabCount + 1,					// 포지션
												str_ImageType);									// Image Type

		sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index], "%s", (LPCTSTR)str);

		m_nSaveImageRingBufIndex[algo][nCam]++;
		m_nSaveImageRingBufIndex[algo][nCam] = m_nSaveImageRingBufIndex[algo][nCam] % MAX_SAVE_IMAGE_RING_BUF;

		//210208
		nCam++;
	}
}
void CLET_AlignClientDlg::saveImageFiles(int nJob, int nCam)
{
	if (m_bSaveReslutImage != TRUE && m_bSaveRawImage != TRUE) return;
	/*if (m_bSimulationStart == TRUE)
	{
		if(m_bSaveReslutImage_simulation[nJob] != TRUE && m_bSaveRawImage_simulation[nJob] != TRUE) return;
	}*/

	int nMethod = vt_job_info[nJob].algo_method;

	switch (nMethod)
	{
		case CLIENT_TYPE_PCB_DISTANCE_INSP:
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];
			int nIndex = m_nSaveImageRingBufIndex_Curr[nJob][nCam];
			/*m_stSaveImage_DistanceResult[real_cam][nIndex].nCam = nCam;
			m_stSaveImage_DistanceResult[real_cam][nIndex].nPos = nIndex;
			m_stSaveImage_DistanceResult[real_cam][nIndex].nIndex = nIndex;
			m_stSaveImage_DistanceResult[real_cam][nIndex].nAlgorithm = nJob;*/
			
			_stSaveImage_DistanceResult *pInfo = &m_stSaveImage_DistanceResult[real_cam][nIndex];
			pInfo->pDlg = this;

			AfxBeginThread(Thread_pcb_Insp_ImageSave, pInfo);
		}
		break;
	case CLIENT_TYPE_ASSEMBLE_INSP:
		{
			int real_cam = vt_job_info[nJob].camera_index[nCam];
			int nIndex = m_nSaveImageRingBufIndex_Curr[nJob][nCam];
			m_stSaveImage_DistanceResult[real_cam][0].nCam = nCam;
			m_stSaveImage_DistanceResult[real_cam][0].nPos = 0;
			m_stSaveImage_DistanceResult[real_cam][0].nIndex = nIndex;
			m_stSaveImage_DistanceResult[real_cam][0].nAlgorithm = nJob;

			_stSaveImage_DistanceResult *pInfo = &m_stSaveImage_DistanceResult[real_cam][m_nSeqCurrentInspGrabCount];
			pInfo->pDlg = this;

			AfxBeginThread(Thread_assemble_Insp_ImageSave, pInfo);
		}
		break;
	case CLIENT_TYPE_SCAN_INSP:
		{
		// dh.jung 2021-05-13 TODO
		m_nSeqScanInspGrabCount[nJob];

		}
		break;
	case CLIENT_TYPE_FILM_INSP:
	{
		int nIndex = m_nSaveImageRingBufIndex_Curr[nJob][nCam];
		m_stSaveImageInfo[nJob][nCam][nIndex].nCam = nCam;
		m_stSaveImageInfo[nJob][nCam][nIndex].nIndex = nIndex;
		_stSaveImageInfo* pInfo = &m_stSaveImageInfo[nJob][nCam][nIndex];
		pInfo->pDlg = this;

		AfxBeginThread(Thread_Film_Insp_ImageSave, pInfo);
	}
	break;
	default:
		{
			int nIndex = m_nSaveImageRingBufIndex_Curr[nJob][nCam];
			m_stSaveImageInfo[nJob][nCam][nIndex].nCam = nCam;
			m_stSaveImageInfo[nJob][nCam][nIndex].nIndex = nIndex;
			_stSaveImageInfo* pInfo = &m_stSaveImageInfo[nJob][nCam][nIndex];
			pInfo->pDlg = this;

			// KBJ 2022-07-19 이미지 저장 캡처로 되는방법 추가
			if(vt_system_option[nJob].use_result_image_capture == TRUE)
			{
				AfxBeginThread(Thread_ImageSave_Capture, pInfo);
			}
			else
			{
				if (vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod() == METHOD_CALIPER)
				{
					AfxBeginThread(Thread_CaliperImageSave2, pInfo);
				}
				else if (vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod() == METHOD_CIRCLE)
				{
					AfxBeginThread(Thread_CircleImageSave, pInfo);
				}
				else
				{
					AfxBeginThread(Thread_ImageSave, pInfo);
				}
			}
		}
		break;
	}
}

UINT Thread_DiffResultWrite(void* pParam)
{
	struct _stFindPattern* pPattern = (struct _stFindPattern*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pPattern->pDlg;

	int nJob = pPattern->nJob;
	BOOL bJudge = pPattern->nSearchCount;
	CString serialNum = pMain->vt_job_info[nJob].main_object_id.c_str();

	int real_cam = pMain->vt_job_info[nJob].camera_index[0];
	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	//KJH 2022-05-04 Wetout 검사 결과 이미지 먼저 만들어 놓고 result 파일 저장
	//KJH 2022-07-15 DiffWetOut OrgImg ProcBuffer 변경
	cv::Mat matGrayImage(H, W, CV_8UC1, pMain->getProcBuffer(real_cam, 3));
	cv::Mat matBeforeImage(H, W, CV_8UC1, pMain->getProcBuffer(real_cam, 2));
	cv::Mat matDiffImage;
	cv::absdiff(matGrayImage, matBeforeImage, matDiffImage);

	pMain->write_result_diff_insp_ELB(serialNum, bJudge, nJob);

	CString strImageDir, str;
	CString strTime, str_modelID, str_algo, str_step, str_ImageType;
	SYSTEMTIME time;
	::GetLocalTime(&time);
	//KMB 220924 SYSTEM OPTION에 따라 저장이미지 확장자 변경
	if (pMain->vt_system_option[nJob].save_image_type == FALSE)
		str_ImageType = "jpg";
	else
		str_ImageType = "bmp";

	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID  \\ JOB이름 \\ Diff_Insp \\ OK/NG \\ PanelID \\

	CString stage = "NULL";
	
	if		(pMain->m_nClientID == 3)	stage = "A1";
	else if (pMain->m_nClientID == 4)	stage = "A2";
	else if (pMain->m_nClientID == 5)	stage = "B1";
	else if (pMain->m_nClientID == 6)	stage = "B2";

	//날짜
	strTime.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	strImageDir.Format("%s%s", pMain->m_strImageDir, strTime);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//모델ID
	str_modelID.Format("%s", pMain->vt_job_info[nJob].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	str_algo.Format(_T("%s"), pMain->vt_job_info[nJob].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//Diff Insp
	str_step.Format(_T("Diff_Insp"));
	strImageDir.Format("%s\\%s", strImageDir, str_step);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	if (bJudge)
	{
		strImageDir.Format("%s\\OK", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}
	else
	{
		strImageDir.Format("%s\\NG", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	}

	//PanelID
	//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
	//if (strlen(pMain->vt_job_info[nJob].main_object_id.c_str()) <= 13)
	//{
	//	strImageDir.Format("%s\\Not Exist Panel ID", strImageDir);
	//	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	//}

	//PanelID
	if (pMain->vt_job_info[nJob].main_object_id.size() <= 0) pMain->vt_job_info[nJob].main_object_id = "TestImg";
	strImageDir.Format("%s\\%s", strImageDir, pMain->vt_job_info[nJob].main_object_id.c_str());
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
	else
	{
		// KBJ 2022-11-30 이미지 폴더 분배
		strImageDir.Format("%s_%s", strImageDir, pMain->m_strResultTime[0]);
		CreateDirectory(strImageDir, NULL);
	}

	//이미지저장 시간
	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);

	pMain->m_strLastInspectionFolder.Format("%s\\%s_INSP_%s_%s_%s", strImageDir, stage,					// 이미지 저장 디렉토리
		pMain->vt_job_info[nJob].main_object_id.c_str(),		// 모델이름
		strTime,												// 시간
		pMain->m_stCamInfo[real_cam].cName,						// 카메라 이름
		str_ImageType);										// 이미지 확장자

	if (pMain->m_bSaveReslutImage == TRUE)
	{
		// kbj 2021-12-31 이미지 저장 압축률 설정.
		vector<int> params_jpg;
		params_jpg.push_back(IMWRITE_JPEG_QUALITY);
		params_jpg.push_back(pMain->vt_system_option[nJob].jpg_compress_rate_Result);

		// 검사 이미지
		str.Format("%s\\%s_INSP_%s_%s_%s_result.%s", strImageDir, stage,									// 이미지 저장 디렉토리
			pMain->vt_job_info[nJob].main_object_id.c_str(),		// 모델이름
			strTime,												// 시간
			pMain->m_stCamInfo[real_cam].cName,						// 카메라 이름
			str_ImageType);										// 이미지 확장자
		cv::imwrite(std::string(str), pMain->m_matResultImage, params_jpg);
	}

	if (pMain->m_bSaveRawImage == TRUE)
	{
		vector<int> params_jpg; // Tkyuha 20211214 영상 압축해서 저장하기
		params_jpg.push_back(IMWRITE_JPEG_QUALITY);

		// kbj 2021-12-31 elb 검사이미지 압축률 ui 인자로 수정.
		//params_jpg.push_back(75); // 압축률 75%
		str.Format("%s\\%s_INSP_%s_%s_%s_ImgRaw.%s", strImageDir, stage,									// 이미지 저장 디렉토리
			pMain->vt_job_info[nJob].main_object_id.c_str(),		// 모델이름
			strTime,												// 시간
			pMain->m_stCamInfo[real_cam].cName,						// 카메라 이름
			str_ImageType);										// 이미지 확장자
		params_jpg.push_back(pMain->vt_system_option[nJob].jpg_compress_rate_Raw);

		cv::imwrite(std::string(str), matGrayImage, params_jpg);

		str.Format("%s\\%s_INSP_%s_%s_%s_ImgRaw2.%s", strImageDir, stage,								// 이미지 저장 디렉토리
			pMain->vt_job_info[nJob].main_object_id.c_str(),	// 모델이름
			strTime,											// 시간
			pMain->m_stCamInfo[real_cam].cName,					// 카메라 이름
			str_ImageType);									// 이미지 확장자						
		cv::imwrite(std::string(str), matBeforeImage, params_jpg);

		str.Format("%s\\%s_INSP_%s_%s_%s_ImgRaw3.%s", strImageDir, stage,								// 이미지 저장 디렉토리
			pMain->vt_job_info[nJob].main_object_id.c_str(),	// 모델이름
			strTime,											// 시간
			pMain->m_stCamInfo[real_cam].cName,					// 카메라 이름
			str_ImageType);									// 이미지 확장자
		cv::imwrite(std::string(str), matDiffImage, params_jpg);

		///////////////
		/// RDP 저장 포멧 추가
		///////////////
		CString strRdp, shape = "Line", strRdpFile, strRdpFile2, timeSecond;
		int method = pMain->vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod();
		if (method == METHOD_CIRCLE) shape = "Hole";
		timeSecond.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);

		strImageDir.Format("%s%s", pMain->m_strImageDir, "Vision_Log");
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		strImageDir.Format("%s\\Image", strImageDir);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		strImageDir.Format("%s\\%s", strImageDir, timeSecond);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		strImageDir.Format("%s\\%s", strImageDir, bJudge ? "OK" : "NG");
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		strImageDir.Format("%s\\%s%s", strImageDir, shape, stage);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		strImageDir.Format("%s\\Original", strImageDir, shape, stage);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

		strRdpFile.Format("%s\\%s_%s_%s_%s%s_Before_%s.%s", strImageDir, timeSecond, strTime, pMain->vt_job_info[nJob].main_object_id.c_str(), shape, stage, bJudge ? "OK" : "NG", str_ImageType);
		cv::imwrite(std::string(strRdpFile), matBeforeImage, params_jpg);
		strRdpFile2.Format("%s\\%s_%s_%s_%s%s_After_%s.%s", strImageDir, timeSecond, strTime, pMain->vt_job_info[nJob].main_object_id.c_str(), shape, stage, bJudge ? "OK" : "NG", str_ImageType);
		cv::imwrite(std::string(strRdpFile2), matGrayImage, params_jpg);

		params_jpg.clear();

		if (pMain->m_strRDP_LogDir == "Z:\\" || pMain->m_strRDP_LogDir == "G:\\")
		{
			strImageDir.Format("%s%s", pMain->m_strHistoryDir, "RDP_Log");
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
		else
		{
			strImageDir.Format("%s", pMain->m_strRDP_LogDir);
		}

		str.Format("%s\\TRACKOUT_%s_%s%02d%02d%02d.Log", strImageDir, pMain->vt_job_info[nJob].main_object_id.c_str(), timeSecond, time.wHour, time.wMinute, time.wSecond);
		
		CStdioFile WriteFile;
		if (WriteFile.Open(str, CFile::modeNoTruncate | CFile::modeCreate	| CFile::modeWrite | CFile::shareDenyNone | CFile::typeText))
		{
			WriteFile.SeekToEnd();
			str_step.Format("CELL_ID = %s\n", pMain->vt_job_info[nJob].main_object_id.c_str());
			WriteFile.WriteString(str_step);
			str_step.Format("INNER_ID = %s%02d%02d%02d\n", timeSecond, time.wHour, time.wMinute, time.wSecond);
			WriteFile.WriteString(str_step);
			//KJH 2022-04-29 RDP 담당자 요청으로 디스크 경로 삭제
			strRdpFile.Delete(0, 3); // D:\\ //
			strRdpFile2.Delete(0, 3); // D:\\ //
			str_step.Format("IMG_PATH1 = \\\\192.168.0.%3d\\%s\n", 120 + (pMain->m_nClientID-3)*10, strRdpFile);
			WriteFile.WriteString(str_step);
			str_step.Format("IMG_PATH2 = \\\\192.168.0.%3d\\%s\n", 120 + (pMain->m_nClientID-3)*10, strRdpFile2);
			WriteFile.WriteString(str_step);
			WriteFile.Close();
		}
	}

	//matGrayImage.release();
	matDiffImage.release();

	// 이전 이미지 업로드랑은 큰 연관은 없어 보이는데 지역변수라 release 시키는게 맞는거 같습니다? -KBJ 
	matGrayImage.release();
	matBeforeImage.release();

	str.Format("[%s] Cam : %d INSP - Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(),  1);
	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}
UINT Thread_Film_Insp_ImageSave(void* pParam)
{
	_stSaveImageInfo* pInfo = (_stSaveImageInfo*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pInfo->pDlg;

	int nCam = pInfo->nCam;
	int bJudge = pInfo->bJudge;
	int algo = pInfo->nAlgorithm;

	std::vector<int> camBuf = pMain->vt_job_info[algo].camera_index;
	int real_cam = camBuf.at(0);

	//20211018 Tkyuha Trace 이미지 오늘 날짜에 저장
	//////////////////////////////////////////////
	CString imgMsg, strImgDir;
	SYSTEMTIME time;
	GetLocalTime(&time);

	CFormMainView* pFormMain = (CFormMainView*)pMain->m_pForm[FORM_MAIN];
	int nview = pMain->vt_job_info[algo].viewer_index[nCam];

	if (_access(pMain->m_strImageDir, 0) != 0)	CreateDirectory(pMain->m_strImageDir, NULL);
	if (pMain->m_strResultDate[0] == "")	pMain->m_strResultDate[algo].Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	if (pMain->vt_job_info[algo].main_object_id.size() <= 0) pMain->vt_job_info[algo].main_object_id = "TestImg";

	CString serialNum = pMain->vt_job_info[algo].main_object_id.c_str();

	//pMain->write_result_Film_insp(serialNum, bJudge, algo);
	//HSJ 2021-01-01 이미지저장
	// KBJ 2022-07-18 필름검사 저장 뷰어 캡처로 수정
	if(pMain->vt_system_option[algo].use_result_image_capture == FALSE) pMain->display_PF_Film_insp_save(pMain->getProcBuffer(real_cam, 1), algo, nCam, &pFormMain->m_pDlgViewerMain[nview]->GetViewer(), pInfo);
	else																pMain->display_PF_Film_insp_save_capture(pMain->getProcBuffer(real_cam, 1), algo, nCam, &pFormMain->m_pDlgViewerMain[nview]->GetViewer(), pInfo);
		
	// kbj 2022-01-05 Move to film inspection of write_result 
	//pMain->write_result_Film_insp_new(serialNum, bJudge, algo);
	
	return 0;
}
UINT Thread_NozzleView_Insp_ImageSave(void* pParam)
{
	_stSaveImageInfo* pInfo = (_stSaveImageInfo*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pInfo->pDlg;

	int nCam = pInfo->nCam;
	int bJudge = pInfo->bJudge;
	int algo = pInfo->nAlgorithm;

	std::vector<int> camBuf = pMain->vt_job_info[algo].camera_index;
	int real_cam = camBuf.at(0);

	//20211018 Tkyuha Trace 이미지 오늘 날짜에 저장
	//////////////////////////////////////////////
	CString imgMsg, strImgDir, str_Imae;
	SYSTEMTIME time;
	GetLocalTime(&time);

	CFormMainView* pFormMain = (CFormMainView*)pMain->m_pForm[FORM_MAIN];
	int nview = pMain->vt_job_info[algo].viewer_index[nCam];

	if (_access(pMain->m_strImageDir, 0) != 0)	CreateDirectory(pMain->m_strImageDir, NULL);
	if (pMain->m_strResultDate[0] == "")	pMain->m_strResultDate[algo].Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	if (pMain->vt_job_info[algo].main_object_id.size() <= 0) pMain->vt_job_info[algo].main_object_id = "TestImg";

	CString serialNum = pMain->vt_job_info[algo].main_object_id.c_str();

	pMain->write_result_NozzleView_insp(serialNum, bJudge, algo);

	strImgDir = pMain->m_strImageDir + pMain->m_strResultDate[algo];
	if (_access(strImgDir, 0) != 0)		CreateDirectory(strImgDir, NULL);

	strImgDir.Format("%s\\NOZZLE_VIEW", strImgDir);
	if (_access(strImgDir, 0) != 0)	CreateDirectory(strImgDir, NULL);

	if (bJudge)
	{
		strImgDir.Format("%s\\OK", strImgDir);
		if (_access(strImgDir, 0) != 0)	CreateDirectory(strImgDir, NULL);
	}
	else
	{
		strImgDir.Format("%s\\NG", strImgDir);
		if (_access(strImgDir, 0) != 0)	CreateDirectory(strImgDir, NULL);
	}

	imgMsg.Format("%s\\NozzleView_%s_%02d%02d%02d.jpg", strImgDir, pMain->vt_job_info[algo].main_object_id.c_str(), time.wHour, time.wMinute, time.wSecond);
	pFormMain->m_pDlgViewerMain[nview]->GetViewer().Screenshot(imgMsg);

	return 0;
}
UINT Thread_ScanImageSave(void* pParam)
{
	_stSaveImageInfo* pInfo = (_stSaveImageInfo*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pInfo->pDlg;

	int nCam = pInfo->nCam;
	int bJudge = pInfo->bJudge;
	int nIndex = pInfo->nIndex;
	int nJob = pInfo->nAlgorithm;
	int nNumPos = pInfo->nNumPos;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	if (pMain->m_pSaperaCam[real_cam].IsOpend())
	{
		//KJH	2021-07-29	이미지 저장 - 1st Grab
		CString str;
		
		cv::Mat matGrayImage_Raw(H * _SCAN_GRAB_MAXCOUNT, W, CV_8UC1, pMain->m_pSaperaCam[real_cam].GetFullImage()->data);
		
		if (pMain->m_bSaveRawImage == TRUE) cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage_Raw);
		
//		cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], pMain->m_matScanResultImage[nCam][nIndex]);
		cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], pMain->m_matScanResultImage[real_cam][nIndex]);			// dh.jung 2021-08-31 검사 결과 오버레이 이미지 scan1,2 같은 이미지 저장 수정
		matGrayImage_Raw.release();

		str.Format("[%s] Scan Cam : %d - 1st Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), real_cam + 1);
		::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
	}
	
	return 0;
}
UINT Thread_ScanOneImageSave(void* pParam)
{
	_stSaveImageInfo* pInfo = (_stSaveImageInfo*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pInfo->pDlg;

	int nCam = pInfo->nCam;
	int bJudge = pInfo->bJudge;
	int nIndex = pInfo->nIndex;
	int nJob = pInfo->nAlgorithm;
	int nNumPos = pInfo->nNumPos;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	if (pMain->m_pSaperaCam[real_cam].IsOpend())
	{
		//KJH	2021-07-29	이미지 저장 - 2nd , 3rd Grab
		CString str;
		cv::Mat matGrayImage_Raw(H , W, CV_8UC1, pMain->getProcBuffer(real_cam, 0));
		if (pMain->m_bSaveRawImage == TRUE) cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage_Raw);
//		cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], pMain->m_matScanResultImage[nCam][nIndex]);
		cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], pMain->m_matScanResultImage[real_cam][nIndex]);			// dh.jung 2021-08-31 검사 결과 오버레이 이미지 scan1,2 같은 이미지 저장 수정

		matGrayImage_Raw.release();

		if (nIndex == 2)
		{
			str.Format("[%s] Scan Cam : %d - 2nd Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1);
		}
		else if (nIndex == 3)
		{
			str.Format("[%s] Scan Cam : %d - 3rd Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1);
		}
		else
		{
			str.Format("[%s] Cam : %d - %d Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
		}
		::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
	}


	return 0;
}
UINT Thread_ImageSave(void* pParam)
{
	_stSaveImageInfo* pInfo = (_stSaveImageInfo*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pInfo->pDlg;
	CFormMainView* pFormMain = (CFormMainView*)pMain->m_pForm[FORM_MAIN];

	int nCam = pInfo->nCam;
	int bJudge = pInfo->bJudge;
	int nIndex = pInfo->nIndex;
	int nJob = pInfo->nAlgorithm;
	int nNumPos = pInfo->nNumPos;
	BOOL b4Align = pInfo->b4Align;
	BOOL bUsing1Cam = pInfo->bUsing1Cam;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	// kbj 2021-12-27 조건문에 each_job_method 추가
	if (pMain->vt_job_info[nJob].algo_method == CLIENT_TYPE_1CAM_1SHOT_ALIGN || pMain->vt_job_info[nJob].algo_method == CLIENT_TYPE_1CAM_1SHOT_FILM || pMain->vt_job_info[nJob].algo_method == CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP && pMain->each_job_method)
	{
		g_Job_1Cam1ShotAlign[pInfo->nAlgorithm].save_image(pInfo);
		return 0;
	}

	CString str;
	cv::Mat matGrayImage(H, W, CV_8UC1, pMain->getSaveImageBuffer(real_cam, nIndex));
	cv::Mat matColorImage;
	cv::cvtColor(matGrayImage, matColorImage, CV_GRAY2BGR);

	cv::Scalar color;
	cv::Scalar colorOK = cv::Scalar(0, 255, 0);
	cv::Scalar colorNG = cv::Scalar(0, 0, 255);
	cv::Scalar colorBLUE = cv::Scalar(255, 64, 64);
	cv::Scalar colorMatch = cv::Scalar(255, 0, 255);
	int nOffset = 20;
	double dbFontSize = 4.0;

	int nWidth = W;
	int nHeight = H;
	BOOL bMarkUse = pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();

	if (bJudge)		color = colorOK;
	else			color = colorNG;

	// OK
	if (bJudge)
	{
		// draw mark
		for (int nPos = 0; nPos < nNumPos; nPos++)
		{
			line(matColorImage, cv::Point((int)pInfo->dPosX[nPos] - nOffset, (int)pInfo->dPosY[nPos]), cv::Point((int)pInfo->dPosX[nPos] + nOffset, (int)pInfo->dPosY[nPos]), color, 2);
			line(matColorImage, cv::Point((int)pInfo->dPosX[nPos], (int)pInfo->dPosY[nPos] - nOffset), cv::Point((int)pInfo->dPosX[nPos], (int)pInfo->dPosY[nPos] + nOffset), color, 2);
		}

		// draw text
		if (pMain->vt_job_info[nJob].algo_method == CLIENT_TYPE_CENTER_NOZZLE_ALIGN)
		{
			str.Format("X : %.4f Y : %.4f Z : %.4f T : %.4f", pInfo->dRevision[AXIS_X], pInfo->dRevision[AXIS_Y], pInfo->dRevision[AXIS_Z], pInfo->dRevision[AXIS_T]);
		}
		//KJH 2022-07-01 1Cam 2Pos 2Object 관련 이미지로그 Text변경
		else if (pMain->vt_job_info[nJob].algo_method == CLIENT_TYPE_1CAM_2POS_REFERENCE ||
				 pMain->vt_job_info[nJob].algo_method == CLIENT_TYPE_1CAM_4POS_ROBOT)
		{
			str.Format("X1 : %.4f Y1 : %.4f T1 : %.4f", pInfo->dRevision_object[AXIS_X][0], pInfo->dRevision_object[AXIS_Y][0], pInfo->dRevision_object[AXIS_T][0]);
		}
		else
		{
			str.Format("X : %.4f Y : %.4f T : %.4f", pInfo->dRevision[AXIS_X], pInfo->dRevision[AXIS_Y], pInfo->dRevision[AXIS_T]);
		}
		putText(matColorImage, std::string(str), cv::Point(5, H / 4), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 4);

		//KJH 2022-07-01 1Cam 2Pos 2Object 관련 이미지로그 Text변경
		if (pMain->vt_job_info[nJob].algo_method == CLIENT_TYPE_1CAM_2POS_REFERENCE ||
			pMain->vt_job_info[nJob].algo_method == CLIENT_TYPE_1CAM_4POS_ROBOT)
		{
			str.Format("X2 : %.4f Y2 : %.4f T2 : %.4f", pInfo->dRevision_object[AXIS_X][1], pInfo->dRevision_object[AXIS_Y][1], pInfo->dRevision_object[AXIS_T][1]);
			putText(matColorImage, std::string(str), cv::Point(5, 3 *(H / 4)), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 4);
		}

		if (pInfo->bFinal)	str = "Final";
		else				str.Format("Retry : %d", pInfo->nRetry);
		putText(matColorImage, std::string(str), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);
	}
	// NG
	else			
	{
		// draw mark
		for (int nPos = 0; nPos < nNumPos; nPos++)
		{
			if (pInfo->nFound[nPos] == FIND_OK)			color = colorOK;
			else if (pInfo->nFound[nPos] == FIND_MATCH) color = colorMatch;
			else									    continue;

			line(matColorImage, cv::Point((int)pInfo->dFindX[nPos] - nOffset, (int)pInfo->dFindY[nPos]), cv::Point((int)pInfo->dFindX[nPos] + nOffset, (int)pInfo->dFindY[nPos]), color, 2);
			line(matColorImage, cv::Point((int)pInfo->dFindX[nPos], (int)pInfo->dFindY[nPos] - nOffset), cv::Point((int)pInfo->dFindX[nPos], (int)pInfo->dFindY[nPos] + nOffset), color, 2);
		}

		// draw text
		str = "NG";
		putText(matColorImage, std::string(str), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);

		if (pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseIncludedAngle() && pInfo->bAngleNG)
		{
			str = "ANGLE NG";
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);

			str.Format("A : %.3f", pInfo->dbIncludedAngle);
			putText(matColorImage, std::string(str), cv::Point(W - 700, 150), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
		}
		else if (pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseIncludedAngle() && pInfo->bLcheckNG)
		{
			str = "L-CHECK NG";
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);

			str.Format("L : %.3f", pInfo->dbLcheckLength);
			putText(matColorImage, std::string(str), cv::Point(W - 700, 250), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
		}
		else if (pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseDummyCornerInsp() && pInfo->bDummyDirNG)
		{
			str = "DUMMY DIR NG";
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
		}
		else if (pInfo->nFound[0] == FIND_OK && pInfo->nFound[1] == FIND_OK)
		{
			str = "calc Revision Failed";
			putText(matColorImage, std::string(str), cv::Point(W / 2, H / 2), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
		}
		else
		{
			str = "NG";
			putText(matColorImage, std::string(str), cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);
		}
	}

	//KJH 2022-05-14 김경철 수석님 요청 사항으로 Nozzle Align Log 미 저장, XYZ 검사만 저장하는걸로
	if (pMain->vt_job_info[nJob].algo_method != CLIENT_TYPE_CENTER_NOZZLE_ALIGN || pMain->m_nSeqNozzleGrabCount == 100)
	{
		// kbj 2022-01-05 SaveImage systemOption
		if (pMain->vt_system_option[nJob].jpg_compress_rate_Result < 90 && pMain->vt_system_option[nJob].jpg_compress_rate_Raw < 90) // 영상 압축해서 저장
		{
			vector<int> params_jpg;
			params_jpg.push_back(IMWRITE_JPEG_QUALITY);

			if(pMain->vt_system_option[nJob].result_image_save == TRUE)
				params_jpg.push_back(pMain->vt_system_option[nJob].jpg_compress_rate_Result);
			else
				params_jpg.push_back(pMain->vt_system_option[nJob].jpg_compress_rate_Raw);

			// result image save on/off
			if (pMain->vt_system_option[nJob].result_image_save == TRUE)
			{
				if (bJudge == TRUE && pMain->vt_system_option[nJob].ok_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage, params_jpg);
				if (bJudge == FALSE && pMain->vt_system_option[nJob].ng_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage, params_jpg);
			}
			// Raw image save on/off
			if (pMain->vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage, params_jpg);
		}
		else // 영상 압축 x
		{
			// result image save on/off
			if (pMain->vt_system_option[nJob].result_image_save == TRUE)
			{
				if (bJudge == TRUE && pMain->vt_system_option[nJob].ok_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);
				if (bJudge == FALSE && pMain->vt_system_option[nJob].ng_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);
			}

			// Raw image save on/off
			if (pMain->vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage);
		}
	}

	matColorImage.release();
	matGrayImage.release(); // kbj 2021-01-05 Add grayimage Release()

	str.Format("[%s] Cam : %d - %d Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}

UINT Thread_ImageSave_Capture(void* pParam)
{
	_stSaveImageInfo* pInfo = (_stSaveImageInfo*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pInfo->pDlg;
	CFormMainView* pFormMain = (CFormMainView*)pMain->m_pForm[FORM_MAIN];

	int nCam = pInfo->nCam;
	int bJudge = pInfo->bJudge;
	int nIndex = pInfo->nIndex;
	int nJob = pInfo->nAlgorithm;
	int nNumPos = pInfo->nNumPos;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	int nView = pMain->vt_job_info[nJob].viewer_index[nCam];

	cv::Mat matGrayImage(H, W, CV_8UC1, pMain->getSaveImageBuffer(real_cam, nIndex));

	//KJH 2022-05-14 김경철 수석님 요청 사항으로 Nozzle Align Log 미 저장, XYZ 검사만 저장하는걸로
	if (pMain->vt_job_info[nJob].algo_method != CLIENT_TYPE_CENTER_NOZZLE_ALIGN || pMain->m_nSeqNozzleGrabCount == 100)
	{
		// kbj 2022-01-05 SaveImage systemOption
		if (pMain->vt_system_option[nJob].jpg_compress_rate_Result < 90 && pMain->vt_system_option[nJob].jpg_compress_rate_Raw < 90) // 영상 압축해서 저장
		{
			vector<int> params_jpg;
			params_jpg.push_back(IMWRITE_JPEG_QUALITY);

			if (pMain->vt_system_option[nJob].result_image_save == TRUE)
				params_jpg.push_back(pMain->vt_system_option[nJob].jpg_compress_rate_Result);
			else
				params_jpg.push_back(pMain->vt_system_option[nJob].jpg_compress_rate_Raw);

			// result image save on/off
			if (pMain->vt_system_option[nJob].result_image_save == TRUE)
			{
				if (bJudge == TRUE && pMain->vt_system_option[nJob].ok_image_save == TRUE)	pFormMain->m_pDlgViewerMain[nView]->GetViewer().saveScreenCapture(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex]);
				if (bJudge == FALSE && pMain->vt_system_option[nJob].ng_image_save == TRUE)	pFormMain->m_pDlgViewerMain[nView]->GetViewer().saveScreenCapture(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex]);
			}
			// Raw image save on/off
			if (pMain->vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage, params_jpg);
		}
		else // 영상 압축 x
		{
			// result image save on/off
			if (pMain->vt_system_option[nJob].result_image_save == TRUE)
			{
				if (bJudge == TRUE && pMain->vt_system_option[nJob].ok_image_save == TRUE)	pFormMain->m_pDlgViewerMain[nView]->GetViewer().saveScreenCapture(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex]);
				if (bJudge == FALSE && pMain->vt_system_option[nJob].ng_image_save == TRUE)	pFormMain->m_pDlgViewerMain[nView]->GetViewer().saveScreenCapture(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex]);
			}

			// Raw image save on/off
			if (pMain->vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage);
		}
	}
	matGrayImage.release(); // kbj 2021-01-05 Add grayimage Release()

	CString str;
	str.Format("[%s] Cam : %d - %d Image Capture Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}

UINT Thread_CaliperImageSave2(void *pParam)
{
	_stSaveImageInfo *pInfo = (_stSaveImageInfo *)pParam;
	CLET_AlignClientDlg *pMain = (CLET_AlignClientDlg *)pInfo->pDlg;

	int nCam = pInfo->nCam;
	int bJudge = pInfo->bJudge;
	int nIndex = pInfo->nIndex;
	int nJob = pInfo->nAlgorithm;
	int nNumPos = pInfo->nNumPos;
	BOOL b4Align = pInfo->b4Align;
	BOOL bUsing1Cam = pInfo->bUsing1Cam;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	CString str;
	cv::Mat matGrayImage(H, W, CV_8UC1, pMain->getSaveImageBuffer(real_cam, nIndex));
	cv::Mat matColorImage;
	cv::cvtColor(matGrayImage, matColorImage, CV_GRAY2BGR);

	cv::Scalar color;
	cv::Scalar colorOK = cv::Scalar(0, 255, 0);
	cv::Scalar colorNG = cv::Scalar(0, 0, 255);
	cv::Scalar colorMatch = cv::Scalar(255, 0, 255);
	cv::Scalar colorReference = cv::Scalar(255, 0, 0);
	int nOffset = 20;
	double dbFontSize = 4.0;

	sLine line_info[8];
	BOOL bFindLine[8];
	int nWidth = W;
	int nHeight = H;
	BOOL bFixtureUse = pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();

	//캘리퍼 정보
	int nPos = 0;
	CPoint ptStart, ptEnd;

	if (bJudge) color = colorOK;
	else		color = colorNG;

	// draw caliper 
	// if judge is ng but draw line.
	if (1)
	{
		switch (nNumPos){
		case 2:
		{
			line_info[0] = pInfo->line[0];
			line_info[1] = pInfo->line[1];
			line_info[2] = pInfo->line[2];
			line_info[3] = pInfo->line[3];

			bFindLine[0] = pInfo->bFindline[0];
			bFindLine[1] = pInfo->bFindline[1];
			bFindLine[2] = pInfo->bFindline[2];
			bFindLine[3] = pInfo->bFindline[3];

			if (bFindLine[0])	pMain->draw_line(matColorImage, color, line_info[0], W, H, 5);
			if (bFindLine[1])	pMain->draw_line(matColorImage, color, line_info[1], W, H, 5);
			if (bFindLine[2])	pMain->draw_line(matColorImage, color, line_info[2], W, H, 5);
			if (bFindLine[3])	pMain->draw_line(matColorImage, color, line_info[3], W, H, 5);

			pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos][0].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos][1].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos + 1][0].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos + 1][1].draw_final_result(matColorImage);
		}
		break;
		case 4:
		{
			line_info[0] = pInfo->line[0];
			line_info[1] = pInfo->line[1];
			line_info[2] = pInfo->line[2];
			line_info[3] = pInfo->line[3];
			line_info[4] = pInfo->line[4];
			line_info[5] = pInfo->line[5];
			line_info[6] = pInfo->line[6];
			line_info[7] = pInfo->line[7];

			bFindLine[0] = pInfo->bFindline[0];
			bFindLine[1] = pInfo->bFindline[1];
			bFindLine[2] = pInfo->bFindline[2];
			bFindLine[3] = pInfo->bFindline[3];
			bFindLine[4] = pInfo->bFindline[4];
			bFindLine[5] = pInfo->bFindline[5];
			bFindLine[6] = pInfo->bFindline[6];
			bFindLine[7] = pInfo->bFindline[7];

			if (bFindLine[0])	pMain->draw_line(matColorImage, color, line_info[0], W, H, 5);
			if (bFindLine[1])	pMain->draw_line(matColorImage, color, line_info[1], W, H, 5);
			if (bFindLine[2])	pMain->draw_line(matColorImage, color, line_info[2], W, H, 5);
			if (bFindLine[3])	pMain->draw_line(matColorImage, color, line_info[3], W, H, 5);
			if (bFindLine[4])	pMain->draw_line(matColorImage, color, line_info[4], W, H, 5);
			if (bFindLine[5])	pMain->draw_line(matColorImage, color, line_info[5], W, H, 5);
			if (bFindLine[6])	pMain->draw_line(matColorImage, color, line_info[6], W, H, 5);
			if (bFindLine[7])	pMain->draw_line(matColorImage, color, line_info[7], W, H, 5);

			pMain->m_pDlgCaliper->m_Caliper[real_cam][0][0].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][0][1].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][1][0].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][1][1].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][2][0].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][2][1].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][3][0].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][3][1].draw_final_result(matColorImage);
		}
		break;
		default:
		{
			line_info[0] = pInfo->line[0];
			line_info[1] = pInfo->line[1];

			bFindLine[1] = pInfo->bFindline[1];

			if (bFindLine[0])	pMain->draw_line(matColorImage, color, line_info[0], W, H, 5);
			if (bFindLine[1])	pMain->draw_line(matColorImage, color, line_info[1], W, H, 5);

			pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos][0].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos][1].draw_final_result(matColorImage);
		}
		break;
		}

		if (bJudge == TRUE)
		{
			str.Format("X : %.4f Y : %.4f T : %.4f", pInfo->dRevision[AXIS_X], pInfo->dRevision[AXIS_Y], pInfo->dRevision[AXIS_T]);
			putText(matColorImage, std::string(str), cv::Point(5, H / 2), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);

			if (pInfo->bFinal)	str = "Final";
			else				str.Format("Retry : %d", pInfo->nRetry);
			putText(matColorImage, std::string(str), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);
		}
	}

	if(bJudge == FALSE)
	{
		str = "NG";
		putText(matColorImage, std::string(str), cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);

		if (pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseIncludedAngle() && pInfo->bAngleNG)
		{
			str = "ANGLE NG";
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);

			str.Format("A : %.3f", pInfo->dbIncludedAngle);
			putText(matColorImage, std::string(str), cv::Point(W - 700, 150), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
		}
		else if (pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseIncludedAngle() && pInfo->bLcheckNG)
		{
			str = "L-CHECK NG";
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);

			str.Format("L : %.3f", pInfo->dbLcheckLength);
			putText(matColorImage, std::string(str), cv::Point(W - 700, 250), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
		}
		else if (pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseDummyCornerInsp() && pInfo->bDummyDirNG)
		{
			str = "DUMMY DIR NG";
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
		}
		else if (pInfo->nFound[0] == FIND_OK && pInfo->nFound[1] == FIND_OK)
		{
			str = "calc Revision Failed";
			putText(matColorImage, std::string(str), cv::Point(W / 2, H / 2), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
		}
		else
		{
			str = "NG";
			putText(matColorImage, std::string(str), cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);
		}
	}

	// reference 마크 표시
	for (int nPos = 0; nPos < nNumPos; nPos++)
	{   line(matColorImage, cv::Point((int)pInfo->dRef_PosX[nPos] - nOffset, (int)pInfo->dRef_PosY[nPos]), cv::Point((int)pInfo->dRef_PosX[nPos] + nOffset, (int)pInfo->dRef_PosY[nPos]), colorReference, 2);
		line(matColorImage, cv::Point((int)pInfo->dRef_PosX[nPos], (int)pInfo->dRef_PosY[nPos] - nOffset), cv::Point((int)pInfo->dRef_PosX[nPos], (int)pInfo->dRef_PosY[nPos] + nOffset), colorReference, 2); }

	// kbj 2022-01-05 SaveImage systemOption
	if (pMain->vt_system_option[nJob].jpg_compress_rate_Result < 90 && pMain->vt_system_option[nJob].jpg_compress_rate_Raw < 90) // 영상 압축해서 저장
	{
		vector<int> params_jpg;
		params_jpg.push_back(IMWRITE_JPEG_QUALITY);

		if (pMain->vt_system_option[nJob].result_image_save == TRUE)
			params_jpg.push_back(pMain->vt_system_option[nJob].jpg_compress_rate_Result);
		else
			params_jpg.push_back(pMain->vt_system_option[nJob].jpg_compress_rate_Raw);

		// result image save on/off
		if (pMain->vt_system_option[nJob].result_image_save == TRUE)
		{
			if (bJudge == TRUE && pMain->vt_system_option[nJob].ok_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage, params_jpg);
			if (bJudge == FALSE && pMain->vt_system_option[nJob].ng_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage, params_jpg);
		}
		// Raw image save on/off
		if (pMain->vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage, params_jpg);
	}
	else // 영상 압축 x
	{
		// result image save on/off
		if (pMain->vt_system_option[nJob].result_image_save == TRUE)
		{
			if (bJudge == TRUE && pMain->vt_system_option[nJob].ok_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);
			if (bJudge == FALSE && pMain->vt_system_option[nJob].ng_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);
		}

		// Raw image save on/off
		if (pMain->vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage);
	}

	matColorImage.release();
	matGrayImage.release(); // kbj 2021-01-05 Add grayimage Release()

	str.Format("[%s] Cam : %d - %d Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}
UINT Thread_CaliperImageSave(void *pParam)
{
	_stSaveImageInfo *pInfo = (_stSaveImageInfo *)pParam;
	CLET_AlignClientDlg *pMain = (CLET_AlignClientDlg *)pInfo->pDlg;

	int nCam = pInfo->nCam;
	int bJudge = pInfo->bJudge;
	int nIndex = pInfo->nIndex;
	int nJob = pInfo->nAlgorithm;
	int nNumPos = pInfo->nNumPos;
	BOOL b4Align = pInfo->b4Align;
	BOOL bUsing1Cam = pInfo->bUsing1Cam;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	CString str;
	cv::Mat matGrayImage(H, W, CV_8UC1, pMain->getSaveImageBuffer(real_cam, nIndex));
	cv::Mat matColorImage;
	cv::cvtColor(matGrayImage, matColorImage, CV_GRAY2BGR);

	cv::Scalar color;
	cv::Scalar colorOK = cv::Scalar(0, 255, 0);
	cv::Scalar colorNG = cv::Scalar(0, 0, 255);
	cv::Scalar colorMatch = cv::Scalar(255, 0, 255);
	int nOffset = 20;
	double dbFontSize = 4.0;

	sLine line_info[4];
	BOOL bFindLine[4];
	int nWidth = W;
	int nHeight = H;
	BOOL bMarkUse = pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseReferenceMark();

	//캘리퍼 정보
	int nPos = 0;

	CPoint ptStart, ptEnd;

	line_info[0] = pInfo->line[0];
	line_info[1] = pInfo->line[1];
	bFindLine[0] = pInfo->bFindline[0];
	bFindLine[1] = pInfo->bFindline[1];
	
	//마크 표시
	if (bMarkUse)
	{
		line(matColorImage, cv::Point((int)pInfo->dPosX[0] - nOffset, (int)pInfo->dPosY[0]), cv::Point((int)pInfo->dPosX[0] + nOffset, (int)pInfo->dPosY[0]), color, 2);
		line(matColorImage, cv::Point((int)pInfo->dPosX[0], (int)pInfo->dPosY[0] - nOffset), cv::Point((int)pInfo->dPosX[0], (int)pInfo->dPosY[0] + nOffset), color, 2);
	}
	
	color = colorOK;
	if (bJudge)		// OK
	{
		//KJH 2021-08-14 Caliper 4개로 Display 이미지 저장용
		if (nNumPos == 2)
		{
			line_info[2] = pInfo->line[2];
			line_info[3] = pInfo->line[3];
			bFindLine[2] = pInfo->bFindline[2];
			bFindLine[3] = pInfo->bFindline[3];

			if (bFindLine[2])	// 수직
			{
				pMain->draw_line(matColorImage,
					color,
					line_info[2],
					W,
					H,
					5);
			}

			if (bFindLine[3])	// 수평
			{
				pMain->draw_line(matColorImage,
					color,
					line_info[3],
					W,
					H,
					5);
			}
			
			pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos + 1][0].draw_final_result(matColorImage);
			pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos + 1][1].draw_final_result(matColorImage);

		}

		if (bFindLine[0])	// 수직
		{
			pMain->draw_line(	matColorImage,
								color,
								line_info[0],
								W,
								H,
								5);
		}

		if (bFindLine[1])	// 수평
		{
			pMain->draw_line(	matColorImage,
								color,
								line_info[1],
								W,
								H,
								5);
		}

		pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos][0].draw_final_result(matColorImage);
		pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos][1].draw_final_result(matColorImage);

		str.Format("X : %.4f Y : %.4f T : %.4f", pInfo->dRevision[AXIS_X], pInfo->dRevision[AXIS_Y], pInfo->dRevision[AXIS_T]);
		//putText(matColorImage, std::string(str), cv::Point(W / 2, H / 2), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);
		putText(matColorImage, std::string(str), cv::Point(5, H / 2), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);

		if (pInfo->bFinal)	str = "Final";
		else				str.Format("Retry : %d", pInfo->nRetry);
		putText(matColorImage, std::string(str), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);
		//putText(matColorImage, std::string(str), cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 2., color, 2);
	}
	else // NG
	{
		if (bFindLine[0])	// 수직
		{
			pMain->draw_line(	matColorImage,
								color,
								line_info[0],
								W,
								H,
								5);
		}

		if (bFindLine[1])	// 수평
		{
			pMain->draw_line(	matColorImage,
								color,
								line_info[1],
								W,
								H,
								5);
		}
		pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos][0].draw_final_result(matColorImage);
		pMain->m_pDlgCaliper->m_Caliper[real_cam][nPos][1].draw_final_result(matColorImage);

		color = colorNG;

		str = "NG";
		putText(matColorImage, std::string(str), cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);
		//putText(matColorImage, std::string(str), cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 2., color, 2);

		if (pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseIncludedAngle() && pInfo->bAngleNG)
		{
			str = "ANGLE NG";
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
			//putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, 2., colorNG, 2);

			str.Format("A : %.3f", pInfo->dbIncludedAngle);
			putText(matColorImage, std::string(str), cv::Point(W - 700, 150), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
			//putText(matColorImage, std::string(str), cv::Point(W - 700, 150), cv::FONT_HERSHEY_SIMPLEX, 2., colorNG, 2);
		}
		else if (pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseIncludedAngle() && pInfo->bLcheckNG)
		{
			str = "L-CHECK NG";
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
			//putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, 2., colorNG, 2);

			str.Format("L : %.3f", pInfo->dbLcheckLength);
			putText(matColorImage, std::string(str), cv::Point(W - 700, 250), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
			//putText(matColorImage, std::string(str), cv::Point(W - 700, 250), cv::FONT_HERSHEY_SIMPLEX, 2., colorNG, 2);
		}
		else if (pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseDummyCornerInsp() && pInfo->bDummyDirNG)
		{
			str = "DUMMY DIR NG";
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
			//putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, 2., colorNG, 2);
		}
		else if (pInfo->nFound[0] == FIND_OK && pInfo->nFound[1] == FIND_OK)
		{
			str = "calc Revision Failed";
			putText(matColorImage, std::string(str), cv::Point(W / 2, H / 2), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
			//putText(matColorImage, std::string(str), cv::Point(W / 2, H / 2), cv::FONT_HERSHEY_SIMPLEX, 1., colorOK, 2);
		}
		else
		{
			str = "NG";
			putText(matColorImage, std::string(str), cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);
			//putText(matColorImage, std::string(str), cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, 2., color, 2);
		}
	}

	if (pMain->m_bSaveReslutImage == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);

	if (pMain->m_bSaveRawImage == TRUE) cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage);
	matColorImage.release();
	matGrayImage.release(); // kbj 2021-01-05 Add grayimage Release()

	str.Format("[%s] Cam : %d - %d Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}
UINT Thread_InspImageSave(void *pParam)
{
	_stSaveImage_DistanceResult *pInfo = (_stSaveImage_DistanceResult *)pParam;
	CLET_AlignClientDlg *pMain = (CLET_AlignClientDlg *)pInfo->pDlg;

	int nCam = pInfo->nCam;
	BOOL bNG = pInfo->bNG;
	int nIndex = pInfo->nIndex;
	int nJob = pInfo->nAlgorithm;
	int nPos = pInfo->nPos;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];
	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	CString str;
	cv::Mat matGrayImage(H, W, CV_8UC1, pMain->getSaveImageBuffer(real_cam, nIndex));
	cv::Mat matColorImage;
	cv::cvtColor(matGrayImage, matColorImage, CV_GRAY2BGR);

	cv::Scalar color;
	cv::Scalar colorOK = cv::Scalar(0, 255, 0);
	cv::Scalar colorNG = cv::Scalar(0, 0, 255);
	cv::Scalar colorLine = cv::Scalar(255, 0, 0);		//파란색
	cv::Scalar colorCross = cv::Scalar(0, 125, 255);	//주황색

	int nPenThickness = 5;
	int nPenLength = 20;
	int nFontScale = 3;

	int nMethod, nMethodDir = 0;
	nMethod = pInfo->nInspMethodType;
	nMethodDir = pInfo->nInspMethodType;

	int nJobMethod = pMain->vt_job_info[nJob].algo_method;

	////////////////////////////////////////////////////////////////////////
	////////////////////////Draw Distance Inspection//////////////////////////////
	int nFind = 0;
	CString strText;

	color = colorOK; 

	/////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////첫번째 위치 그리기
	switch (nMethod)
	{
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark
	case DISTANCE_INSP_METHOD_M_TO_E: // Mark
	{
		// Draw Mark
		if (pInfo->bFindPattern[FIND_PANEL])
		{
			pMain->draw_mark(	matColorImage,
								color,
								pInfo->xPos[POINT_PANEL],
								pInfo->yPos[POINT_PANEL],
								nPenLength,
								nPenThickness);
		}
		else strText.Format("Fail to find Panel Mark");
	}
	break;
	case DISTANCE_INSP_METHOD_L_TO_M: // Line
	case DISTANCE_INSP_METHOD_L_TO_E: // Line
	{
		color = colorLine;
		// Position 1 Edge 
		if (pInfo->bFindPattern[FIND_PANEL])
		{
			CPoint ptStart, ptEnd;

			if (nMethodDir ==TRUE)	//방향이 vertical 일때
			{
				// Line Veritical
				pMain->draw_line(	matColorImage,
									colorLine,
									pInfo->line[FIND_CALIPER_PANEL_VERT],
									W,
									H,
									nPenThickness);
			}
			else //방향이 Horizontal 일때
			{
				// Line Horizontal
				pMain->draw_line(	matColorImage,
									colorLine,
									pInfo->line[FIND_CALIPER_PANEL_HORI],
									W,
									H,
									nPenThickness);
			}
		}
		else strText.Format("Fail to find Panel Line");
		color = colorOK;
	}
	break;
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge
	{
		if (pInfo->bFindPattern[FIND_PANEL])
		{
			// Line Veritical
			pMain->draw_line(	matColorImage,
								color,
								pInfo->line[FIND_CALIPER_PANEL_VERT],
								W,
								H,
								nPenThickness);

			// Line Horizontal
			pMain->draw_line(	matColorImage,
								color,
								pInfo->line[FIND_CALIPER_PANEL_HORI],
								W,
								H,
								nPenThickness);
		}
		else strText.Format("Fail to find Panel Edge");
	}
	break;
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////두번째 위치 그리기
	switch (nMethod)
	{
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark
	case DISTANCE_INSP_METHOD_L_TO_M: // Mark
	{
		// Draw Mark
		if (pInfo->bFindPattern[POINT_PCB_BOTTOM])
		{
			pMain->draw_mark(	matColorImage,
								color,
								pInfo->xPos[POINT_PCB_BOTTOM],
								pInfo->yPos[POINT_PCB_BOTTOM],
								nPenLength,
								nPenThickness);
		}
		else
		{
			switch (nJobMethod)
			{
			case CLIENT_TYPE_PCB_DISTANCE_INSP: strText.Format("Fail to find PCB Edge");	break;
			case CLIENT_TYPE_ASSEMBLE_INSP:		strText.Format("Fail to find BOTTOM Edge");	break;
			}
		}
	}
	break;
	case DISTANCE_INSP_METHOD_M_TO_E: // Edge
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge
	case DISTANCE_INSP_METHOD_L_TO_E: // Edge
	{
		if (pInfo->bFindPattern[POINT_PCB_BOTTOM])
		{
			// Line Veritical
			pMain->draw_line(	matColorImage,
								color,
								pInfo->line[FIND_CALIPER_PCB_VERT],
								W,
								H,
								nPenThickness);
			// Line Horizontal
			pMain->draw_line(	matColorImage,
								color,
								pInfo->line[FIND_CALIPER_PCB_HORI],
								W,
								H,
								nPenThickness);
		}
		else
		{
			switch (nJobMethod)
			{
			case CLIENT_TYPE_PCB_DISTANCE_INSP: strText.Format("Fail to find PCB Edge");	break;
			case CLIENT_TYPE_ASSEMBLE_INSP:		strText.Format("Fail to find BOTTOM Edge");	break;
			}
		}
	}
	break;
	}

	color = colorCross;
	//교차점 그리기
	switch (nMethod)
	{
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge 교차점
	{
		if (pInfo->bFindPattern[FIND_PCB_BOTTOM])
		{
			pMain->draw_mark(matColorImage,
				colorCross,
				pInfo->xPos[POINT_CROSS_1],
				pInfo->yPos[POINT_CROSS_1],
				nPenLength,
				nPenThickness);

			pMain->draw_mark(matColorImage,
				colorCross,
				pInfo->xPos[POINT_CROSS_2],
				pInfo->yPos[POINT_CROSS_2],
				nPenLength,
				nPenThickness);
		}
	}
	break;
	case DISTANCE_INSP_METHOD_L_TO_E: // Line 교차점
	{
		if(pInfo->bFindLine[FIND_CALIPER_PANEL_VERT] && pInfo->bFindPattern[FIND_PCB_BOTTOM])
		{
		pMain->draw_mark(	matColorImage,
							colorCross,
							pInfo->xPos[POINT_CROSS_1],
							pInfo->yPos[POINT_CROSS_1],
							nPenLength,
							nPenThickness);
		}
		if (pInfo->bFindLine[FIND_CALIPER_PANEL_HORI] && pInfo->bFindPattern[FIND_PCB_BOTTOM])
		{
		pMain->draw_mark(	matColorImage,
							colorCross,
							pInfo->xPos[POINT_CROSS_1],
							pInfo->yPos[POINT_CROSS_1],
							nPenLength,
							nPenThickness);
		}
	}
	break;
	}

	if (pMain->vt_job_info[nJob].model_info.getGlassInfo().getModelPanelType() == _CORE_MODEL_CALC)
	{
		pMain->draw_mark(matColorImage,
						colorOK,
						pInfo->xPos[POINT_CROSS_1],
						pInfo->yPos[POINT_CROSS_1],
						nPenLength,
						nPenThickness);

		pMain->draw_mark(matColorImage,
						colorLine,
						pInfo->xPos[POINT_PROTRUDING],
						pInfo->yPos[POINT_PROTRUDING],
						nPenLength,
						nPenThickness);
	}

	// Distance 검사 포인트 추출
	int nWidthPoint = 0, nHeightPoint = 0;
	switch (nCam)
	{
	case 0:	nWidthPoint = 5; nHeightPoint = 6; break;
	case 1:	nWidthPoint = 0; nHeightPoint = 7; break;
	case 2:	nWidthPoint = 4; nHeightPoint = 3; break;
	case 3:	nWidthPoint = 1; nHeightPoint = 2; break;
	}
	double Spec_distance_LSL_W = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(nWidthPoint);
	double Spec_distance_USL_W = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(nWidthPoint);
	double Spec_distance_LSL_H = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(nHeightPoint);
	double Spec_distance_USL_H = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(nHeightPoint);

	// Tilt 검사 포인트 추출
	int nTilt_Point_W = 0, nTilt_Point_H = 0;
	switch (nCam)
	{
	case 0:	nTilt_Point_W = 3; nTilt_Point_H = 2; break;
	case 1:	nTilt_Point_W = 3; nTilt_Point_H = 0; break;
	case 2:	nTilt_Point_W = 1; nTilt_Point_H = 2; break;
	case 3:	nTilt_Point_W = 1; nTilt_Point_H = 0; break;
	}
	double Spec_Tilt_W = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(nTilt_Point_W);
	double Spec_Tilt_H = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(nTilt_Point_H);
	double Spec_Tilt_Tolerance = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(0);

	int offset = 100;
	cv::Scalar colorDrarLime = cv::Scalar(64, 128, 64);
	
	if (pMain->m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] &&
		pMain->m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM])
	{
		switch (nMethod)
		{
		case DISTANCE_INSP_METHOD_M_TO_M:
		case DISTANCE_INSP_METHOD_M_TO_E:
		case DISTANCE_INSP_METHOD_E_TO_E:
		{
			if (pMain->m_dDistanceInspJudgeResult[nWidthPoint])		color = colorDrarLime;
			else													color = colorNG;
			strText.Format("X(P%d) = %.3f( %.3f ~ %.3f )",	nWidthPoint + 1,
															pMain->m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance,
															Spec_distance_LSL_W,
															Spec_distance_USL_W);
			putText(matColorImage, std::string(strText), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);

			if (pMain->m_dDistanceInspJudgeResult[nHeightPoint])	color = colorDrarLime;
			else													color = colorNG;
			strText.Format("Y(P%d) = %.3f( %.3f ~ %.3f )",	nHeightPoint + 1,
															pMain->m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance,
															Spec_distance_LSL_H,
															Spec_distance_USL_H);
			putText(matColorImage, std::string(strText), cv::Point(50, 100 + offset), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);

			if (pMain->m_dDistanceInspSubJudgeResult[nTilt_Point_W])	color = colorDrarLime;
			else														color = colorNG;
			strText.Format("X(Tilt%d) = %.3f( %d ~ %.3f )", nTilt_Point_W + 1,
															pMain->m_dDistanceInspSubDataResult[nTilt_Point_W],
															0,
															Spec_Tilt_W + Spec_Tilt_Tolerance);
			putText(matColorImage, std::string(strText), cv::Point(50, 100 + (offset*2)), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);

			if (pMain->m_dDistanceInspSubJudgeResult[nTilt_Point_H])	color = colorDrarLime;
			else														color = colorNG;
			strText.Format("Y(Tilt%d) = %.3f( %d ~ %.3f )", nTilt_Point_H + 1,
															pMain->m_dDistanceInspSubDataResult[nTilt_Point_H],
															0,
															Spec_Tilt_H + Spec_Tilt_Tolerance);
			putText(matColorImage, std::string(strText), cv::Point(50, 100 + (offset*3)), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);
		}
		break;
		case DISTANCE_INSP_METHOD_L_TO_M:
		case DISTANCE_INSP_METHOD_L_TO_E:
		{
			strText.Format("Distance=%.3f", pInfo->dDistance);
			putText(matColorImage, std::string(strText), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);
		}
		break;
		}
	}
	else	putText(matColorImage, std::string(strText), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);

	if (pMain->m_bSaveReslutImage == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);

	if (pMain->m_bSaveRawImage == TRUE )	cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage);

	matColorImage.release();

	str.Format("[%s] Cam : %d - %d Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}
UINT Thread_assemble_Insp_ImageSave(void *pParam)
{
	_stSaveImage_DistanceResult *pInfo = (_stSaveImage_DistanceResult *)pParam;
	CLET_AlignClientDlg *pMain = (CLET_AlignClientDlg *)pInfo->pDlg;

	int nCam = pInfo->nCam;
	BOOL bNG = pInfo->bNG;
	int nIndex = pInfo->nIndex;
	int nJob = pInfo->nAlgorithm;
	int nPos = pInfo->nPos;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];
	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	CString str;
	cv::Mat matGrayImage(H, W, CV_8UC1, pMain->getSaveImageBuffer(real_cam, nIndex));
	cv::Mat matColorImage;
	cv::cvtColor(matGrayImage, matColorImage, CV_GRAY2BGR);

	cv::Scalar color;
	cv::Scalar colorOK = cv::Scalar(0, 255, 0);
	cv::Scalar colorNG = cv::Scalar(0, 0, 255);
	cv::Scalar colorLine = cv::Scalar(255, 0, 0);		//파란색
	cv::Scalar colorCross = cv::Scalar(0, 125, 255);	//주황색

	int nPenThickness = 5;
	int nPenLength = 20;
	int nFontScale = 3;

	int nMethod, nMethodDir = 0;
	nMethod = pInfo->nInspMethodType;
	nMethodDir = pInfo->nInspMethodType;

	int nJobMethod = pMain->vt_job_info[nJob].algo_method;

	////////////////////////////////////////////////////////////////////////
	////////////////////////Draw Distance Inspection//////////////////////////////
	int nFind = 0;
	CString strText;

	color = colorOK;

	/////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////첫번째 위치 그리기
	switch (nMethod)
	{
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark
	case DISTANCE_INSP_METHOD_M_TO_E: // Mark
	{
		// Draw Mark
		if (pInfo->bFindPattern[FIND_PANEL])
		{
			pMain->draw_mark(matColorImage,
				color,
				pInfo->xPos[POINT_PANEL],
				pInfo->yPos[POINT_PANEL],
				nPenLength,
				nPenThickness);
		}
		else strText.Format("Fail to find Panel Mark");
	}
	break;
	case DISTANCE_INSP_METHOD_L_TO_M: // Line
	case DISTANCE_INSP_METHOD_L_TO_E: // Line
	{
		color = colorLine;
		// Position 1 Edge 
		if (pInfo->bFindPattern[FIND_PANEL])
		{
			CPoint ptStart, ptEnd;

			if (nMethodDir == TRUE)	//방향이 vertical 일때
			{
				// Line Veritical
				pMain->draw_line(matColorImage,
					colorLine,
					pInfo->line[FIND_CALIPER_PANEL_VERT],
					W,
					H,
					nPenThickness);
			}
			else //방향이 Horizontal 일때
			{
				// Line Horizontal
				pMain->draw_line(matColorImage,
					colorLine,
					pInfo->line[FIND_CALIPER_PANEL_HORI],
					W,
					H,
					nPenThickness);
			}
		}
		else strText.Format("Fail to find Panel Line");
		color = colorOK;
	}
	break;
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge
	{
		if (pInfo->bFindPattern[FIND_PANEL])
		{
			// Line Veritical
			pMain->draw_line(matColorImage,
				color,
				pInfo->line[FIND_CALIPER_PANEL_VERT],
				W,
				H,
				nPenThickness);

			// Line Horizontal
			pMain->draw_line(matColorImage,
				color,
				pInfo->line[FIND_CALIPER_PANEL_HORI],
				W,
				H,
				nPenThickness);
		}
		else strText.Format("Fail to find Panel Edge");
	}
	break;
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////두번째 위치 그리기
	switch (nMethod)
	{
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark
	case DISTANCE_INSP_METHOD_L_TO_M: // Mark
	{
		// Draw Mark
		if (pInfo->bFindPattern[POINT_PCB_BOTTOM])
		{
			pMain->draw_mark(matColorImage,
				color,
				pInfo->xPos[POINT_PCB_BOTTOM],
				pInfo->yPos[POINT_PCB_BOTTOM],
				nPenLength,
				nPenThickness);
		}
		else
		{
			switch (nJobMethod)
			{
			case CLIENT_TYPE_PCB_DISTANCE_INSP: strText.Format("Fail to find PCB Edge");	break;
			case CLIENT_TYPE_ASSEMBLE_INSP:		strText.Format("Fail to find BOTTOM Edge");	break;
			}
		}
	}
	break;
	case DISTANCE_INSP_METHOD_M_TO_E: // Edge
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge
	case DISTANCE_INSP_METHOD_L_TO_E: // Edge
	{
		if (pInfo->bFindPattern[POINT_PCB_BOTTOM])
		{
			// Line Veritical
			pMain->draw_line(matColorImage,
				color,
				pInfo->line[FIND_CALIPER_PCB_VERT],
				W,
				H,
				nPenThickness);
			// Line Horizontal
			pMain->draw_line(matColorImage,
				color,
				pInfo->line[FIND_CALIPER_PCB_HORI],
				W,
				H,
				nPenThickness);
		}
		else
		{
			switch (nJobMethod)
			{
			case CLIENT_TYPE_PCB_DISTANCE_INSP: strText.Format("Fail to find PCB Edge");	break;
			case CLIENT_TYPE_ASSEMBLE_INSP:		strText.Format("Fail to find BOTTOM Edge");	break;
			}
		}
	}
	break;
	}

	color = colorCross;
	//교차점 그리기
	switch (nMethod)
	{
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge 교차점
	{
		if (pInfo->bFindPattern[FIND_PCB_BOTTOM])
		{
			pMain->draw_mark(matColorImage,
				colorCross,
				pInfo->xPos[POINT_CROSS_1],
				pInfo->yPos[POINT_CROSS_1],
				nPenLength,
				nPenThickness);

			pMain->draw_mark(matColorImage,
				colorCross,
				pInfo->xPos[POINT_CROSS_2],
				pInfo->yPos[POINT_CROSS_2],
				nPenLength,
				nPenThickness);
		}
	}
	break;
	case DISTANCE_INSP_METHOD_L_TO_E: // Line 교차점
	{
		if (pInfo->bFindLine[FIND_CALIPER_PANEL_VERT] && pInfo->bFindPattern[FIND_PCB_BOTTOM])
		{
			pMain->draw_mark(matColorImage,
				colorCross,
				pInfo->xPos[POINT_CROSS_1],
				pInfo->yPos[POINT_CROSS_1],
				nPenLength,
				nPenThickness);
		}
		if (pInfo->bFindLine[FIND_CALIPER_PANEL_HORI] && pInfo->bFindPattern[FIND_PCB_BOTTOM])
		{
			pMain->draw_mark(matColorImage,
				colorCross,
				pInfo->xPos[POINT_CROSS_1],
				pInfo->yPos[POINT_CROSS_1],
				nPenLength,
				nPenThickness);
		}
	}
	break;
	}

	if (pMain->vt_job_info[nJob].model_info.getGlassInfo().getModelPanelType() == _CORE_MODEL_CALC)
	{
		pMain->draw_mark(matColorImage,
			colorOK,
			pInfo->xPos[POINT_CROSS_1],
			pInfo->yPos[POINT_CROSS_1],
			nPenLength,
			nPenThickness);

		pMain->draw_mark(matColorImage,
			colorLine,
			pInfo->xPos[POINT_PROTRUDING],
			pInfo->yPos[POINT_PROTRUDING],
			nPenLength,
			nPenThickness);
	}

	// Distance 검사 포인트 추출
	int nWidthPoint = 0, nHeightPoint = 0;
	switch (nCam)
	{
	case 0:	nWidthPoint = 5; nHeightPoint = 6; break;
	case 1:	nWidthPoint = 0; nHeightPoint = 7; break;
	case 2:	nWidthPoint = 4; nHeightPoint = 3; break;
	case 3:	nWidthPoint = 1; nHeightPoint = 2; break;
	}
	double Spec_distance_LSL_W = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(nWidthPoint);
	double Spec_distance_USL_W = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(nWidthPoint);
	double Spec_distance_LSL_H = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(nHeightPoint);
	double Spec_distance_USL_H = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(nHeightPoint);

	// Tilt 검사 포인트 추출
	int nTilt_Point_W = 0, nTilt_Point_H = 0;
	switch (nCam)
	{
	case 0:	nTilt_Point_W = 3; nTilt_Point_H = 2; break;
	case 1:	nTilt_Point_W = 3; nTilt_Point_H = 0; break;
	case 2:	nTilt_Point_W = 1; nTilt_Point_H = 2; break;
	case 3:	nTilt_Point_W = 1; nTilt_Point_H = 0; break;
	}
	double Spec_Tilt_W = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(nTilt_Point_W);
	double Spec_Tilt_H = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(nTilt_Point_H);
	double Spec_Tilt_Tolerance = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(0);

	int offset = 100;
	cv::Scalar colorDrarLime = cv::Scalar(64, 128, 64);

	if (pMain->m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] &&
		pMain->m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM])
	{
		switch (nMethod)
		{
		case DISTANCE_INSP_METHOD_M_TO_M:
		case DISTANCE_INSP_METHOD_M_TO_E:
		case DISTANCE_INSP_METHOD_E_TO_E:
		{
			if (pMain->m_dDistanceInspJudgeResult[nWidthPoint])		color = colorDrarLime;
			else													color = colorNG;
			strText.Format("X(P%d) = %.3f( %.3f ~ %.3f )", nWidthPoint + 1,
				pMain->m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance,
				Spec_distance_LSL_W,
				Spec_distance_USL_W);
			putText(matColorImage, std::string(strText), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);

			if (pMain->m_dDistanceInspJudgeResult[nHeightPoint])	color = colorDrarLime;
			else													color = colorNG;
			strText.Format("Y(P%d) = %.3f( %.3f ~ %.3f )", nHeightPoint + 1,
				pMain->m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance,
				Spec_distance_LSL_H,
				Spec_distance_USL_H);
			putText(matColorImage, std::string(strText), cv::Point(50, 100 + offset), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);

			if (pMain->m_dDistanceInspSubJudgeResult[nTilt_Point_W])	color = colorDrarLime;
			else														color = colorNG;
			strText.Format("X(Tilt%d) = %.3f( %d ~ %.3f )", nTilt_Point_W + 1,
				pMain->m_dDistanceInspSubDataResult[nTilt_Point_W],
				0,
				Spec_Tilt_W + Spec_Tilt_Tolerance);
			putText(matColorImage, std::string(strText), cv::Point(50, 100 + (offset * 2)), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);

			if (pMain->m_dDistanceInspSubJudgeResult[nTilt_Point_H])	color = colorDrarLime;
			else														color = colorNG;
			strText.Format("Y(Tilt%d) = %.3f( %d ~ %.3f )", nTilt_Point_H + 1,
				pMain->m_dDistanceInspSubDataResult[nTilt_Point_H],
				0,
				Spec_Tilt_H + Spec_Tilt_Tolerance);
			putText(matColorImage, std::string(strText), cv::Point(50, 100 + (offset * 3)), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);
		}
		break;
		case DISTANCE_INSP_METHOD_L_TO_M:
		case DISTANCE_INSP_METHOD_L_TO_E:
		{
			strText.Format("Distance=%.3f", pInfo->dDistance);
			putText(matColorImage, std::string(strText), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);
		}
		break;
		}
	}
	else	putText(matColorImage, std::string(strText), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);

	if (pMain->m_bSaveReslutImage == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);

	if (pMain->m_bSaveRawImage == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage);

	matColorImage.release();

	str.Format("[%s] Cam : %d - %d Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}
UINT Thread_pcb_Insp_ImageSave(void *pParam)
{
	_stSaveImage_DistanceResult *pInfo = (_stSaveImage_DistanceResult *)pParam;
	CLET_AlignClientDlg *pMain = (CLET_AlignClientDlg *)pInfo->pDlg;

	int nCam = pInfo->nCam;
	BOOL bNG = pInfo->bNG;
	int nIndex = pInfo->nIndex;
	int nJob = pInfo->nAlgorithm;
	int nPos = pInfo->nPos;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];
	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	CString str;
	cv::Mat matGrayImage(H, W, CV_8UC1, pMain->getSaveImageBuffer(real_cam, nIndex));
	cv::Mat matColorImage;
	cv::cvtColor(matGrayImage, matColorImage, CV_GRAY2BGR);

	cv::Scalar color;
	cv::Scalar colorOK = cv::Scalar(0, 255, 0);
	cv::Scalar colorNG = cv::Scalar(0, 0, 255);
	cv::Scalar colorLine = cv::Scalar(255, 0, 0);		//파란색
	cv::Scalar colorCross = cv::Scalar(0, 125, 255);	//주황색

	int nPenThickness = 5;
	int nPenLength = 20;
	int nFontScale = 3;

	int nMethod, nMethodDir = 0;
	nMethod = pInfo->nInspMethodType;
	nMethodDir = pInfo->nInspMethodType;

	int nJobMethod = pMain->vt_job_info[nJob].algo_method;

	////////////////////////////////////////////////////////////////////////
	////////////////////////Draw Distance Inspection//////////////////////////////
	int nFind = 0;
	CString strText;

	color = colorOK;

	/////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////첫번째 위치 그리기
	switch (nMethod)
	{
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark
	case DISTANCE_INSP_METHOD_M_TO_E: // Mark
	{
		// Draw Mark
		if (pInfo->bFindPattern[FIND_PANEL])
		{
			pMain->draw_mark(matColorImage,
				color,
				pInfo->xPos[POINT_PANEL],
				pInfo->yPos[POINT_PANEL],
				nPenLength,
				nPenThickness);
		}
		else strText.Format("Fail to find Panel Mark");
	}
	break;
	case DISTANCE_INSP_METHOD_L_TO_M: // Line
	case DISTANCE_INSP_METHOD_L_TO_E: // Line
	{
		color = colorLine;
		// Position 1 Edge 
		if (pInfo->bFindPattern[FIND_PANEL])
		{
			CPoint ptStart, ptEnd;

			if (nMethodDir == TRUE)	//방향이 vertical 일때
			{
				// Line Veritical
				pMain->draw_line(matColorImage,
					colorLine,
					pInfo->line[FIND_CALIPER_PANEL_VERT],
					W,
					H,
					nPenThickness);
			}
			else //방향이 Horizontal 일때
			{
				// Line Horizontal
				pMain->draw_line(matColorImage,
					colorLine,
					pInfo->line[FIND_CALIPER_PANEL_HORI],
					W,
					H,
					nPenThickness);
			}
		}
		else strText.Format("Fail to find Panel Line");
		color = colorOK;
	}
	break;
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge
	{
		if (pInfo->bFindPattern[FIND_PANEL])
		{
			// Line Veritical
			pMain->draw_line(matColorImage,
				color,
				pInfo->line[FIND_CALIPER_PANEL_VERT],
				W,
				H,
				nPenThickness);

			// Line Horizontal
			pMain->draw_line(matColorImage,
				color,
				pInfo->line[FIND_CALIPER_PANEL_HORI],
				W,
				H,
				nPenThickness);
		}
		else strText.Format("Fail to find Panel Edge");
	}
	break;
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////두번째 위치 그리기
	switch (nMethod)
	{
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark
	case DISTANCE_INSP_METHOD_L_TO_M: // Mark
	{
		// Draw Mark
		if (pInfo->bFindPattern[POINT_PCB_BOTTOM])
		{
			pMain->draw_mark(matColorImage,
				color,
				pInfo->xPos[POINT_PCB_BOTTOM],
				pInfo->yPos[POINT_PCB_BOTTOM],
				nPenLength,
				nPenThickness);
		}
		else
		{
			switch (nJobMethod)
			{
			case CLIENT_TYPE_PCB_DISTANCE_INSP: strText.Format("Fail to find PCB Edge");	break;
			case CLIENT_TYPE_ASSEMBLE_INSP:		strText.Format("Fail to find BOTTOM Edge");	break;
			}
		}
	}
	break;
	case DISTANCE_INSP_METHOD_M_TO_E: // Edge
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge
	case DISTANCE_INSP_METHOD_L_TO_E: // Edge
	{
		if (pInfo->bFindPattern[POINT_PCB_BOTTOM])
		{
			// Line Veritical
			pMain->draw_line(matColorImage,
				color,
				pInfo->line[FIND_CALIPER_PCB_VERT],
				W,
				H,
				nPenThickness);
			// Line Horizontal
			pMain->draw_line(matColorImage,
				color,
				pInfo->line[FIND_CALIPER_PCB_HORI],
				W,
				H,
				nPenThickness);
		}
		else
		{
			switch (nJobMethod)
			{
			case CLIENT_TYPE_PCB_DISTANCE_INSP: strText.Format("Fail to find PCB Edge");	break;
			case CLIENT_TYPE_ASSEMBLE_INSP:		strText.Format("Fail to find BOTTOM Edge");	break;
			}
		}
	}
	break;
	}

	color = colorCross;
	//교차점 그리기
	switch (nMethod)
	{
	case DISTANCE_INSP_METHOD_E_TO_E: // Edge 교차점
	{
		if (pInfo->bFindPattern[FIND_PCB_BOTTOM])
		{
			pMain->draw_mark(matColorImage,
				colorCross,
				pInfo->xPos[POINT_CROSS_1],
				pInfo->yPos[POINT_CROSS_1],
				nPenLength,
				nPenThickness);

			pMain->draw_mark(matColorImage,
				colorCross,
				pInfo->xPos[POINT_CROSS_2],
				pInfo->yPos[POINT_CROSS_2],
				nPenLength,
				nPenThickness);
		}
	}
	break;
	case DISTANCE_INSP_METHOD_L_TO_E: // Line 교차점
	{
		if (pInfo->bFindLine[FIND_CALIPER_PANEL_VERT] && pInfo->bFindPattern[FIND_PCB_BOTTOM])
		{
			pMain->draw_mark(matColorImage,
				colorCross,
				pInfo->xPos[POINT_CROSS_1],
				pInfo->yPos[POINT_CROSS_1],
				nPenLength,
				nPenThickness);
		}
		if (pInfo->bFindLine[FIND_CALIPER_PANEL_HORI] && pInfo->bFindPattern[FIND_PCB_BOTTOM])
		{
			pMain->draw_mark(matColorImage,
				colorCross,
				pInfo->xPos[POINT_CROSS_1],
				pInfo->yPos[POINT_CROSS_1],
				nPenLength,
				nPenThickness);
		}
	}
	break;
	}

	if (pMain->vt_job_info[nJob].model_info.getGlassInfo().getModelPanelType() == _CORE_MODEL_CALC)
	{
		pMain->draw_mark(matColorImage,
			colorOK,
			pInfo->xPos[POINT_CROSS_1],
			pInfo->yPos[POINT_CROSS_1],
			nPenLength,
			nPenThickness);

		pMain->draw_mark(matColorImage,
			colorLine,
			pInfo->xPos[POINT_PROTRUDING],
			pInfo->yPos[POINT_PROTRUDING],
			nPenLength,
			nPenThickness);
	}

	// PCB_Distance 검사 포인트 추출
	int nWidthPoint = 0, nHeightPoint = 0;
	if (pMain->m_nSeqTotalInspGrabCount == 2)
	{
		if (nCam == 0) {
			switch (nPos)
			{
			case 0:	nWidthPoint = 0;  nHeightPoint = 1;		break;
			case 1:	nWidthPoint = -1; nHeightPoint = 2;		break;
			}
		}
		else {
			switch (nPos)
			{
			case 0:	nWidthPoint = -1; nHeightPoint = 3;		break;
			case 1:	nWidthPoint = 5;  nHeightPoint = 4;		break;
			}
		}
	}
	else if (pMain->m_nSeqTotalInspGrabCount == 4)
	{
		if (nCam == 0) {
			switch (nPos)
			{
			case 0:	nWidthPoint = 0;  nHeightPoint = 1;		break;
			case 1:	nWidthPoint = -1; nHeightPoint = 2;		break;
			case 2:	nWidthPoint = -1; nHeightPoint = 3;		break;
			case 3:	nWidthPoint = -1; nHeightPoint = 4;		break;
			}
		}
		else {
			switch (nPos)
			{
			case 0:	nWidthPoint = -1; nHeightPoint = 5;		break;
			case 1:	nWidthPoint = -1; nHeightPoint = 6;		break;
			case 2:	nWidthPoint = -1; nHeightPoint = 7;		break;
			case 3:	nWidthPoint = 9;  nHeightPoint = 8;		break;
			}
		}
	}
	double Spec_distance_LSL_W = 0;
	double Spec_distance_USL_W = 0;
	double Spec_distance_LSL_H = 0;
	double Spec_distance_USL_H = 0;

	if (nWidthPoint >= 0) {
		Spec_distance_LSL_W = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(nWidthPoint);
		Spec_distance_USL_W = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(nWidthPoint);
	}
	Spec_distance_LSL_H = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecLSL(nHeightPoint);
	Spec_distance_USL_H = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSpecUSL(nHeightPoint);


	int offset = 100;
	cv::Scalar colorDrarLime = cv::Scalar(64, 128, 64);

	if (pMain->m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] &&
		pMain->m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM])
	{
		switch (nMethod)
		{
		case DISTANCE_INSP_METHOD_M_TO_M:
		case DISTANCE_INSP_METHOD_M_TO_E:
		case DISTANCE_INSP_METHOD_E_TO_E:
		{
			if (pMain->m_dDistanceInspJudgeResult[nWidthPoint])		color = colorDrarLime;
			else													color = colorNG;
			strText.Format("X(P%d) = %.3f( %.3f ~ %.3f )",	nWidthPoint + 1,
															pMain->m_stInsp_DistanceResult[real_cam][nPos].dWidthDistance,
															Spec_distance_LSL_W,
															Spec_distance_USL_W);
			putText(matColorImage, std::string(strText), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);

			if (pMain->m_dDistanceInspJudgeResult[nHeightPoint])	color = colorDrarLime;
			else													color = colorNG;
			strText.Format("Y(P%d) = %.3f( %.3f ~ %.3f )",	nHeightPoint + 1,
															pMain->m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance,
															Spec_distance_LSL_H,
															Spec_distance_USL_H);
			putText(matColorImage, std::string(strText), cv::Point(50, 100 + offset), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);

		}
		break;
		case DISTANCE_INSP_METHOD_L_TO_M:
		case DISTANCE_INSP_METHOD_L_TO_E:
		{
			if (pMain->m_dDistanceInspJudgeResult[nHeightPoint])	color = colorDrarLime;
			else													color = colorNG;
			strText.Format("Y(P%d) = %.3f( %.3f ~ %.3f )",	nHeightPoint + 1,
															pMain->m_stInsp_DistanceResult[real_cam][nPos].dHeightDistance,
															Spec_distance_LSL_H,
															Spec_distance_USL_H);
			putText(matColorImage, std::string(strText), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);
		}
		break;
		}
	}
	else
	{
		color = colorNG;
		putText(matColorImage, std::string(strText), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, nFontScale, color, 5);
	}

	if (pMain->m_bSaveReslutImage == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);

	if (pMain->m_bSaveRawImage == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage);

	matColorImage.release();

	str.Format("[%s] Cam : %d - %d Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}
UINT Thread_CircleImageSave(void* pParam)		
{
	_stSaveImageInfo* pInfo = (_stSaveImageInfo*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pInfo->pDlg;
	CFormMainView* pFormMain = (CFormMainView*)pMain->m_pForm[FORM_MAIN];

	int nCam = pInfo->nCam;
	int bJudge = pInfo->bJudge;
	int nIndex = pInfo->nIndex;
	int nJob = pInfo->nAlgorithm;
	int nNumPos = pInfo->nNumPos;
	BOOL b4Align = pInfo->b4Align;
	BOOL bUsing1Cam = pInfo->bUsing1Cam;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	CString str;
	cv::Mat matGrayImage(H, W, CV_8UC1, pMain->getSaveImageBuffer(real_cam, nIndex));
	cv::Mat matColorImage;
	cv::cvtColor(matGrayImage, matColorImage, CV_GRAY2BGR);

	cv::Scalar color;
	cv::Scalar colorOK = cv::Scalar(0, 255, 0);
	cv::Scalar colorNG = cv::Scalar(0, 0, 255);
	cv::Scalar colorBLUE = cv::Scalar(255, 64, 64);
	cv::Scalar colorMatch = cv::Scalar(255, 0, 255);
	int nOffset = 20;
	double dbFontSize = 4.0;
	double xres = pMain->GetMachine(nJob).getCameraResolutionX(nCam, 0);

	int nWidth = W;
	int nHeight = H;
	BOOL bFixtureUse = pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();
	if (bJudge)		color = colorOK;
	else			color = colorNG;

	//계산된 PN 중앙점
	double posX = pMain->m_ELB_TraceResult.m_ELB_ResultXY.x;
	double posY = pMain->m_ELB_TraceResult.m_ELB_ResultXY.y;

	str.Format("R : %.3f", pMain->m_ELB_TraceResult.m_nRadius * xres);
	putText(matColorImage, std::string(str), cv::Point(posX, posY), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 5);

	// KBJ 2022-09-07 센터얼라인 결과 이미지용 벡터
	CFormMainView* pForm = (CFormMainView*)pMain->m_pForm[FORM_MAIN];
	for (int i = 0; i < pForm->m_vtEdgePosition.size(); i++)
	{
		cv::circle(matColorImage, cv::Point(pForm->m_vtEdgePosition[i].x, pForm->m_vtEdgePosition[i].y), 4, cv::Scalar(0, 255, 0), 2, 5);
	}

	if (bJudge)		// OK
	{
		CString strText;

		int nPenThickness = 2;

		//double CIRCLE_RADIUS = 2.75;
		int radius = pMain->m_ELB_TraceResult.m_nRadius;

		CPoint ptBegin, ptEnd;

		ptBegin.x = posX - radius;
		ptBegin.y = posY - radius;
		ptEnd.x = posX + radius;
		ptEnd.y = posY + radius;

		//사각형 그리기(PN 중앙으로 사각형 그리기)
		cv::line(matColorImage, cv::Point(ptBegin.x, ptBegin.y), cv::Point(ptBegin.x, ptEnd.y), colorOK, 4);	//좌측선그리기
		cv::line(matColorImage, cv::Point(ptEnd.x, ptBegin.y), cv::Point(ptEnd.x, ptEnd.y), colorOK, 4);	//우측선그리기
		cv::line(matColorImage, cv::Point(ptBegin.x, ptBegin.y), cv::Point(ptEnd.x, ptBegin.y), colorOK, 4);	//상부선그리기
		cv::line(matColorImage, cv::Point(ptBegin.x, ptEnd.y), cv::Point(ptEnd.x, ptEnd.y), colorOK, 4);	//하부선그리기
		
		str.Format("X : %.4f Y : %.4f T : %.4f", pInfo->dRevision[AXIS_X], pInfo->dRevision[AXIS_Y], pInfo->dRevision[AXIS_T]);
		putText(matColorImage, std::string(str), cv::Point(50, H - 100), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 4);

		if (pInfo->bFinal)	str = "Final";
		else				str.Format("Retry : %d", pInfo->nRetry);
		putText(matColorImage, std::string(str), cv::Point(50, 100), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);
	}
	else				// NG
	{
		BOOL bFind = FALSE;

		if (pInfo->nCam == 0)
		{
			if (pInfo->nFound[0] != FIND_ERR)
			{
				if (pInfo->nFound[0] == FIND_OK)	color = colorOK;
				else								color = colorMatch;
				line(matColorImage, cv::Point((int)pInfo->dPosX[0] - nOffset, (int)pInfo->dPosY[0]), cv::Point((int)pInfo->dPosX[0] + nOffset, (int)pInfo->dPosY[0]), color, 2);
				line(matColorImage, cv::Point((int)pInfo->dPosX[0], (int)pInfo->dPosY[0] - nOffset), cv::Point((int)pInfo->dPosX[0], (int)pInfo->dPosY[0] + nOffset), color, 2);
			}
		}
		else
		{
			if (pInfo->nFound[1] != FIND_ERR)
			{
				if (pInfo->nFound[1] == FIND_OK)	color = colorOK;
				else								color = colorMatch;
				line(matColorImage, cv::Point((int)pInfo->dPosX[1] - nOffset, (int)pInfo->dPosY[1]), cv::Point((int)pInfo->dPosX[1] + nOffset, (int)pInfo->dPosY[1]), color, 2);
				line(matColorImage, cv::Point((int)pInfo->dPosX[1], (int)pInfo->dPosY[1] - nOffset), cv::Point((int)pInfo->dPosX[1], (int)pInfo->dPosY[1] + nOffset), color, 2);
			}
		}

		if (pMain->m_nErrorType[nJob] == ERR_TYPE_CIRCLE_ERROR)
		{
			str = "CIRCLE NG";
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);

			str.Format("R : %.3f", pMain->m_ELB_TraceResult.m_nRadius * xres);
			putText(matColorImage, std::string(str), cv::Point(W - 700, 150), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
		}

		if (pMain->m_nErrorType[nJob] == ERR_TYPE_REVISION_LIMIT)
		{
			str.Format("[%s] X : %.4f Y : %.4f T : %.4f NG Limit", pMain->vt_job_info[nJob].job_name.c_str(), pMain->GetPrealign(nJob).getRevisionX(),
				pMain->GetPrealign(nJob).getRevisionY(), pMain->GetPrealign(nJob).getRevisionT());
			putText(matColorImage, std::string(str), cv::Point(W - 700, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, colorNG, 2);
		}
		
		if(pMain->m_nErrorType[nJob] == 0)
		{
			str = "NG";
			putText(matColorImage, std::string(str), cv::Point(50, 50), cv::FONT_HERSHEY_SIMPLEX, dbFontSize, color, 2);
		}
	}

	// kbj 2022-01-05 SaveImage systemOption
	if (pMain->vt_system_option[nJob].jpg_compress_rate_Result < 90 || pMain->vt_system_option[nJob].jpg_compress_rate_Raw < 90) // 영상 압축해서 저장
	{
		vector<int> params_jpg;
		params_jpg.push_back(IMWRITE_JPEG_QUALITY);

		if (pMain->vt_system_option[nJob].result_image_save == TRUE)
			params_jpg.push_back(pMain->vt_system_option[nJob].jpg_compress_rate_Result);
		else
			params_jpg.push_back(pMain->vt_system_option[nJob].jpg_compress_rate_Raw);

		// result image save on/off
		if (pMain->vt_system_option[nJob].result_image_save == TRUE)
		{
			if (bJudge == TRUE && pMain->vt_system_option[nJob].ok_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage, params_jpg);
			if (bJudge == FALSE && pMain->vt_system_option[nJob].ng_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage, params_jpg);
		}
		// Raw image save on/off
		if (pMain->vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage, params_jpg);
	}
	else // 영상 압축 x
	{
		// result image save on/off
		if (pMain->vt_system_option[nJob].result_image_save == TRUE)
		{
			if (bJudge == TRUE && pMain->vt_system_option[nJob].ok_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);
			if (bJudge == FALSE && pMain->vt_system_option[nJob].ng_image_save == TRUE)	cv::imwrite(pMain->m_cSaveImageRingBufPath[nJob][nCam][nIndex], matColorImage);
		}

		// Raw image save on/off
		if (pMain->vt_system_option[nJob].raw_image_save == TRUE)						cv::imwrite(pMain->m_cSaveImageRingBufPath_Raw[nJob][nCam][nIndex], matGrayImage);
	}

	matColorImage.release();
	matGrayImage.release(); // kbj 2021-01-05 Add grayimage Release()

	str.Format("[%s] Cam : %d - %d Image Save Complete ", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, nIndex);
	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return 0;
}
UINT Thread_LogDelete(void *pParam)
{
	CLET_AlignClientDlg *pMain = (CLET_AlignClientDlg *)pParam;

	int save_term = pMain->m_nSaveTerm;
	int hdd_check = pMain->m_nHDD_UsedRate;
	int total=1, free=1;

	do
	{
		if (pMain->m_bAutoStart != TRUE)
		{			
			((CPaneAuto*)pMain->m_pPane[PANE_AUTO])->m_cPcPerformance.GetDiskSpace("D:\\", total, free);

			if((100 - (int(free / double(total) * 100)))> hdd_check) save_term = MAX(10,pMain->m_nSaveTerm - 10);

			RemoveDirByDay(pMain->m_strResultDir + "Video\\", save_term, pMain);
			RemoveDirByDay(pMain->m_strResultDir + "Files\\", save_term, pMain);
			RemoveDirByDay(pMain->m_strResultDir + "Trace\\", save_term, pMain);
			RemoveDirByDay(pMain->m_strImageDir, save_term, pMain);
			RemoveDirByDay(pMain->m_strHistoryDir+"Process\\", save_term, pMain);
		}

		::WaitForSingleObject(pMain->m_hDummyEvent, 10000);

	}while (pMain->m_bProgramEnd != TRUE);	
	return 0;
}

UINT Thread_LogDelete2(void* pParam)
{
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pParam;

	int save_term_offset = 0;
	int hdd_check = pMain->m_nHDD_UsedRate;
	int total = 1, free = 1;

	CString str;
	CPaneBottom* pPane = (CPaneBottom*)pMain->m_pPaneBottom[B_PANE_BOTTOM];
	CFormMainView* pForm = (CFormMainView*)pMain->m_pForm[FORM_MAIN];
	int nProcessing_count = 0;

	do
	{
		// KBJ 2022-08-09 Auto일때도 Log 지우기.
		if (pMain->m_bAutoStart == TRUE)
		{
			BOOL bProcessing = FALSE;
			for (int nJob = 0; nJob < pMain->vt_job_info.size(); nJob++)
			{
				if (pMain->getProcessStartFlag(nJob) == TRUE)	bProcessing = TRUE;
				if (pForm->m_bHandShake[nJob] == TRUE)			bProcessing = TRUE;  // KBJ 2022-08-26
			}

			// 프로세스 실행중이지 않을때 카운팅.
			if (bProcessing == FALSE)	nProcessing_count++;
			else
			{
				nProcessing_count = 0;
				continue;
			}

			// nSecond 동안 프로세스 실행되지 않으면 Delete 시작 .
			if (nProcessing_count >= pMain->m_system_option_common.cycle_time_to_delete_file_auto_mode / 10) //10000ms->s
			{
				CString str = "Start Auto Mode LogDelete";
				::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

				pPane->SetAutoStartStop(FALSE);
				
				::SendMessageA(pMain->m_pPane[PANE_MANUAL]->m_hWnd, WM_VIEW_CONTROL, MSG_PMN_MANUAL_COLOR_RESET, 0);

				// KBJ 2022-08-26
				pForm->HideErrorMessageBlink();
				str.Format("Doing delete file ... ");
				pForm->ShowErrorMessageBlink(str);
			}
		}

		if (pMain->m_bAutoStart != TRUE)
		{
			((CPaneAuto*)pMain->m_pPane[PANE_AUTO])->m_cPcPerformance.GetDiskSpace("D:\\", total, free);

			RemoveDirByDay(pMain->m_strResultDir + "Video\\"	, pMain->m_system_option_common.save_term_file_video + save_term_offset, pMain);
			RemoveDirByDay(pMain->m_strResultDir + "Files\\"	, pMain->m_system_option_common.save_term_file_excel + save_term_offset, pMain);
			RemoveDirByDay(pMain->m_strImageDir					, pMain->m_system_option_common.save_term_file_image + save_term_offset, pMain);
			RemoveFileByDay(pMain->m_strHistoryDir + "Process\\"	, pMain->m_system_option_common.save_term_file_history + save_term_offset, pMain);
			RemoveDirByDay(pMain->m_strResultDir + "Trace\\",pMain->m_system_option_common.save_term_file_image + save_term_offset, pMain);
			
			if ((100 - (int(free / double(total) * 100))) > hdd_check)	save_term_offset--;
			else														save_term_offset = 0;

			// Auto중 지우기 끝났을때 Auto 원복.
			if (nProcessing_count >= pMain->m_system_option_common.cycle_time_to_delete_file_auto_mode / 10)
			{
				str.Format("End Auto Mode LogDelete.");
				::SendMessage(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
				pPane->m_btnAutoStart.SetEnable(true);

				pPane->OnBnClickedBtnAutoStart();
			}
			pForm->HideErrorMessageBlink();
			nProcessing_count = 0;
		}
		::WaitForSingleObject(pMain->m_hDummyEvent, 10000);
	} while (pMain->m_bProgramEnd != TRUE);
	return 0;
}


UINT Thread_Check_Model_Process_Able(void* pParam)
{
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pParam;

	int save_term_offset = 0;
	int hdd_check = pMain->m_nHDD_UsedRate;
	int total = 1, free = 1;

	CString str;
	CFormMainView* pForm = (CFormMainView*)pMain->m_pForm[FORM_MAIN];
	int nProcessing_count = 0;

	do
	{
		if (pMain->m_bAutoStart == TRUE)
		{
			BOOL bProcessing = FALSE;
			for (int nJob = 0; nJob < pMain->vt_job_info.size(); nJob++)
			{
				if (pMain->getProcessStartFlag(nJob) == TRUE)	bProcessing = TRUE;
				if (pForm->m_bHandShake[nJob] == TRUE)			bProcessing = TRUE;  // KBJ 2022-08-26
			}

			if (bProcessing == TRUE)
			{
				bProcessing = FALSE;

				for (int nModel_Process = 0; nModel_Process < 4; nModel_Process++)
				{
					if (pForm->m_bModelProcessStart[nModel_Process] == TRUE)
					{
						bProcessing = TRUE;
					}
				}
			}

			if (bProcessing != TRUE)
			{
				g_CommPLC.SetBit(pMain->model_process_addres.PLC_WB_PLC_MODEL_PROCESS_ABLE, TRUE);
			}
			else
			{
				g_CommPLC.SetBit(pMain->model_process_addres.PLC_WB_PLC_MODEL_PROCESS_ABLE, FALSE);
			}
		}
		else
		{
			g_CommPLC.SetBit(pMain->model_process_addres.PLC_WB_PLC_MODEL_PROCESS_ABLE, TRUE);
		}
		::WaitForSingleObject(pMain->m_hDummyEvent, 10000);
	} while (pMain->m_bProgramEnd != TRUE);
	return 0;
}


UINT Thread_ImageGrab(void *pParam)
{
#ifdef _DAHUHA
	CDahuaCameraHelper* pCamera = (CDahuaCameraHelper*)pParam;
	pCamera->grabSingle();
#else
	CCamera* pCamera = (CCamera*)pParam;
	pCamera->SingleGrab();
#endif
	return 0;
}
UINT Thread_ImageGrabSapera(void* pParam)
{
	CSaperaCamera* pCamera = (CSaperaCamera*)pParam;
	pCamera->SingleGrab();

	return 0;
}
UINT Thread_EdgeIspection(void* pParam)
{
	struct _stFindPattern* pPattern = (struct _stFindPattern*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pPattern->pDlg;

	BOOL bFind = TRUE;

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;
	int nJob = pPattern->nJob;
	int nSCount = pPattern->nSearchCount;
	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	if (pMain->m_bSimulationStart != TRUE && nPos != 1)
	{
		pMain->copyMemory(pMain->getProcBuffer(real_cam, 0), pMain->getSrcBuffer(real_cam), W * H);
	}
	
	if (nPos==1) pMain->m_bFindPattern[real_cam] = pMain->m_pSaperaInspWorker[real_cam].algorithm_WetOut_OnesInsp(pMain->m_pSaperaCam[real_cam].GetFullImage()->data, nJob, real_cam, W,H* _SCAN_GRAB_MAXCOUNT);
	else		 pMain->m_bFindPattern[real_cam] = pMain->m_pSaperaInspWorker[real_cam].algorithm_WetOut_OnesInsp(pMain->getProcBuffer(real_cam, 0), nJob, real_cam, W, H);

	//HSJ 스펙 창 계속 갱신
	::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_SCAN_SPEC_VIEW, MAKELPARAM(real_cam, nPos));

	pMain->m_bFindPatternEnd[real_cam] = TRUE;

	return 0;
}
UINT Thread_FindPattern(void *pParam)		// 17.12.30 jmLee		Auto 모드일때 라이브 처리 하도록..
{
	struct _stFindPattern *pPattern = (struct _stFindPattern *) pParam;
	CLET_AlignClientDlg *pMain = (CLET_AlignClientDlg *)pPattern->pDlg;
	CFormMainView* pFormMain = (CFormMainView*)pMain->m_pForm[FORM_MAIN];

	BOOL bFind = TRUE;

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;
	int nJob = pPattern->nJob;
	int nSCount = pPattern->nSearchCount;
	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];


	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	// kbj 2022-01-07 live simulation mode.
	CPaneSimulation* pPane = (CPaneSimulation*)pMain->m_pPane[PANE_SIMULATION];
	if (pMain->m_bSimulationStart != TRUE || pPane->m_bUseLive == TRUE)
		pMain->copyMemory(pMain->getProcBuffer(real_cam, nPos), pMain->getSrcBuffer(real_cam), W * H);

	CString strTemp;
	/*strTemp.Format("[%s] cam : %d, pos : %d, count : %d, size : %d", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, nPos, nSCount, W * H);
	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
*/
	for (int pos = 0; pos < nSCount; pos++)
	{
		int method = pMain->vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod();

		if (method == METHOD_RANSAC)
		{
			bool bwhite = pMain->vt_job_info[nJob].model_info.getAlignInfo().getMarkReverseFind() ? true : false;
			pMain->GetMatching(nJob).findPattern(pMain->getProcBuffer(real_cam, nPos), nCam, nPos + pos, W, H);
		}
		else if (method == METHOD_LINE || method == METHOD_CIRCLE || method == METHOD_NOTCH || method == METHOD_ELLIPSE || method == METHOD_NOTCH)
		{
			cv::Mat img(H, W, CV_8UC1, pMain->getProcBuffer(real_cam, nPos));
			double posx = 0.0, posy = 0.0;
			double xres = pMain->GetMachine(nJob).getCameraResolutionX(0, 0);
			double yres = pMain->GetMachine(nJob).getCameraResolutionY(0, 0);
			int x = pMain->vt_job_info[nJob].model_info.getAlignInfo().getInspRangeX() / xres / 2; //  중심점 기준 좌우 분리
			int y = pMain->vt_job_info[nJob].model_info.getAlignInfo().getInspRangeY() / yres / 2;  //  중심점 기준 상하 분리
			double l = pMain->vt_job_info[nJob].model_info.getAlignInfo().getInspRangeLength(); //도포 길이
			int cx = W / 2, cy = H / 2;
			BOOL br=TRUE;
			int viewer = pMain->vt_job_info[nJob].viewer_index[0];

			pMain->m_dbCirceErrorLossRate = 0.0; // Tkyuha 221108 에러율 초기화
			//CenterAlign Method
			switch (method)
			{
			case  METHOD_LINE:
			{
				pFormMain->m_pDlgViewerMain[viewer]->GetViewer().OnLoadImageFromPtr(pMain->getProcBuffer(real_cam, 0));
				br = pFormMain->InspLineEdgeDetection(nJob, img, CPoint(cx - x, cy - y), CPoint(cx + x, cy + y), l, &pFormMain->m_pDlgViewerMain[viewer]->GetViewer());
			}
			break;
			case  METHOD_CIRCLE: br = pFormMain->InspCircleEdgeDetection(nJob, img, CPoint(cx - x, cy - y), CPoint(cx + x, cy + y), &pFormMain->m_pDlgViewerMain[viewer]->GetViewer()); break;
			case  METHOD_NOTCH: br = pFormMain->InspNotchEdgeDetection(true, false, nJob, nCam, CPoint(cx - x, cy - y), CPoint(cx + x, cy + y), NULL, true); break;
			case  METHOD_NOTCH_LINE: pFormMain->InspNotchEdgeDetection(true, false, nJob, nCam, CPoint(cx - x, cy - y), CPoint(cx + x, cy + y), NULL, true); break;
			case  METHOD_ELLIPSE: break;
			}
			
			CFindInfo pFindInfo = pMain->GetMatching(nJob).getFindInfo(nCam, nPos);
			pFindInfo.SetXPos(pMain->m_ELB_TraceResult.m_ELB_ResultXY.x);
			pFindInfo.SetYPos(pMain->m_ELB_TraceResult.m_ELB_ResultXY.y);
			pFindInfo.SetAngle(pMain->m_ELB_TraceResult.m_ELB_ResultT);

			if(br) pFindInfo.SetFound(FIND_OK);
			else pFindInfo.SetFound(FIND_ERR);
			
			pMain->GetMatching(nJob).setFindInfo(nCam, nPos, pFindInfo);
		}		
		else
		{
			int bMethod = pMain->vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod();

			//if (bMethod == METHOD_MATCHING)
			{
				CRect realRoi = pMain->GetMatching(nJob).getSearchROI(nCam, nPos + pos);
				bool bwhite = pMain->vt_job_info[nJob].model_info.getAlignInfo().getEnableAlignBlackWhiteSelect() ? true : false;
				pMain->GetMatching(nJob).findPattern(pMain->getProcBuffer(real_cam, nPos), nCam, nPos + pos, W, H);

				pMain->GetMatching(nJob).setSearchROI(nCam, nPos + pos, realRoi);
			}

			if (bMethod == METHOD_MATCHING_LINE_THETA)
			{
				BYTE* pImage = pMain->getProcBuffer(real_cam, nPos);
				double dx = 0.0, dy = 0.0, dt = 0.0, posx = 0.0, posy = 0.0;

				BOOL bFixtureUse = pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();

				if (bFixtureUse)
				{
					double fixtureX = pMain->GetMatching(nJob).getFixtureX(nCam, pos + nPos);
					double fixtureY = pMain->GetMatching(nJob).getFixtureY(nCam, pos + nPos);
					double posX = pMain->GetMatching(nJob).getFindInfo(nCam, pos + nPos).GetXPos();
					double posY = pMain->GetMatching(nJob).getFindInfo(nCam, pos + nPos).GetYPos();

					CFindInfo pFindInfo = pMain->GetMatching(nJob).getFindInfo(nCam, pos + nPos);
					pFindInfo.SetMatchingXPos(posX);
					pFindInfo.SetMatchingYPos(posY);
					pMain->GetMatching(nJob).setFindInfo(nCam, pos + nPos, pFindInfo);

						dx = posX - fixtureX;
						dy = posY - fixtureY;
						dt = 0.0;
				}


				pMain->m_pDlgCaliper->m_Caliper[real_cam][pos + nPos][0].processCaliper(pImage, W, H, dx, dy, dt);
				if (pMain->m_pDlgCaliper->m_Caliper[real_cam][pos + nPos][0].getIsMakeLine() != TRUE)	pMain->GetMatching(nJob).getFindInfo(nCam, nPos).SetFound(FIND_ERR);
			}


			if (bMethod == METHOD_CALIPER)
			{
				BOOL bFindLine[2];
				sLine line_info[2];
				double dx = 0.0, dy = 0.0, dt = 0.0, posx =0.0, posy = 0.0;
				BYTE *pImage = pMain->getProcBuffer(real_cam, nPos);

				BOOL bFixtureUse = pMain->vt_job_info[nJob].model_info.getAlignInfo().getUseFixtureMark();

				if (bFixtureUse)
				{
					double fixtureX = pMain->GetMatching(nJob).getFixtureX(nCam, pos + nPos);
					double fixtureY = pMain->GetMatching(nJob).getFixtureY(nCam, pos + nPos);
					double posX = pMain->GetMatching(nJob).getFindInfo(nCam, pos + nPos).GetXPos();
					double posY = pMain->GetMatching(nJob).getFindInfo(nCam, pos + nPos).GetYPos();

					CFindInfo pFindInfo = pMain->GetMatching(nJob).getFindInfo(nCam, pos + nPos);
					pFindInfo.SetMatchingXPos(posX);
					pFindInfo.SetMatchingYPos(posY);
					pMain->GetMatching(nJob).setFindInfo(nCam, pos + nPos, pFindInfo);

					if (fixtureX != 0.0 && fixtureY != 0.0)
					{
						dx = posX - fixtureX;
						dy = posY - fixtureY;
						dt = 0.0;
					}
				}

				pMain->m_pDlgCaliper->m_Caliper[real_cam][pos + nPos][C_CALIPER_POS_1].processCaliper(pImage, W, H, dx, dy, dt, TRUE);
				pMain->m_pDlgCaliper->m_Caliper[real_cam][pos + nPos][C_CALIPER_POS_2].processCaliper(pImage, W, H, dx, dy, dt, TRUE);

				line_info[0] = pMain->m_pDlgCaliper->m_Caliper[real_cam][pos + nPos][C_CALIPER_POS_1].m_lineInfo;
				line_info[1] = pMain->m_pDlgCaliper->m_Caliper[real_cam][pos + nPos][C_CALIPER_POS_2].m_lineInfo;
				bFindLine[0] = pMain->m_pDlgCaliper->m_Caliper[real_cam][pos + nPos][C_CALIPER_POS_1].getIsMakeLine();
				bFindLine[1] = pMain->m_pDlgCaliper->m_Caliper[real_cam][pos + nPos][C_CALIPER_POS_2].getIsMakeLine();

				if (bFindLine[0] && bFindLine[1])
				{
					sLine lineVert = line_info[0];
					sLine lineHori = line_info[1];

					// 21.02.13 각도를 Matching Rate로 변환.
					double dAngle = pMain->calcIncludedAngle(lineHori, lineVert);	
					double dRate  = pMain->make_included_angle_to_matching(dAngle, nJob);

					CCaliper::cramersRules(-lineHori.a, 1, -lineVert.a, 1, lineHori.b, lineVert.b, &posx, &posy);

					CFindInfo pFindInfo = pMain->GetMatching(nJob).getFindInfo(nCam, pos + nPos);
					pFindInfo.SetXPos(posx);
					pFindInfo.SetYPos(posy);
					pFindInfo.SetFound(FIND_OK);
					//KJH 2021-08-14 Caliper Angle Log 추가
					pFindInfo.SetCaliperAngle(dAngle);
					pFindInfo.SetScore(dRate);
					pFindInfo.SetLine(0, lineHori);
					pFindInfo.SetLine(1, lineVert);
					pFindInfo.SetFindline(0,TRUE);
					pFindInfo.SetFindline(1,TRUE);
					pMain->GetMatching(nJob).setFindInfo(nCam, pos + nPos, pFindInfo);
				}
				else
				{
					CFindInfo pFindInfo = pMain->GetMatching(nJob).getFindInfo(nCam, pos + nPos);
					pFindInfo.SetXPos(0.0);
					pFindInfo.SetYPos(0.0);
					pFindInfo.SetFound(FIND_ERR);
					//KJH 2021-08-14 Caliper Angle Log 추가
					pFindInfo.SetCaliperAngle(0.0);
					pFindInfo.SetScore(0.0);
					if (bFindLine[0] == TRUE)
					{
						sLine  lineVert = line_info[0];
						pFindInfo.SetLine(0, lineVert);
						pFindInfo.SetFindline(0, FALSE); 
					}
					else if (bFindLine[1] == TRUE)
					{
						sLine lineHori= line_info[1];
						pFindInfo.SetLine(1, lineHori);
						pFindInfo.SetFindline(1, FALSE);
					}
					pMain->GetMatching(nJob).setFindInfo(nCam, pos + nPos, pFindInfo);
				}
			}
		}

		if (pMain->GetMatching(nJob).getFindInfo(nCam, pos + nPos).GetFound() != FIND_OK)
			bFind = FALSE;
	}

	if (bFind == FALSE)
	{
		pMain->m_bFindPattern[real_cam] = FALSE;

		strTemp.Format("[%s] Cam %d Find NG", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1);
		::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
	}
	else  pMain->m_bFindPattern[real_cam] = TRUE;

	pMain->m_bFindPatternEnd[real_cam] = TRUE;

	pMain->m_bFindAlignPattern[real_cam][nPos] = bFind;
	pMain->m_bFindAlignPatternEnd[real_cam][nPos] = TRUE;

	return 0;
}

UINT Thread_FindNozzlePattern(void* pParam)		 // 20220921 노즐 얼라인 찾는 방법 선형으로 변경
{
	struct _stFindPattern* pPattern = (struct _stFindPattern*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pPattern->pDlg;
	CFormMainView* pFormMain = (CFormMainView*)pMain->m_pForm[FORM_MAIN];
	BOOL bFind = TRUE;
	CString strTemp;

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;
	int nJob = pPattern->nJob;
	int nSCount = pPattern->nSearchCount;
	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	cv::Point2f matchPt= cv::Point2f(-1,-1);

	CPaneSimulation* pPane = (CPaneSimulation*)pMain->m_pPane[PANE_SIMULATION];
	if (pMain->m_bSimulationStart != TRUE || pPane->m_bUseLive == TRUE)
		pMain->copyMemory(pMain->getProcBuffer(real_cam, nPos), pMain->getSrcBuffer(real_cam), W * H);	

	bFind = pFormMain->InspNozzleSearchCaliper_Use(pMain->getProcBuffer(real_cam, nPos), W, H, nJob, real_cam, matchPt);

	CFindInfo pFindInfo = pMain->GetMatching(nJob).getFindInfo(nCam, nPos);
	pFindInfo.SetXPos(matchPt.x);
	pFindInfo.SetYPos(matchPt.y);
	pFindInfo.SetAngle(0);

	if (bFind) pFindInfo.SetFound(FIND_OK);
	else pFindInfo.SetFound(FIND_ERR);

	pMain->GetMatching(nJob).setFindInfo(nCam, nPos, pFindInfo);

	if (bFind == FALSE)
	{
		pMain->m_bFindPattern[real_cam] = FALSE;

		strTemp.Format("[%s] Cam %d Find NG", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1);
		::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
	}
	else  pMain->m_bFindPattern[real_cam] = TRUE;

	pMain->m_bFindPatternEnd[real_cam] = TRUE;

	pMain->m_bFindAlignPattern[real_cam][nPos] = bFind;
	pMain->m_bFindAlignPatternEnd[real_cam][nPos] = TRUE;

	return 0;
}
UINT Thread_PcbDistanceInspection(void *pParam)
{
	struct _stFindPattern *pPattern = (struct _stFindPattern *) pParam;
	CLET_AlignClientDlg *pMain = (CLET_AlignClientDlg *)pPattern->pDlg;

	BOOL bFind = TRUE;

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;
	int nJob = pPattern->nJob;
	int nSCount = pPattern->nSearchCount;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];
	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;
	
	// srcbuffer가 pos 구분이 없어, 
	// 시뮬레이션일때에는 ProcBuffer에 미리 이미지를 복사 해둠.
	if(pMain->m_bSimulationStart != TRUE)
		pMain->copyMemory(pMain->getProcBuffer(real_cam, nPos), pMain->getSrcBuffer(real_cam), W * H);

	CString strTemp;

	int nInspMethod = pMain->vt_job_info[nJob].model_info.getAlignInfo().getInspectionMethod();			// Panel 끝단 위치 검사 방법.
	int nInspSubMethod = pMain->vt_job_info[nJob].model_info.getAlignInfo().getInspectionSubMethod();		// Panel 중간 위치 검사 방법.

#pragma region 패널 및 PCB 찾는 부분
	// 좌측 카메라는 첫 위치, 우측 카메라는 마지막 위치일때,
	// 패널의 좌/우측 엣지(세로)가 보이므로, 세로선을 추가로 찾기 위해 분기 함.
	if ((nCam == 0 && nPos == 0) ||
		(nCam == 1 && nPos == pMain->m_nSeqTotalInspGrabCount - 1))
	{
		bFind = pMain->algorithm_pcb_Insp(pMain->getProcBuffer(real_cam, nPos), pPattern, nInspMethod);
	}
	else
	{
		bFind = pMain->algorithm_pcb_Insp(pMain->getProcBuffer(real_cam, nPos), pPattern, nInspSubMethod, TRUE);
	}
#pragma endregion

	if (bFind == FALSE)
	{
		strTemp.Format("[%s] Cam %d Find NG", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1);
		::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
	}

	pMain->m_bFindPattern[real_cam] = bFind;
	pMain->m_bFindPatternEnd[real_cam] = TRUE;

	pMain->m_bFindInspPattern[real_cam][nPos] = bFind;
	pMain->m_bFindInspPatternEnd[real_cam][nPos] = TRUE;

	return 0;
}
UINT Thread_AssembleInspection(void* pParam)
{
	struct _stFindPattern* pPattern = (struct _stFindPattern*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pPattern->pDlg;

	CString strTemp;
	BOOL bFind = TRUE;

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;
	int nJob = pPattern->nJob;
	int nSCount = pPattern->nSearchCount;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	if (pMain->m_bSimulationStart != TRUE)
		pMain->copyMemory(pMain->getProcBuffer(real_cam, nPos), pMain->getSrcBuffer(real_cam), W * H);

	int nInspMethod = pMain->vt_job_info[nJob].model_info.getAlignInfo().getInspectionMethod();

	if (pMain->vt_job_info[nJob].model_info.getGlassInfo().getModelPanelType() == _CORE_MODEL_CALC)
	{
		bFind = pMain->m_bInspResult[nJob] = pMain->algorithm_AssembleInsp_CALC(pMain->getProcBuffer(real_cam, 0), pPattern, nInspMethod);
	}
	else
	{
		bFind = pMain->m_bInspResult[nJob] = pMain->algorithm_assemble_Insp(pMain->getProcBuffer(real_cam, 0), pPattern, nInspMethod);
	}

	if (bFind == FALSE)
	{
		pMain->m_bFindPattern[real_cam] = FALSE;

		strTemp.Format("[%s] Cam %d Find NG", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1);
		::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
	}

	pMain->m_bFindPatternEnd[real_cam] = TRUE;

	return 0;
}

UINT Thread_Ink_UVInspection(void* pParam)
{
	struct _stFindPattern* pPattern = (struct _stFindPattern*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pPattern->pDlg;
	CFormMainView* pFormMain = (CFormMainView*)pMain->m_pForm[FORM_MAIN];

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;
	int nJob = pPattern->nJob;

	int real_cam = pMain->vt_job_info[nJob].camera_index[0];
	int nViewer = pMain->vt_job_info[nJob].viewer_index[0], ncount = 0;
	CViewerEx* pViewer = &pFormMain->m_pDlgViewerMain[nViewer]->GetViewer();
	CString strTemp;

	bool r_inspAck = pFormMain->fnCInk2_UV_InkInspection(nJob, 0, ncount, pMain->getProcBuffer(real_cam, 0), pViewer);
	int bFilmUVCheckSpec = pMain->vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmUVCheckSpec();

	if (r_inspAck == false)
	{
		strTemp.Format("[UV Check !] Contact Angle Count = %d (spec =%d)", ncount, bFilmUVCheckSpec);
		pFormMain->ShowErrorMessageBlink(strTemp);
	}
	else strTemp.Format("[%s] Contact Angle Count = %d", pMain->vt_job_info[nJob].get_job_name(), ncount);

	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

	pViewer->Invalidate();

	return 0;
}

UINT  Thread_ScratchInsp(void* pParam)
{
	struct _stFindPattern* pPattern = (struct _stFindPattern*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pPattern->pDlg;
	CFormMainView* pFormMain = (CFormMainView*)pMain->m_pForm[FORM_MAIN];

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;
	int nJob = pPattern->nJob;

	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];
	int nViewer = pMain->vt_job_info[nJob].viewer_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	CViewerEx* pViewer = &pFormMain->m_pDlgViewerMain[nViewer]->GetViewer();
	CString strTemp;

	pMain->copyMemory(pMain->getProcBuffer(real_cam, 2), pMain->getSrcBuffer(real_cam), W * H);

	BOOL r_inspAck = pFormMain->Inspection_ScratchHole(nJob, 0, pMain->getProcBuffer(real_cam, 2), pViewer);

	if (r_inspAck == FALSE)
	{
		strTemp.Format("[Scratch Inspection !] Panel Scratch Check !!!");
		pFormMain->ShowErrorMessageBlink(strTemp);
		pMain->m_bSubInspJudge[real_cam] = FALSE;
	}

	::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

	SetEvent(pMain->m_hInspEndEvent[real_cam]);

	return 0;
}

//HTK 2022-07-12 Nozzel#45에 약액상태 검사 추가
UINT Thread_Ink_45CamInspection(void* pParam)
{
	struct _stFindPattern* pPattern = (struct _stFindPattern*)pParam;
	CLET_AlignClientDlg* pMain = (CLET_AlignClientDlg*)pPattern->pDlg;
	CFormMainView* pFormMain = (CFormMainView*)pMain->m_pForm[FORM_MAIN];

	BOOL bFind = TRUE;

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;
	int nJob = pPattern->nJob;
	int nSCount = pPattern->nSearchCount;
	int real_cam = pMain->vt_job_info[nJob].camera_index[nCam];

	int W = pMain->m_stCamInfo[real_cam].w;
	int H = pMain->m_stCamInfo[real_cam].h;

	// kbj 2022-01-07 live simulation mode.
	CString strTemp;
	CPaneSimulation* pPane = (CPaneSimulation*)pMain->m_pPane[PANE_SIMULATION];
	if (pMain->m_bSimulationStart != TRUE || pPane->m_bUseLive == TRUE)
		pMain->copyMemory(pMain->getProcBuffer(real_cam, nPos), pMain->getSrcBuffer(real_cam), W * H);
	
	//	검사 시작
	CRect realRoi = pMain->GetMatching(nJob).getSearchROI(nCam, nPos);

	if (realRoi.Width() > 0 && realRoi.Width() < W && realRoi.Height() > 0 && realRoi.Height() < H)
	{
		realRoi.left = MIN(MAX(realRoi.left, 0), W - 1);
		realRoi.top = MIN(MAX(realRoi.top, 0), H - 1);
		realRoi.right = MAX(MIN(realRoi.right, W - 1), 0);
		realRoi.bottom = MAX(MIN(realRoi.bottom, H - 1), 0);

		if (realRoi.left > realRoi.right)
		{
			int tmp = realRoi.right;
			realRoi.right = realRoi.left;
			realRoi.left = tmp;
		}

		if (realRoi.bottom < realRoi.top)
		{
			int tmp = realRoi.bottom;
			realRoi.bottom = realRoi.top;
			realRoi.top = tmp;
		}

		double hthresh = pMain->vt_job_info[nJob].model_info.getInspSpecParaInfo().get45DegreeInkInspThresh();

		cv::Mat img(H, W, CV_8UC1, pMain->getProcBuffer(real_cam, nPos));
		cv::Mat InspImg = img(cv::Rect(realRoi.left, realRoi.top, realRoi.Width(), realRoi.Height()));
		cv::Scalar scalar = cv::mean(InspImg);

		if (scalar.val[0] > hthresh) bFind = TRUE;
		else bFind = FALSE;
// 		//20211018 Tkyuha Trace 이미지 오늘 날짜에 저장
		//////////////////////////////////////////////

		CString strImageDir, str;
		CString strTime, str_modelID, str_algo, strDate;
		SYSTEMTIME time;
		::GetLocalTime(&time);
		int algo = nJob;
		///////////////////////////////////// 이미지 저장 폴더
		///  D:\\ Result \\ Image \\ 날짜 \\ 모델ID  \\ JOB이름 \\ OK/NG   \\ PanelID \\

		// KBJ 2022-02-23 changed strTime
		//이미지저장 시간
		if (pMain->m_strResultTime[algo].IsEmpty())	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
		else									strTime.Format("%s", pMain->m_strResultTime[algo]);

		//날짜
		if (pMain->m_strResultDate[algo].IsEmpty())	strDate.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
		else									strDate.Format("%s", pMain->m_strResultDate[algo]);

		strImageDir.Format("%s%s", pMain->m_strImageDir, strDate);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

		//모델ID
		str_modelID.Format("%s", pMain->vt_job_info[algo].model_info.getModelID());
		strImageDir.Format("%s\\%s", strImageDir, str_modelID);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

		//JOB이름
		str_algo.Format(_T("%s"), pMain->vt_job_info[algo].job_name.c_str());
		strImageDir.Format("%s\\%s", strImageDir, str_algo);
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

		if (bFind)
		{
			strImageDir.Format("%s\\OK", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}
		else
		{
			strImageDir.Format("%s\\NG", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}

		//PanelID
		//KJH 2021-08-14 PANEL ID 없는거 따로 별도의 폴더로 관리
		if (strlen(pMain->vt_job_info[algo].main_object_id.c_str()) <= 13)
		{
			strImageDir.Format("%s\\Not Exist Panel ID\\", strImageDir);
			if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);
		}

		// KBJ 2022-02-23 If panel_id of memoried is same current panel_id that divide folder_name to time.
		strImageDir.Format("%s\\%s", strImageDir, pMain->vt_job_info[algo].main_object_id.c_str());
		if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

		if (strlen(pMain->vt_job_info[algo].main_object_id.c_str()) <= 13)
		{
			str.Format("%s\\NO_NAME_%s_%s_ImgRaw.jpg", strImageDir,	strTime,pMain->m_stCamInfo[real_cam].cName);	
		}
		else
		{
			str.Format("%s\\%s_%s_%s_ImgRaw.jpg", strImageDir,	pMain->vt_job_info[algo].main_object_id.c_str(),	strTime,	pMain->m_stCamInfo[real_cam].cName);
		}

		cv::imwrite(std::string(str), img);
//
		InspImg.release();
		img.release();

		strTemp.Format("[%s] Cam %d Find Gray = %.3f", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, scalar.val[0]);

		if (bFind == FALSE)
		{
			strTemp.Format("[%s] Cam %d Find NG Gray = %.3f", pMain->vt_job_info[nJob].job_name.c_str(), nCam + 1, scalar.val[0]);
			::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
		}

		theLog.logmsg(LOG_ETC, strTemp);

	} else bFind = TRUE;
		

	if (bFind == FALSE)		pMain->m_bFindPattern[real_cam] = FALSE;
	else  pMain->m_bFindPattern[real_cam] = TRUE;

	
	pMain->m_bFindPatternEnd[real_cam] = TRUE;

	pMain->m_bFindAlignPattern[real_cam][nPos] = bFind;
	pMain->m_bFindAlignPatternEnd[real_cam][nPos] = TRUE;	

	return 0;
}

UINT Thread_Process(void *pParam)
{
#ifndef NO_MIL	
	STPARAM Param = *(STPARAM*)pParam;

	int nRet = 0;
	int nJob = Param.id;	
	CString str;
	
	CLET_AlignClientDlg *pMain = (CLET_AlignClientDlg *)Param.m_pDlg;

	delete pParam;

	pMain->m_bThreadEndFlag = TRUE;

	while (pMain->m_bProgramEnd != TRUE)
	{
		if (pMain->getProcessStartFlag(nJob))
		{
			nRet = (pMain->*pMain->m_pFunc[nJob])(nJob);

			int nMethod = pMain->vt_job_info[nJob].algo_method;

			if (nMethod == CLIENT_TYPE_ONLY_VIEW)
			{
				if (nRet == 1)		pMain->resetProcessStartFlag(nJob);
				else if (nRet == 2) pMain->resetProcessStartFlag(nJob);
				
				::WaitForSingleObject(pMain->m_hDummyEvent, 50);

				continue;
			}

			if (nRet == 1)		// OK
			{
#ifdef _DATA_BASE
				//Tkyuha 2021-12-21 DataBase에 저장
				_st_SUM_RESULT_DATA _result;
				memset(&_result, 0, sizeof(_st_SUM_RESULT_DATA));
				_result._bok = true; _result._bng = false; _result._jobID= nJob;
#endif
				if (pMain->vt_job_info[nJob].model_info.getMachineInfo().getRevisionLimit(AXIS_X) < fabs(pMain->m_dbRevisionData[nJob][AXIS_X]) ||
					pMain->vt_job_info[nJob].model_info.getMachineInfo().getRevisionLimit(AXIS_Y) < fabs(pMain->m_dbRevisionData[nJob][AXIS_Y]) ||
					pMain->vt_job_info[nJob].model_info.getMachineInfo().getRevisionLimit(AXIS_T) < fabs(pMain->m_dbRevisionData[nJob][AXIS_T]))
				{
					pMain->m_bRetryOkNg[nJob] = FALSE;
					pMain->m_nRetryCount[nJob]++;
				}
				else
				{
					pMain->m_bRetryOkNg[nJob] = TRUE;
					pMain->m_nRetryCount[nJob] = 0;
				}

				if (nMethod == CLIENT_TYPE_PANEL_EXIST_INSP || nMethod == CLIENT_TYPE_PCB_DISTANCE_INSP || 
					nMethod == CLIENT_TYPE_ASSEMBLE_INSP || nMethod == CLIENT_TYPE_SCAN_INSP || 
					nMethod == CLIENT_TYPE_FILM_INSP || nMethod == CLIENT_TYPE_NOZZLE_SIDE_VIEW)
				{
					if (pMain->m_nInspRequestRead[nJob])		pMain->fnProcessCheckOK(nJob);
					else
					{
						str.Format("[%s] PLC Request Off!! OK Signal Ignore", pMain->vt_job_info[nJob].get_job_name());
						::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					}
				}
				else
				{
					if (pMain->m_nAlignRequestRead[nJob])		pMain->fnProcessCheckOK(nJob);
					else
					{
						str.Format("[%s] PLC Request Off!! OK Signal Ignore", pMain->vt_job_info[nJob].get_job_name());
						::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					}
				}

				//pMain->m_nRetryCount[nJob] = 0;
				//pMain->resetProcessStartFlag(nJob);

				if (nMethod == CLIENT_TYPE_PANEL_EXIST_INSP || nMethod == CLIENT_TYPE_PCB_DISTANCE_INSP || 
					nMethod == CLIENT_TYPE_ASSEMBLE_INSP || nMethod == CLIENT_TYPE_SCAN_INSP || 
					nMethod == CLIENT_TYPE_FILM_INSP || nMethod == CLIENT_TYPE_NOZZLE_SIDE_VIEW)
				{
					// kbj 21.03.05
					//pMain->SaveResultImageInspection(TRUE, nJob, pMain->m_bRetryOkNg[nJob]);
					//pMain->drawInspectionDistancePos(nJob);
					//pMain->save_result_insp_image(TRUE, nJob, pMain->m_bRetryOkNg[nJob]);
					pMain->draw_inspection(nJob);
					pMain->draw_calib_direction(nJob, FORM_MAIN);  // 2022-01-31 kbj 
					// KBJ 2022-07-18 캡처저장시 필요하에 이미지 저장버퍼 위치 수정
					pMain->save_result_insp_image(TRUE, nJob, pMain->m_bRetryOkNg[nJob]);
#ifdef _DATA_BASE
					//Tkyuha 2021-12-21 DataBase에 저장
					if (nMethod == CLIENT_TYPE_FILM_INSP)
					{
						//HSJ 2022-01-08고객요청으로 필름검사 기준점(Center,Left,Right)다 표시할 수 있도록
						for (int i = 0; i < 3; i++)
						{
							_result._x[i] = pMain->vt_result_info[nJob].pf_film_insp_data.dist_lx[i];
							_result._y[i] = pMain->vt_result_info[nJob].pf_film_insp_data.dist_ly[i];
							
						}
						//HTK 2022-06-29 절대값 표시에서 Spec과 차이값 표시로 변경
						double lx = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(0); //lx spec
						double ly = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(2); //ly spec
						double rx = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(1); //rx spec
						double ry = pMain->vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(3); //ry spec

						_result._r1 = lx - pMain->vt_result_info[nJob].pf_film_insp_data.dist_lx[1];
						_result._r2 = ly - pMain->vt_result_info[nJob].pf_film_insp_data.dist_ly[1];
						_result._r3 = rx - pMain->vt_result_info[nJob].pf_film_insp_data.dist_rx[2];
						_result._r4 = ry - pMain->vt_result_info[nJob].pf_film_insp_data.dist_ry[2];
						_result._r5 = pMain->vt_result_info[nJob].pf_film_insp_data.dist_lx[0];
						_result._r6 = pMain->vt_result_info[nJob].pf_film_insp_data.dist_rx[0];
					}
#endif
				}
				else
				{
					//pMain->save_result_image(TRUE, nJob, pMain->m_bRetryOkNg[nJob]);			// Image 저장
					pMain->drawMarkPos(nJob);													// Draw Search Mark Info
					pMain->draw_align_revision(nJob, nRet);
					// KBJ 2022-07-18 캡처저장시 필요하에 이미지 저장버퍼 위치 수정
					
					pMain->draw_calib_direction(nJob, FORM_MAIN);  // 2022-01-31 kbj 
					pMain->save_result_image(TRUE, nJob, pMain->m_bRetryOkNg[nJob]);			// Image 저장

#ifdef _DATA_BASE					
					//Tkyuha 2021-12-21 DataBase에 저장
					//HTK 2022-06-29 X,Y,T 보정값 저장
					//KJH 2022-06-29 Nozzle Align 분기 필요함 (X,Y,Z,T)
					_result._r1 = pMain->m_dbRevisionData[nJob][AXIS_X];
					_result._r2 = pMain->m_dbRevisionData[nJob][AXIS_Y];
					_result._r3 = pMain->m_dbRevisionData[nJob][AXIS_T];
#endif
				}

				// hsj 2022-02-12 확인중
				::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)nJob);
				::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(TRUE, nJob));
				::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(nJob));

				//KJH_LOG_OK
				pMain->write_process_log(TRUE, nJob);

				::SendMessageA(pMain->m_hWnd, WM_VIEW_CONTROL, MSG_MD_INC_COUNT, TRUE);						// 생산량 갱신
				::SendMessageA(pMain->m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_JUDGE, 1);		// Judge 갱신

				pMain->set_viewer_judge_ok(nJob);

				//kbj 위치수정
				pMain->resetProcessStartFlag(nJob);
				pMain->m_nRetryCount[nJob] = 0;

				pMain->m_bProcessResult[nJob] = TRUE;
#ifdef _DATA_BASE
				//Tkyuha 2021-12-21 DataBase에 저장
				pMain->m_dbResultDataBase.insertResultDataBase(_result);
#endif
				str.Format("[%s] Process OK", pMain->vt_job_info[nJob].get_job_name());
				::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

			}
			else if (nRet == 2)	// NG
			{
#ifdef _DATA_BASE
				//Tkyuha 2021-12-21 DataBase에 저장
				_st_SUM_RESULT_DATA _result;
				memset(&_result, 0, sizeof(_st_SUM_RESULT_DATA));
				_result._bok = false; _result._bng = true;  _result._jobID = nJob;
#endif
				if (nMethod == CLIENT_TYPE_PANEL_EXIST_INSP || nMethod == CLIENT_TYPE_PCB_DISTANCE_INSP || 
					nMethod == CLIENT_TYPE_ASSEMBLE_INSP || nMethod == CLIENT_TYPE_SCAN_INSP || 
					nMethod == CLIENT_TYPE_FILM_INSP || nMethod == CLIENT_TYPE_NOZZLE_SIDE_VIEW)
				{
					if (pMain->m_nInspRequestRead[nJob])		pMain->fnProcessCheckNG(nJob);
					else
					{
						str.Format("[%s] PLC Request Off!! NG Signal Ignore", pMain->vt_job_info[nJob].get_job_name());
						::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					}
				}
				else
				{
					if (pMain->m_nAlignRequestRead[nJob])		pMain->fnProcessCheckNG(nJob);
					else
					{
						str.Format("[%s] PLC Request Off!! NG Signal Ignore", pMain->vt_job_info[nJob].get_job_name());
						::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
					}
				}

				//pMain->resetProcessStartFlag(nJob);
				//pMain->m_nRetryCount[nJob] = 0;

				if (nMethod == CLIENT_TYPE_PANEL_EXIST_INSP || nMethod == CLIENT_TYPE_PCB_DISTANCE_INSP ||
					nMethod == CLIENT_TYPE_ASSEMBLE_INSP || nMethod == CLIENT_TYPE_SCAN_INSP || 
					nMethod == CLIENT_TYPE_FILM_INSP || nMethod == CLIENT_TYPE_NOZZLE_SIDE_VIEW)
				{
					// kbj 21.03.05
					//pMain->SaveResultImageInspection(FALSE, nJob, FALSE);
					//pMain->drawInspectionDistancePos(nJob);
					//pMain->save_result_insp_image(FALSE, nJob, FALSE);
					pMain->draw_inspection(nJob);
					pMain->draw_calib_direction(nJob, FORM_MAIN);  // 2022-01-31 kbj 
					// KBJ 2022-07-18 캡처저장시 필요하에 이미지 저장버퍼 위치 수정
					pMain->save_result_insp_image(FALSE, nJob, FALSE);
				}
				else
				{
					//pMain->save_result_image(FALSE, nJob);
					pMain->drawMarkPos(nJob);								// Draw Search Mark Info
					pMain->draw_align_revision(nJob, nRet);
					pMain->draw_calib_direction(nJob, FORM_MAIN);  // 2022-01-31 kbj 
					// KBJ 2022-07-18 캡처저장시 필요하에 이미지 저장버퍼 위치 수정
					pMain->save_result_image(FALSE, nJob);
				}

				// HSJ 2022-02-14 확인중
				::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)nJob);
				::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_JUDGE_JOB, MAKELPARAM(FALSE, nJob));
				::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_UPDATE_ALIGN_RESULT, int(nJob));

				//KJH_LOG_NG
				pMain->write_process_log(FALSE, nJob);

				::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_RESET_RESULT_LIST, (LPARAM)nJob);
				::SendMessageA(pMain->m_hWnd, WM_VIEW_CONTROL, MSG_MD_INC_COUNT, FALSE);						// 생산량 갱신
				::SendMessageA(pMain->m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_JUDGE, 0);

				pMain->set_viewer_judge_ng(nJob);

				//kbj 위치수정
				pMain->resetProcessStartFlag(nJob);
				pMain->m_nRetryCount[nJob] = 0;

				pMain->m_bProcessResult[nJob] = FALSE;
#ifdef _DATA_BASE
				//Tkyuha 2021-12-21 DataBase에 저장
				pMain->m_dbResultDataBase.insertResultDataBase(_result);
#endif
				str.Format("[%s] Process NG", pMain->vt_job_info[nJob].get_job_name());
				::SendMessageA(pMain->m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
			}

		}

		::WaitForSingleObject(pMain->m_hDummyEvent, 50);
	}
#endif

	pMain->m_bThreadEndFlag = FALSE;
	TRACE(_T("Thread_Process() Thread End\n"));

	return 0;
}

void CLET_AlignClientDlg::set_viewer_judge_ok(int nJob)
{
	CString str_temp;
	int algo_method = vt_job_info[nJob].algo_method;
	CFormMainView *pFormMain = (CFormMainView *)m_pForm[FORM_MAIN];
	
	switch (algo_method) 
	{
		case CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN:	set_viewer_judge_2cam_2shot_align(nJob, TRUE);		break;
		case CLIENT_TYPE_PCB_DISTANCE_INSP:		set_viewer_judge_pcb_distance_insp(nJob, TRUE);		break;
		case CLIENT_TYPE_ASSEMBLE_INSP:			set_viewer_judge_assemble_insp(nJob, TRUE);			break;
		case CLIENT_TYPE_SCAN_INSP:             set_viewer_judge_scan_insp(nJob, TRUE);            break;
		case CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP: set_viewer_judge_scratch_insp(nJob, TRUE); break;	// YCS 2022-11-18 스크래치 뷰어도 OK, NG 갱신하도록 추가
		default:								set_viewer_judge_infra(nJob, TRUE);					break;
	}
}
void CLET_AlignClientDlg::set_viewer_judge_ng(int nJob)
{
	int algo_method = vt_job_info[nJob].algo_method;

	switch (algo_method) 
	{
		case CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN:	set_viewer_judge_2cam_2shot_align(nJob, FALSE);		break;
		case CLIENT_TYPE_PCB_DISTANCE_INSP:		set_viewer_judge_pcb_distance_insp(nJob, FALSE);	break;
		case CLIENT_TYPE_ASSEMBLE_INSP:			set_viewer_judge_assemble_insp(nJob, FALSE);		break;
		case CLIENT_TYPE_SCAN_INSP:             set_viewer_judge_scan_insp(nJob, FALSE);            break; 
		case CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP: set_viewer_judge_scratch_insp(nJob, FALSE); break;	// YCS 2022-11-18 스크래치 뷰어도 OK, NG 갱신하도록 추가
		default:								set_viewer_judge_infra(nJob, FALSE);				break;
	}
}
void CLET_AlignClientDlg::set_viewer_judge_scan_insp(int nJob, BOOL bJudge)
{
	CString str_temp;
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	for (int i = 0; i < vt_job_info[nJob].num_of_camera; i++)
	{
		if (i < vt_job_info[nJob].viewer_index.size())
		{
			if (bJudge)
			{
				int viewer = vt_job_info[nJob].viewer_index[i]+ m_nSeqScanInspGrabCount[nJob]-1;
				pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
			}
			else
			{
				int viewer = vt_job_info[nJob].viewer_index[i] + m_nSeqScanInspGrabCount[nJob] - 1;
				if (vt_result_info[nJob].each_Judge[i][0])	pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
				else										pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(FALSE);
			}
		}
		else
		{
			str_temp.Format("[%s] set_viewer_judge_%s - viewer index invalid!!", vt_job_info[nJob].get_job_name(), bJudge ? "ok" : "ng");
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str_temp);
		}
	}

	::SendMessageA(theApp.m_pFrame->m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_PA_JUDGE_DISPLAY, MAKELPARAM(nJob, bJudge));
}
void CLET_AlignClientDlg::set_viewer_judge_infra(int nJob, BOOL bJudge)
{
	CString str_temp;
	CFormMainView *pFormMain = (CFormMainView *)m_pForm[FORM_MAIN];

	for (int i = 0; i < vt_job_info[nJob].num_of_camera; i++)
	{
		if (i < vt_job_info[nJob].viewer_index.size())
		{
			if (bJudge)
			{
				int viewer = vt_job_info[nJob].viewer_index[i];
				pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
			}
			else
			{
				int viewer = vt_job_info[nJob].viewer_index[i];
				if (vt_result_info[nJob].each_Judge[i][0])	pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
				else										pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(FALSE);
			}
		}
		else
		{
			str_temp.Format("[%s] set_viewer_judge_%s - viewer index invalid!!", vt_job_info[nJob].get_job_name(), bJudge ? "ok" : "ng");
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str_temp);
		}
	}
}
void CLET_AlignClientDlg::set_viewer_judge_2cam_2shot_align(int nJob, BOOL bJudge)
{
	CString str_temp;
	CFormMainView *pFormMain = (CFormMainView *)m_pForm[FORM_MAIN];

	for (int i = 0; i < vt_job_info[nJob].num_of_camera; i++)
	{
		if ((i * 2 + 1) < vt_job_info[nJob].viewer_index.size())
		{
			if (bJudge)
			{
				int viewer = vt_job_info[nJob].viewer_index[i * 2 + 0];
				pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);

				viewer = vt_job_info[nJob].viewer_index[i * 2 + 1];
				pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
			}
			else
			{
				int viewer = vt_job_info[nJob].viewer_index[i * 2 + 0];
				if (vt_result_info[nJob].each_Judge[i][0])	pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
				else										pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(FALSE);

				viewer = vt_job_info[nJob].viewer_index[i * 2 + 1];
				if (vt_result_info[nJob].each_Judge[i][1])	pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
				else										pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(FALSE);
			}
		}
		else
		{
			str_temp.Format("[%s] set_viewer_judge_%s - viewer index invalid!!", vt_job_info[nJob].get_job_name(), bJudge ? "ok" : "ng");
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str_temp);
		}
	}
}
void CLET_AlignClientDlg::set_viewer_judge_pcb_distance_insp(int nJob, BOOL bJudge)
{
	CString str_temp;
	CFormMainView *pFormMain = (CFormMainView *)m_pForm[FORM_MAIN];

	for (int nPos = 0; nPos < m_nSeqTotalInspGrabCount; nPos++)
	{
		for (int i = 0; i < vt_job_info[nJob].num_of_camera; i++)
		{
			if ((i * 4 + nPos) < vt_job_info[nJob].viewer_index.size())
			{
				if (bJudge)
				{
					int viewer = vt_job_info[nJob].viewer_index[i * 4 + nPos];
					pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
				}
				else
				{
					int real_cam = vt_job_info[nJob].camera_index[i];
					int viewer = vt_job_info[nJob].viewer_index[i * 4 + nPos];
					if (m_stInsp_DistanceResult[real_cam][nPos].bNG)		pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(FALSE);
					else													pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
				}
			}
			else
			{
				str_temp.Format("[%s] set_viewer_judge_%s - viewer index invalid!!", vt_job_info[nJob].get_job_name(), bJudge ? "ok" : "ng");
				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str_temp);
			}
		}
	}
}
void CLET_AlignClientDlg::set_viewer_judge_assemble_insp(int nJob, BOOL bJudge)
{
	CString str_temp;
	CFormMainView *pFormMain = (CFormMainView *)m_pForm[FORM_MAIN];
	for (int i = 0; i < vt_job_info[nJob].num_of_camera; i++)
	{
		if (i < vt_job_info[nJob].viewer_index.size())
		{
			if (bJudge)
			{
				int viewer = vt_job_info[nJob].viewer_index[i];
				pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
			}
			else
			{
				int real_cam = vt_job_info[nJob].camera_index[i];
				int viewer = vt_job_info[nJob].viewer_index[i];
				if (m_stInsp_DistanceResult[real_cam][0].bNG)		pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(FALSE);
				else												pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
			}
		}
		else
		{
			str_temp.Format("[%s] set_viewer_judge_%s - viewer index invalid!!", vt_job_info[nJob].get_job_name(), bJudge ? "ok" : "ng");
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str_temp);
		}
	}
}

void CLET_AlignClientDlg::OnUpdateTime()
{
	Delay(30);
	CPaneHeader* pHeader = (CPaneHeader*)m_pPaneHeader;
	pHeader->OnUpdateTime();
}
void CLET_AlignClientDlg::SetLightBright(int nCtrl,int nChannel, int nValue)
{
	if (m_stLightCtrlInfo.nType[nCtrl] == LTYPE_LLIGHT_LPW_SOCK || m_stLightCtrlInfo.nType[nCtrl] == LTYPE_LLIGHT_LPC_COT_SOCK)
	{
		m_LightSock[nCtrl].set_light_value(nChannel, nValue);
	}
	//21.01.02
	else if (m_stLightCtrlInfo.nType[nCtrl] == LTYPE_LLIGHT_LPW_232)
	{
		m_Light[nCtrl].set_light_value(nChannel, nValue);
	}
	else
	{
		m_Light[nCtrl].setBrightness(nChannel, nValue);
	}
}
void CLET_AlignClientDlg::OnClose()
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	if (m_thdTime.IsDone() == false)
		m_thdTime.Stop();

	for (int i = 0; i < MAX_LIGHT_CTRL; i++)
	{
		m_Light[i].GetComm().ClosePort();
		m_LightSock[i].CloseSockets();
	}

	((CPaneAuto* )m_pPane[PANE_AUTO])->SaveRefDataCSV();

	m_ELB_vtMaskContour.clear();
	// 원래는 모든 쓰레드가 종료 될때 까지 기다려야 하나, 누군가가 기다리는 부분 삭제해서 일단 Sleep........
	Sleep(1000);
	CDialogEx::OnClose();
}

void CLET_AlignClientDlg::calc_sub_mark_offset_2cam_1pos(int algo, int cam_pos_type)
{

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);
#else
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;
#endif

	CString str;
	int cam_no[MAX_CAMERA] = { 0, };
	double mark_offset_x[MAX_CAMERA] = { 0, };
	double mark_offset_y[MAX_CAMERA] = { 0, };
	int mark_find_index[MAX_CAMERA] = { 0, };

	double mark_offset_x_world[MAX_CAMERA] = { 0, };
	double mark_offset_y_world[MAX_CAMERA] = { 0, };

	double mark_x[MAX_CAMERA] = { 0, };
	double mark_y[MAX_CAMERA] = { 0, };
	double mark_x_world[MAX_CAMERA] = { 0, };
	double mark_y_world[MAX_CAMERA] = { 0, };
	double final_offset_x_world[MAX_CAMERA] = { 0, };
	double final_offset_y_world[MAX_CAMERA] = { 0, };
	double final_offset_x_pixel[MAX_CAMERA] = { 0, };
	double final_offset_y_pixel[MAX_CAMERA] = { 0, };
	double rotate_x[MAX_CAMERA] = { 0, };
	double rotate_y[MAX_CAMERA] = { 0, };

	cam_no[0] = camBuf.at(0);
	cam_no[1] = camBuf.at(1);
	
#ifndef JOB_INFO
	rotate_x[0] = GetMachine(algo).getRotateX(cam_no[0], 0);
	rotate_y[0] = GetMachine(algo).getRotateY(cam_no[0], 0);
	rotate_x[1] = GetMachine(algo).getRotateX(cam_no[1], 0);
	rotate_y[1] = GetMachine(algo).getRotateY(cam_no[1], 0);

	mark_find_index[0] = GetMatching(algo).getFindInfo(cam_no[0], 0).GetFoundPatternNum();
	mark_find_index[1] = GetMatching(algo).getFindInfo(cam_no[1], 0).GetFoundPatternNum();

	// 마크 찾은 위치
	mark_x[0] = GetMatching(algo).getFindInfo(cam_no[0], 0).GetXPos();
	mark_y[0] = GetMatching(algo).getFindInfo(cam_no[0], 0).GetYPos();
	mark_x[1] = GetMatching(algo).getFindInfo(cam_no[1], 0).GetXPos();
	mark_y[1] = GetMatching(algo).getFindInfo(cam_no[1], 0).GetYPos();

	// 마크로 찾은 인덱스의 offset  부호 반전하여 가져 와야 됨.
	// 계산할때 반전 시키기 때문에
	mark_offset_x[0] = -GetMatching(algo).getMarkOffsetX(cam_no[0], 0, mark_find_index[0]);
	mark_offset_y[0] = -GetMatching(algo).getMarkOffsetY(cam_no[0], 0, mark_find_index[0]);
	mark_offset_x[1] = -GetMatching(algo).getMarkOffsetX(cam_no[1], 0, mark_find_index[1]);
	mark_offset_y[1] = -GetMatching(algo).getMarkOffsetY(cam_no[1], 0, mark_find_index[1]);
#else
	rotate_x[0] = GetMachine(algo).getRotateX(0, 0);
	rotate_y[0] = GetMachine(algo).getRotateY(0, 0);
	rotate_x[1] = GetMachine(algo).getRotateX(1, 0);
	rotate_y[1] = GetMachine(algo).getRotateY(1, 0);

	mark_find_index[0] = GetMatching(algo).getFindInfo(0, 0).GetFoundPatternNum();
	mark_find_index[1] = GetMatching(algo).getFindInfo(1, 0).GetFoundPatternNum();

	// 마크 찾은 위치
	mark_x[0] = GetMatching(algo).getFindInfo(0, 0).GetXPos();
	mark_y[0] = GetMatching(algo).getFindInfo(0, 0).GetYPos();
	mark_x[1] = GetMatching(algo).getFindInfo(1, 0).GetXPos();
	mark_y[1] = GetMatching(algo).getFindInfo(1, 0).GetYPos();

	// 마크로 찾은 인덱스의 offset  부호 반전하여 가져 와야 됨.
	// 계산할때 반전 시키기 때문에
	mark_offset_x[0] = -GetMatching(algo).getMarkOffsetX(0, 0, mark_find_index[0]);
	mark_offset_y[0] = -GetMatching(algo).getMarkOffsetY(0, 0, mark_find_index[0]);
	mark_offset_x[1] = -GetMatching(algo).getMarkOffsetX(1, 0, mark_find_index[1]);
	mark_offset_y[1] = -GetMatching(algo).getMarkOffsetY(1, 0, mark_find_index[1]);
#endif

	GetMachine(algo).PixelToWorld(0, 0, mark_offset_x[0], mark_offset_y[0], &mark_offset_x_world[0], &mark_offset_y_world[0]);
	GetMachine(algo).PixelToWorld(1, 0, mark_offset_x[1], mark_offset_y[1], &mark_offset_x_world[1], &mark_offset_y_world[1]);
	GetMachine(algo).PixelToWorld(0, 0, mark_x[0], mark_y[0], &mark_x_world[0], &mark_y_world[0]);
	GetMachine(algo).PixelToWorld(1, 0, mark_x[1], mark_y[1], &mark_x_world[1], &mark_y_world[1]);

	double dbDist = 0.0;
	double dbDiagonal = 0.0;

	//if (cam_pos_type == CAM_HORI)
	//{
	//	dbDist = mark_y[0] - mark_y[1];
	//	dbDiagonal = fabs(rotate_x[0]) + fabs(rotate_x[1]);// m_dbPatternPitchX;
	//}
	//else
	//{
	//	dbDist = mark_x[0] - mark_x[1];
	//	dbDiagonal = fabs(rotate_y[0]) + fabs(rotate_y[1]);// m_dbPatternPitchX;
	//}

	if (cam_pos_type == CAM_HORI)
	{
		dbDist = (mark_y[0] + mark_offset_y[0]) - (mark_y[1] + mark_offset_y[1]);
		dbDiagonal = fabs(rotate_x[0] + mark_offset_x[0]) + fabs(rotate_x[1] + mark_offset_x[1]);
	}
	else
	{
		dbDist = (mark_x[0] + mark_offset_x[0]) - (mark_x[1] + mark_offset_x[1]);
		dbDiagonal = fabs(rotate_y[0] + mark_offset_y[0]) + fabs(rotate_y[1] + mark_offset_y[1]);
	}
	
	double theta = asin(dbDist / dbDiagonal);
	
	// 로봇 좌표계 상의 offset 계산
	final_offset_x_world[0] = mark_offset_x_world[0] * cos(theta) - mark_offset_y_world[0] * sin(theta);
	final_offset_y_world[0] = mark_offset_x_world[0] * sin(theta) + mark_offset_y_world[0] * cos(theta);
	final_offset_x_world[1] = mark_offset_x_world[1] * cos(theta) - mark_offset_y_world[1] * sin(theta);
	final_offset_y_world[1] = mark_offset_x_world[1] * sin(theta) + mark_offset_y_world[1] * cos(theta);

	// 이미지 좌표계 상의 offset 계산
	final_offset_x_pixel[0] = mark_offset_x[0] * cos(theta) - mark_offset_y[0] * sin(theta);
	final_offset_y_pixel[0] = mark_offset_x[0] * sin(theta) + mark_offset_y[0] * cos(theta);
	final_offset_x_pixel[1] = mark_offset_x[1] * cos(theta) - mark_offset_y[1] * sin(theta);
	final_offset_y_pixel[1] = mark_offset_x[1] * sin(theta) + mark_offset_y[1] * cos(theta);
	

	GetMatching(algo).setMarkOffsetX(0, 0, mark_find_index[0], final_offset_x_pixel[0]);
	GetMatching(algo).setMarkOffsetY(0, 0, mark_find_index[0], final_offset_y_pixel[0]);
	GetMatching(algo).setMarkOffsetX(1, 0, mark_find_index[1], final_offset_x_pixel[1]);
	GetMatching(algo).setMarkOffsetY(1, 0, mark_find_index[1], final_offset_y_pixel[1]);

	GetPrealign(algo).set_mark_offset_x(0, final_offset_x_world[0]);
	GetPrealign(algo).set_mark_offset_y(0, final_offset_y_world[0]);
	GetPrealign(algo).set_mark_offset_x(1, final_offset_x_world[1]);
	GetPrealign(algo).set_mark_offset_y(1, final_offset_y_world[1]);
}
void CLET_AlignClientDlg::calc_sub_mark_offset_4cam_1pos(int algo)
{
	/*
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);

	CString str;
	int cam_no[4] = { 0, };
	cam_no[0] = camBuf.at(0);
	*/
}
void CLET_AlignClientDlg::calc_sub_mark_offset_1cam_2pos(int algo)
{
	/*
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);
	
	CString str;
	int cam_no[4] = { 0, };
	cam_no[0] = camBuf.at(0);
	*/
}

BOOL CLET_AlignClientDlg::calc_lcheck_1cam_1shot(int algo, BOOL prealign_test)
{
	BOOL bError = FALSE;

	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;

	CString str;
	int nCam = 0;
	int nPos = 0;
	double pixel_x[2] = { 0, };
	double pixel_y[2] = { 0, };
	double world_x[2] = { 0, };
	double world_y[2] = { 0, };

	pixel_x[0] = GetMatching(algo).getFindInfo(nCam, nPos + 0).GetXPos();
	pixel_y[0] = GetMatching(algo).getFindInfo(nCam, nPos + 0).GetYPos();
	pixel_x[1] = GetMatching(algo).getFindInfo(nCam, nPos + 1).GetXPos();
	pixel_y[1] = GetMatching(algo).getFindInfo(nCam, nPos + 1).GetYPos();

	GetMachine(algo).PixelToWorld(0, 0, pixel_x[0], pixel_y[0], &world_x[0], &world_y[0]);
	GetMachine(algo).PixelToWorld(0, 0, pixel_x[1], pixel_y[1], &world_x[1], &world_y[1]);

	double dx = world_x[1] - world_x[0];
	double dy = world_y[1] - world_y[0];
	double dist = sqrt(dx * dx + dy * dy);

	dist += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(0);
	
	m_dLcheckCurrentValue[algo] = dist;

	double lcheckscale = vt_job_info[algo].model_info.getAlignInfo().getLCheckScale();

	dist *= lcheckscale;

	double dist_tor = vt_job_info[algo].model_info.getAlignInfo().getLCheckTor();
	double dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecX();

	int target_dir = vt_job_info[algo].model_info.getAlignInfo().getAlignmentTargetDir();	// vertical or horizontal

	if (target_dir == 1)	// vertical
		dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecY();

	str.Format("length : %.3f", dist);
	m_dist = dist;

	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	m_dbLCheck[algo][0] = dist;
	m_dbLCheckSpec[algo][0] = dist_spec;

	if (fabs(dist_spec - dist) > dist_tor)
	{
		str.Format("L Check NG!!  limit : %.3f, tor : %.3f", dist_spec, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist;
		vt_result_info[algo].each_Judge[0][0] = FALSE;
		bError = TRUE;
	}

	return bError;
}

BOOL CLET_AlignClientDlg::calc_lcheck_1cam_1shot_2object(int algo, BOOL prealign_test)
{
	BOOL bError = FALSE;
	BOOL bError1 = FALSE; 
	BOOL bError2 = FALSE;

	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;

	CString str;
	int nCam = 0;
	int nPos = 0;
	double pixel_x[4] = { 0, };
	double pixel_y[4] = { 0, };
	double world_x[4] = { 0, };
	double world_y[4] = { 0, };

	double xres = GetMachine(algo).getCameraResolutionX(nCam, 0);
	double yres = GetMachine(algo).getCameraResolutionY(nCam, 0);

	pixel_x[0] = GetMatching(algo).getFindInfo(nCam, 0).GetXPos();
	pixel_y[0] = GetMatching(algo).getFindInfo(nCam, 0).GetYPos();
	pixel_x[1] = GetMatching(algo).getFindInfo(nCam, 1).GetXPos();
	pixel_y[1] = GetMatching(algo).getFindInfo(nCam, 1).GetYPos();

	pixel_x[2] = GetMatching(algo).getFindInfo(nCam, 2).GetXPos();
	pixel_y[2] = GetMatching(algo).getFindInfo(nCam, 2).GetYPos();
	pixel_x[3] = GetMatching(algo).getFindInfo(nCam, 3).GetXPos();
	pixel_y[3] = GetMatching(algo).getFindInfo(nCam, 3).GetYPos();

	/*GetMachine(algo).PixelToWorld(0, 0, pixel_x[0], pixel_y[0], &world_x[0], &world_y[0]);
	GetMachine(algo).PixelToWorld(0, 0, pixel_x[1], pixel_y[1], &world_x[1], &world_y[1]);
	GetMachine(algo).PixelToWorld(0, 0, pixel_x[2], pixel_y[2], &world_x[2], &world_y[2]);
	GetMachine(algo).PixelToWorld(0, 0, pixel_x[3], pixel_y[3], &world_x[3], &world_y[3]);*/

	int target_dir = vt_job_info[algo].model_info.getAlignInfo().getAlignmentTargetDir();	// vertical or horizontal
	double dist_tor = vt_job_info[algo].model_info.getAlignInfo().getLCheckTor();
	double dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecX();
	if (target_dir == 1)	// vertical
		dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecY();

	double lcheckscale = vt_job_info[algo].model_info.getAlignInfo().getLCheckScale();

	// object 1
	//double dx = world_x[1] - world_x[0];
	//double dy = world_y[1] - world_y[0];
	double dx = xres * (pixel_x[1] - pixel_x[0]);
	double dy = yres * (pixel_y[1] - pixel_y[0]);
	double dist = sqrt(dx * dx + dy * dy);
	dist += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(0);

	m_dLcheckCurrentValue[algo] = dist;

	dist *= lcheckscale;

	// object 2
	//double dx2 = world_x[3] - world_x[2];
	//double dy2 = world_y[3] - world_y[2];
	double dx2 = xres * (pixel_x[3] - pixel_x[2]);
	double dy2 = yres * (pixel_y[3] - pixel_y[2]);
	double dist2 = sqrt(dx2 * dx2 + dy2 * dy2);
	dist2 += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(0);

	dist2 *= lcheckscale;

	m_dbLCheck[algo][0] = dist;
	m_dbLCheck[algo][1] = dist2;

	m_dbLCheckSpec[algo][0] = dist_spec;
	m_dbLCheckSpec[algo][1] = dist_spec;

	str.Format("[1] length : %.3f", dist);
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	str.Format("[2] length : %.3f", dist2);
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	if (fabs(dist_spec - dist) > dist_tor)
	{
		str.Format("[1] L Check NG!!  limit : %.3f, tor : %.3f", dist_spec, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist;
		vt_result_info[algo].each_Judge[0][0] = FALSE;
		bError1 = TRUE;
	}

	if (fabs(dist_spec - dist2) > dist_tor)
	{
		str.Format("[2] L Check NG!!  limit : %.3f, tor : %.3f", dist_spec, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist;
		vt_result_info[algo].each_Judge[0][0] = FALSE;
		bError2 = TRUE;
	}

	if (bError1 && bError2) bError = TRUE;

	return bError;
}

BOOL CLET_AlignClientDlg::calc_lcheck_1cam_2pos(int algo, BOOL prealign_test)
{
	BOOL bError = FALSE;

	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;

	CString str;
	double pixel_x[2] = { 0, };
	double pixel_y[2] = { 0, };
	double world_x[2] = { 0, };
	double world_y[2] = { 0, };
	double rotate_x[2] = { 0, };
	double rotate_y[2] = { 0, };
	double absolute_x[2] = { 0, };
	double absolute_y[2] = { 0, };

	rotate_x[0] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterX(0, 0);
	rotate_y[0] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterY(0, 0);
	rotate_x[1] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterX(0, 1);
	rotate_y[1] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterY(0, 1);

	pixel_x[0] = GetMatching(algo).getFindInfo(0, 0).GetXPos();
	pixel_y[0] = GetMatching(algo).getFindInfo(0, 0).GetYPos();
	pixel_x[1] = GetMatching(algo).getFindInfo(0, 1).GetXPos();
	pixel_y[1] = GetMatching(algo).getFindInfo(0, 1).GetYPos();

	//GetMachine(algo).PixelToWorld(0, 0, pixel_x[0], pixel_y[0], &world_x[0], &world_y[0]);
	//GetMachine(algo).PixelToWorld(0, 0, pixel_x[1], pixel_y[1], &world_x[1], &world_y[1]);

	//absolute_x[0] = rotate_x[0] - world_x[0];
	//absolute_y[0] = rotate_y[0] - world_y[0];
	//absolute_x[1] = rotate_x[1] - world_x[1];
	//absolute_y[1] = rotate_y[1] - world_y[1];

	//double dx = absolute_x[1] - absolute_x[0];
	//double dy = absolute_y[1] - absolute_y[0];
	//double dist = sqrt(dx * dx + dy * dy);
	double dist = abs(pixel_x[0] * GetMachine(algo).getCameraResolutionX(0, 0) - pixel_x[1] * GetMachine(algo).getCameraResolutionX(0, 1));

	dist += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(0);

	m_dLcheckCurrentValue[algo] = dist;

	double dist_tor = vt_job_info[algo].model_info.getAlignInfo().getLCheckTor();
	double dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecX();

	double lcheckscale = vt_job_info[algo].model_info.getAlignInfo().getLCheckScale();

	dist *= lcheckscale;

	int target_dir = vt_job_info[algo].model_info.getAlignInfo().getAlignmentTargetDir();	// vertical or horizontal

	if (target_dir == 1)	// vertical
		dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecY();

	str.Format("length : %.3f", dist);
	m_dist = dist;
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	m_dbLCheck[algo][0] = dist;
	
	if (fabs(dist_spec - dist) > dist_tor)
	{
		str.Format("L Check NG!!  limit : %.3f, tor : %.3f", dist_spec, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist;
		vt_result_info[algo].each_Judge[0][0] = FALSE;
		bError = TRUE;
	}

	return bError;
}

BOOL CLET_AlignClientDlg::calc_lcheck_2cam_1pos(int algo, BOOL prealign_test)
{
	BOOL bError = FALSE;

	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;

	CString str;
	double pixel_x[4] = { 0, };
	double pixel_y[4] = { 0, };
	double world_x[4] = { 0, };
	double world_y[4] = { 0, };
	double rotate_x[4] = { 0, };
	double rotate_y[4] = { 0, };
	double absolute_x[4] = { 0, };
	double absolute_y[4] = { 0, };

	int LcheckMethode = vt_job_info[algo].model_info.getAlignInfo().getLCheckReference();
	//KJH 2022-04-22 CameraDistance 방식 삭제
	//double Cameradistance = vt_job_info[algo].model_info.getAlignInfo().getLCheckScale();

	for (int i = 0; i < camCount; i++)
	{
		rotate_x[i] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterX(i, 0);
		rotate_y[i] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterY(i, 0);

		pixel_x[i] = GetMatching(algo).getFindInfo(i, 0).GetXPos();
		pixel_y[i] = GetMatching(algo).getFindInfo(i, 0).GetYPos();

		GetMachine(algo).PixelToWorld(i, 0, pixel_x[i], pixel_y[i], &world_x[i], &world_y[i]);
		
		absolute_x[i] = rotate_x[i] - world_x[i];
		absolute_y[i] = rotate_y[i] - world_y[i];
	}

	double dx, dy = 0;

	if (LcheckMethode == 0)
	{
		//Rotate distance 방식
		dx = absolute_x[1] - absolute_x[0];
		dy = absolute_y[1] - absolute_y[0];
	}
	//KJH 2022-04-22 CameraDistance 방식 삭제
	//else
	//{
	//	//Camera distance 방식
	//	dx = world_x[1] - world_x[0];
	//	dx += Cameradistance;
	//	dy = world_y[1] - world_y[0];
	//}

	double dist = sqrt(dx * dx + dy * dy);

	dist += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(0);
	
	m_dLcheckCurrentValue[algo] = dist;

	double dist_tor = vt_job_info[algo].model_info.getAlignInfo().getLCheckTor();
	double dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecX();

	double lcheckscale = vt_job_info[algo].model_info.getAlignInfo().getLCheckScale();

	dist *= lcheckscale;

	int target_dir = vt_job_info[algo].model_info.getAlignInfo().getAlignmentTargetDir();	// vertical or horizontal

	if(target_dir == 1 )	// vertical
		dist_spec = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecY();

	str.Format("length : %.3f", dist);
	m_dist = dist;
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	m_dbLCheck[algo][0] = dist;
	m_dbLCheckSpec[algo][0] = dist_spec;

	if (fabs(dist_spec - dist) > dist_tor)
	{
		str.Format("L Check NG!!  limit : %.3f, tor : %.3f", dist_spec, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist;

		for (int nCam = 0; nCam < camCount; nCam++)
		{
			vt_result_info[algo].each_Judge[nCam][0] = FALSE;
		}

		bError = TRUE;
	}

	return bError;
}
//tnwjddl
BOOL CLET_AlignClientDlg::calc_lcheck_4cam_1pos(int algo, BOOL prealign_test)
{
	BOOL bError = FALSE;
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;

	CString str;
	int cam_no[4] = { 0, };
	cam_no[0] = camBuf.at(0);
	cam_no[1] = camBuf.at(1);
	cam_no[2] = camBuf.at(2);
	cam_no[3] = camBuf.at(3);

	double pixel_x[4] = { 0, };
	double pixel_y[4] = { 0, };
	double world_x[4] = { 0, };
	double world_y[4] = { 0, };
	double rotate_x[4] = { 0, };
	double rotate_y[4] = { 0, };

	double absolute_x[4] = { 0, };
	double absolute_y[4] = { 0, };

	for (int i = 0; i < camCount; i++)
	{
		rotate_x[i] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterX(i, 0);
		rotate_y[i] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterY(i, 0);

		pixel_x[i] = GetMatching(algo).getFindInfo(i, 0).GetXPos();
		pixel_y[i] = GetMatching(algo).getFindInfo(i, 0).GetYPos();

		GetMachine(algo).PixelToWorld(i, 0, pixel_x[i], pixel_y[i], &world_x[i], &world_y[i]);
		absolute_x[i] = rotate_x[i] - world_x[i];
		absolute_y[i] = rotate_y[i] - world_y[i];
	}

	// 장변 끼리만 L Check 하는 걸로
	double dist_tor = vt_job_info[algo].model_info.getAlignInfo().getLCheckTor();
	double dist_specX = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecX();
	double dist_specY = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecY();	

	double dx_T = absolute_x[1] - absolute_x[0];
	double dy_T = absolute_y[1] - absolute_y[0];
	double dist_T = sqrt(dx_T * dx_T + dy_T * dy_T);
	dist_T += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(0);

	double dx_L = absolute_x[2] - absolute_x[0];
	double dy_L = absolute_y[2] - absolute_y[0];
	double dist_L = sqrt(dx_L * dx_L + dy_L * dy_L);
	dist_L += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(1);

	double dx_R = absolute_x[3] - absolute_x[1];
	double dy_R = absolute_y[3] - absolute_y[1];
	double dist_R = sqrt(dx_R * dx_R + dy_R * dy_R);
	dist_R += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(2);

	double dx_B = absolute_x[3] - absolute_x[2];
	double dy_B = absolute_y[3] - absolute_y[2];
	double dist_B = sqrt(dx_B * dx_B + dy_B * dy_B);
	dist_B += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(3);
	
	str.Format("top length : %.3f", dist_T);
	m_dist_T = dist_T;
	if(prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	str.Format("bottom length : %.3f", dist_B);
	m_dist_B = dist_B;
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	str.Format("right length : %.3f", dist_R);
	m_dist_R = dist_R;
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	str.Format("left length : %.3f", dist_L);
	m_dist_L = dist_L;
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	m_dbLCheck[algo][0] = m_dist_T;
	m_dbLCheck[algo][1] = m_dist_L;
	m_dbLCheck[algo][2] = m_dist_R;
	m_dbLCheck[algo][3] = m_dist_B;

	if (fabs(dist_specX - dist_T) > dist_tor)
	{
		str.Format("Top L Check NG!!  limit : %.3f, tor : %.3f", dist_specX, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist_T;

		vt_result_info[algo].each_Judge[0][0] = FALSE;
		vt_result_info[algo].each_Judge[1][0] = FALSE;

		bError = TRUE;
	}

	if (fabs(dist_specX - dist_B) > dist_tor)
	{
		str.Format("Bottom L Check NG!!  limit : %.3f, tor : %.3f", dist_specX, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist_B;

		vt_result_info[algo].each_Judge[2][0] = FALSE;
		vt_result_info[algo].each_Judge[3][0] = FALSE;

		bError = TRUE;
	}

	if (fabs(dist_specY - dist_R) > dist_tor)
	{
		str.Format("Right L Check NG!!  limit : %.3f, tor : %.3f", dist_specY, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist_R;

		vt_result_info[algo].each_Judge[1][0] = FALSE;
		vt_result_info[algo].each_Judge[3][0] = FALSE;

		bError = TRUE;
	}

	if (fabs(dist_specY - dist_L) > dist_tor)
	{
		str.Format("Left L Check NG!!  limit : %.3f, tor : %.3f", dist_specY, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist_L;

		vt_result_info[algo].each_Judge[0][0] = FALSE;
		vt_result_info[algo].each_Judge[2][0] = FALSE;

		bError = TRUE;
	}

	return bError;
}
BOOL CLET_AlignClientDlg::calc_lcheck_2cam_2pos(int algo, BOOL prealign_test)
{
	BOOL bError = FALSE;
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;

	CString str;

	double pixel_x[4] = { 0, };
	double pixel_y[4] = { 0, };
	double world_x[4] = { 0, };
	double world_y[4] = { 0, };
	double rotate_x[4] = { 0, };
	double rotate_y[4] = { 0, };

	double absolute_x[4] = { 0, };
	double absolute_y[4] = { 0, };

	for (int i = 0; i < camCount; i++)
	{
		rotate_x[i * 2 + 0] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterX(i, 0);
		rotate_y[i * 2 + 0] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterY(i, 0);
		rotate_x[i * 2 + 1] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterX(i, 1);
		rotate_y[i * 2 + 1] = vt_job_info[algo].model_info.getMachineInfo().getRotateCenterY(i, 1);



		pixel_x[i * 2 + 0] = GetMatching(algo).getFindInfo(i, 0).GetXPos();
		pixel_y[i * 2 + 0] = GetMatching(algo).getFindInfo(i, 0).GetYPos();
		pixel_x[i * 2 + 1] = GetMatching(algo).getFindInfo(i, 1).GetXPos();
		pixel_y[i * 2 + 1] = GetMatching(algo).getFindInfo(i, 1).GetYPos();

		GetMachine(algo).PixelToWorld(i, 0, pixel_x[i * 2 + 0], pixel_y[i * 2 + 0], &world_x[i * 2 + 0], &world_y[i * 2 + 0]);
		GetMachine(algo).PixelToWorld(i, 0, pixel_x[i * 2 + 1], pixel_y[i * 2 + 1], &world_x[i * 2 + 1], &world_y[i * 2 + 1]);

		absolute_x[i * 2 + 0] = rotate_x[i * 2 + 0] - world_x[i * 2 + 0];
		absolute_y[i * 2 + 0] = rotate_y[i * 2 + 0] - world_y[i * 2 + 0];
		absolute_x[i * 2 + 1] = rotate_x[i * 2 + 1] - world_x[i * 2 + 1];
		absolute_y[i * 2 + 1] = rotate_y[i * 2 + 1] - world_y[i * 2 + 1];
	}

	// 장변 끼리만 L Check 하는 걸로
	double dist_tor = vt_job_info[algo].model_info.getAlignInfo().getLCheckTor();
	double dist_specX = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecX();
	double dist_specY = vt_job_info[algo].model_info.getAlignInfo().getLCheckSpecY();

	double dx_T = absolute_x[1] - absolute_x[0];
	double dy_T = absolute_y[1] - absolute_y[0];
	double dist_T = sqrt(dx_T * dx_T + dy_T * dy_T);
	dist_T += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(0);

	double dx_L = absolute_x[2] - absolute_x[0];
	double dy_L = absolute_y[2] - absolute_y[0];
	double dist_L = sqrt(dx_L * dx_L + dy_L * dy_L);
	dist_L += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(1);

	double dx_R = absolute_x[3] - absolute_x[1];
	double dy_R = absolute_y[3] - absolute_y[1];
	double dist_R = sqrt(dx_R * dx_R + dy_R * dy_R);
	dist_R += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(2);

	double dx_B = absolute_x[3] - absolute_x[2];
	double dy_B = absolute_y[3] - absolute_y[2];
	double dist_B = sqrt(dx_B * dx_B + dy_B * dy_B);
	dist_B += vt_job_info[algo].model_info.getMachineInfo().get_lcheck_offset(3);

	str.Format("top length : %.3f", dist_T);
	m_dist_T = dist_T;
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	str.Format("bottom length : %.3f", dist_B);
	m_dist_B = dist_B;
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	str.Format("right length : %.3f", dist_R);
	m_dist_R = dist_R;
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	str.Format("left length : %.3f", dist_L);
	m_dist_L = dist_L;
	if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
	else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	m_dbLCheck[algo][0] = m_dist_T;
	m_dbLCheck[algo][1] = m_dist_L;
	m_dbLCheck[algo][2] = m_dist_R;
	m_dbLCheck[algo][3] = m_dist_B;

	m_dbLCheckSpec[algo][0] = dist_specX;
	m_dbLCheckSpec[algo][1] = dist_specY;
	m_dbLCheckSpec[algo][2] = dist_specY;
	m_dbLCheckSpec[algo][3] = dist_specX;

	if (fabs(dist_specX - dist_T) > dist_tor)
	{
		str.Format("Top L Check NG!!  limit : %.3f, tor : %.3f", dist_specX, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist_T;

		vt_result_info[algo].each_Judge[0][0] = FALSE;
		vt_result_info[algo].each_Judge[0][1] = FALSE;

		bError = TRUE;
	}

	if (fabs(dist_specX - dist_B) > dist_tor)
	{
		str.Format("Bottom L Check NG!!  limit : %.3f, tor : %.3f", dist_specX, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist_B;

		vt_result_info[algo].each_Judge[1][0] = FALSE;
		vt_result_info[algo].each_Judge[1][1] = FALSE;

		bError = TRUE;
	}

	if (fabs(dist_specY - dist_R) > dist_tor)
	{
		str.Format("Right L Check NG!!  limit : %.3f, tor : %.3f", dist_specY, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist_R;

		vt_result_info[algo].each_Judge[0][1] = FALSE;
		vt_result_info[algo].each_Judge[1][1] = FALSE;

		bError = TRUE;
	}

	if (fabs(dist_specY - dist_L) > dist_tor)
	{
		str.Format("Left L Check NG!!  limit : %.3f, tor : %.3f", dist_specY, dist_tor);
		if (prealign_test)	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&str);
		else				::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		m_dbLcheckLength[algo] = dist_L;

		vt_result_info[algo].each_Judge[0][0] = FALSE;
		vt_result_info[algo].each_Judge[1][0] = FALSE;
		bError = TRUE;
	}

	return bError;
}

BOOL CLET_AlignClientDlg::UsePassword()
{
	CKeyPadDlg dlg;
	CString strTemp, strTime;

	dlg.SetValueString(true, strTemp);
	dlg.DoModal();
	dlg.GetValue(strTemp);

	SYSTEMTIME time;
	::GetLocalTime(&time);
	strTime.Format("%02d%02d", time.wHour, time.wMinute);

	BOOL bFind = TRUE;
	int nLen = strTemp.GetLength();
	if (nLen > 4) bFind = FALSE;// 4자리 이상 NG

	// 입력한 값 중에 시간 + 분 값이 있는지
	for (int i = 0; i < 4; i++)
	{
		if (strTemp.Find(strTime.GetAt(i)) < 0)
		{
			bFind = FALSE;
			return bFind;
		}
			
	}
	return bFind;
}
BOOL CLET_AlignClientDlg::PCB_Distance_Insp(BYTE *pImage, _stFindPattern *pPattern)
{
	BOOL bResult = TRUE;

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;		//현재 카메라 포지션
	int nJob = pPattern->nJob;
	int nSCount = pPattern->nSearchCount;
	
	std::vector<int> camBuf = vt_job_info[nJob].camera_index;
	int real_cam = vt_job_info[nJob].camera_index[nCam];
	int W = m_stCamInfo[real_cam].w;
	int H = m_stCamInfo[real_cam].h;
	cv::Mat img(H, W, CV_8UC1, pImage);
	///////////// PCB 밴딩검사 위치에 따라 검사 방법 조정
	/*
							-------------------> CAM 진행방향
	//																				  //
	//																				  //
	//															                      //
	//	      PCB1                PCB2	               PCB3              PCB4		  //
	////////////////////////////////////////////////////////////////////////////////////   <- 패널끝단
		(Cam1-1) (Cam1-2)  (Cam1-3) (Cam1-4)     (Cam2-1) (Cam2-2) (Cam2-3) (Cam2-4)       <- CAM 위치
	*/
	

	int nInspMethod = vt_job_info[nJob].model_info.getAlignInfo().getInspectionMethod();			// Panel 끝단 위치 검사 방법.
	int nInspSubMethod = vt_job_info[nJob].model_info.getAlignInfo().getInspectionSubMethod();		// Panel 중간 위치 검사 방법.
#pragma region 패널 및 PCB 찾는 부분
	// 좌측 카메라는 첫 위치, 우측 카메라는 마지막 위치일때,
	// 패널의 좌/우측 엣지(세로)가 보이므로, 세로선을 추가로 찾기 위해 분기 함.
	if ((camBuf.at(0) == real_cam && nPos == 0) || 
		(camBuf.at(1) == real_cam && nPos == m_nSeqTotalInspGrabCount - 1))
	{
		bResult = algorithm_pcb_Insp(img.data, pPattern, nInspMethod);
	}
	else
	{
		bResult = algorithm_pcb_Insp(img.data, pPattern, nInspSubMethod, TRUE);
	}
#pragma endregion

	return bResult;
}

void CLET_AlignClientDlg::init_calib_data()
{
	CString str;

	for (int job = 0; job < vt_job_info.size(); job++)
	{
		for (int nCam = 0; nCam < vt_job_info[job].num_of_camera; nCam++)
		{
			for (int nPos = 0; nPos < vt_job_info[job].num_of_position; nPos++)
			{
				m_bMakeDefaultCoordinates[nCam][nPos] = FALSE;
				if (GetMachine(job).isInitCalib(nCam, nPos) == TRUE)		continue;

				//str.Format("%sCalibData%d.dat", m_strMachineDir, nCam + 1);
				str.Format("%s%s\\CalibData%d_%d.dat", m_strMachineDir, vt_job_info[job].job_name.c_str(), nCam + 1, nPos + 1);

				if (_access(str, 0) == 0)
				{
					GetMachine(job).readCalibrationData(nCam, nPos, str);

					int org_pos = vt_job_info[job].model_info.getMachineInfo().getAlignOrginPos(nCam);
					int real_cam = vt_job_info[job].camera_index[nCam];
					int W = m_stCamInfo[real_cam].w;
					int H = m_stCamInfo[real_cam].h;
					
					double xr = 0.5;
					double yr = 0.5;
					double cX, cY;
					switch (org_pos)
					{
					case _LEFT_TOP_X25_Y25:  xr = 0.25; yr = 0.25; break;
					case _CENTER_TOP_X50_Y25:  xr = 0.5; yr = 0.25; break;
					case _RIGHT_TOP_X75_Y25:  xr = 0.75; yr = 0.25; break;
					case _LEFT_CENTER_X25_Y50:  xr = 0.25; yr = 0.5; break;
					case _CENTER_CENTER_X50_Y50:  xr = 0.5; yr = 0.5; break;
					case _RIGHT_CENTER_X75_Y50:  xr = 0.75; yr = 0.5; break;
					case _LEFT_BOTTOM_X25_Y75:  xr = 0.25; yr = 0.75; break;
					case _CENTER_BOTTOM_X50_Y75:  xr = 0.5; yr = 0.75; break;
					case _RIGHT_BOTTOM_X75_Y75:  xr = 0.75; yr = 0.75; break;
					case _NOTCH_X85_Y50:		xr = 0.85; yr = 0.5; break;
					}

					GetMachine(job).PixelToWorld(nCam, nPos, W * xr, H * yr, &cX, &cY, TRUE);
					GetMachine(job).setOffsetX(nCam, nPos, cX);
					GetMachine(job).setOffsetY(nCam, nPos, cY);

					

					BOOL bCalibOriginAtYCenter = GetMachine(job).getCalibOriginAtYCenter();

					if (bCalibOriginAtYCenter)
						GetMachine(job).setCalibrationOrigin(nCam, nPos, vt_job_info[job].model_info.getAlignInfo().getFiducialMarkPitchX());

					if (GetMachine(job).getCameraResolutionX(nCam, nPos) == 0 || GetMachine(job).getCameraResolutionY(nCam, nPos) == 0)
						GetMachine(job).calculateResolution(nCam, nPos, GetMachine(job).getNumCalPointsX(), GetMachine(job).getNumCalPointsY());
				}
				else
				{
					double rangeX = vt_job_info[job].model_info.getMachineInfo().getCalibrationRangeX();
					double rangeY = vt_job_info[job].model_info.getMachineInfo().getCalibrationRangeY();
					double pitchX = vt_job_info[job].model_info.getAlignInfo().getFiducialMarkPitchX();
					double pitchY = vt_job_info[job].model_info.getAlignInfo().getFiducialMarkPitchY();
					BOOL bCalibChangeAxisXY = GetMachine(job).getCalibChangeAxisXY();
					BOOL bCalibDirReverseX = GetMachine(job).getCalibDirReverseX();
					BOOL bCalibDirReverseY = GetMachine(job).getCalibDirReverseY();



					int real_cam = vt_job_info[job].camera_index[nCam];
					int w = m_stCamInfo[real_cam].w;
					int h = m_stCamInfo[real_cam].h;
					int viewer = vt_job_info[job].viewer_index[nCam];

					GetMachine(job).setWidth(w);
					GetMachine(job).setHeight(h);
					GetMachine(job).setCameraResolutionX(nCam, nPos, vt_viewer_info[viewer].resolution_x);
					GetMachine(job).setCameraResolutionY(nCam, nPos, vt_viewer_info[viewer].resolution_y);
					GetMachine(job).MakeDefaultMachineCoordinatesCenter(nCam, nPos, pitchX, bCalibChangeAxisXY, bCalibDirReverseX, bCalibDirReverseY, rangeX, rangeY);

					double cX, cY;

					GetMachine(job).PixelToWorld(nCam, nPos, w / 2, h / 2, &cX, &cY, TRUE);

					GetMachine(job).setOffsetX(nCam, nPos, cX);
					GetMachine(job).setOffsetY(nCam, nPos, cY);
					m_bMakeDefaultCoordinates[nCam][nPos] = TRUE;
				}

				GetMachine(job).readCalibrationDirection(nCam, nPos);
			}
		}

		CString str_path;
		str_path.Format("%s%s", m_strCurrentModelPath, vt_job_info[job].job_name.c_str());
		GetMachine(job).readRotateCenter(str_path);
		GetMachine(job).setNumCalPointsX(vt_job_info[job].model_info.getMachineInfo().getCalibrationCountX());
		GetMachine(job).setNumCalPointsY(vt_job_info[job].model_info.getMachineInfo().getCalibrationCountY());
	}

	//KJH 2022-06-30 Machine창 Origin Box Display 삭제
	//::SendMessageA(m_pForm[FORM_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_TRAGER_VIEW, NULL);
	::SendMessageA(m_pForm[FORM_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_TARGET_LINE_VIEW, 0);
	::SendMessageA(m_pForm[FORM_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_DISPLAY_CALIBRATION_AREA_VIEW, 0);
}
void CLET_AlignClientDlg::init_gui()
{
	CString str;
	CCreateContext context;
	ZeroMemory(&context, sizeof(context));
	CView* pView = NULL;
	CRect rect = CRect(0, 0, 0, 0);

	//----- Pane Header -----//
	pView = (CView*)RUNTIME_CLASS(CPaneHeader)->CreateObject();
	GetDlgItem(IDC_PANEL_HEADER)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_PANE_HEADER, &context);
	pView->OnInitialUpdate();
	m_pPaneHeader = pView;
	m_hHeaderBar = m_pPaneHeader->m_hWnd;
	m_pPaneHeader->ShowWindow(SW_SHOW);

	//----- Pane Bottom -----//
	pView = (CView*)RUNTIME_CLASS(CPaneBottom)->CreateObject();
	GetDlgItem(IDC_PANEL_BOTTOM)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_PANE_BOTTOM, &context);
	pView->OnInitialUpdate();
	m_pPaneBottom[B_PANE_BOTTOM] = pView;
	m_pPaneBottom[B_PANE_BOTTOM]->ShowWindow(SW_SHOW);

	// kbj 2021-12-31 시뮬레이션 Bottom_Pane 이름 변경 및 수정.
	//----- Pane Bottom Simulation -----//
	pView = (CView*)RUNTIME_CLASS(CPaneBottomSimulation)->CreateObject();
	GetDlgItem(IDC_PANEL_BOTTOM)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_PANE_BOTTOM_SIMULATION, &context);
	pView->OnInitialUpdate();
	m_pPaneBottom[B_PANE_SIMULATION] = pView;
	m_pPaneBottom[B_PANE_SIMULATION]->ShowWindow(SW_HIDE);

	//----- Pane Manual -----//
	pView = (CView*)RUNTIME_CLASS(CPaneManual)->CreateObject();
	GetDlgItem(IDC_PANEL_RIGHT)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_PANE_MANUAL, &context);
	pView->OnInitialUpdate();
	m_pPane[PANE_MANUAL] = pView;
	m_pPane[PANE_MANUAL]->ShowWindow(SW_SHOW);

	//----- Pane Camera -----//
	pView = (CView*)RUNTIME_CLASS(CPaneCamera)->CreateObject();
	GetDlgItem(IDC_PANEL_RIGHT)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_PANE_CAMERA, &context);
	pView->OnInitialUpdate();
	m_pPane[PANE_CAMERA] = pView;
	m_pPane[PANE_CAMERA]->ShowWindow(SW_HIDE);

	//----- Pane Model -----//
	pView = (CView*)RUNTIME_CLASS(CPaneModel)->CreateObject();
	GetDlgItem(IDC_PANEL_RIGHT)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_PANE_MODEL, &context);
	pView->OnInitialUpdate();
	m_pPane[PANE_MODEL] = pView;
	m_pPane[PANE_MODEL]->ShowWindow(SW_HIDE);

	//----- Pane Machine-----//
	pView = (CView*)RUNTIME_CLASS(CPaneMachine)->CreateObject();
	GetDlgItem(IDC_PANEL_RIGHT)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_PANE_MACHINE, &context);
	pView->OnInitialUpdate();
	m_pPane[PANE_MACHINE] = pView;
	m_pPane[PANE_MACHINE]->ShowWindow(SW_HIDE);

	//----- Pane Auto -----//
	pView = (CView*)RUNTIME_CLASS(CPaneAuto)->CreateObject();
	GetDlgItem(IDC_PANEL_RIGHT)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_PANE_AUTO, &context);
	pView->OnInitialUpdate();
	m_pPane[PANE_AUTO] = pView;
	m_pPane[PANE_AUTO]->ShowWindow(SW_HIDE);

	// kbj 2021-12-31 시뮬레이션 Pane 추가
	//----- Pane Simulation -----//
	pView = (CView*)RUNTIME_CLASS(CPaneSimulation)->CreateObject();
	GetDlgItem(IDC_PANEL_RIGHT)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_PANE_SIMULATION, &context);
	pView->OnInitialUpdate();
	m_pPane[PANE_SIMULATION] = pView;
	m_pPane[PANE_SIMULATION]->ShowWindow(SW_HIDE);

	//----- Main View -----//
	pView = (CView*)RUNTIME_CLASS(CFormMainView)->CreateObject();
	GetDlgItem(IDC_PANEL_BODY)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_FORM_MAIN, &context);
	pView->OnInitialUpdate();
	m_pForm[FORM_MAIN] = pView;
	m_pForm[FORM_MAIN]->ShowWindow(SW_SHOW);

	//----- Machine View -----//
	pView = (CView*)RUNTIME_CLASS(CFormMachineView)->CreateObject();
	GetDlgItem(IDC_PANEL_BODY)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_FORM_MACHINE, &context);
	pView->OnInitialUpdate();
	m_pForm[FORM_MACHINE] = pView;
	m_pForm[FORM_MACHINE]->ShowWindow(SW_HIDE);

	//----- Camera View -----//
	pView = (CView*)RUNTIME_CLASS(CFormCameraView)->CreateObject();
	GetDlgItem(IDC_PANEL_BODY)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_FORM_CAMERA, &context);
	pView->OnInitialUpdate();
	m_pForm[FORM_CAMERA] = pView;
	m_pForm[FORM_CAMERA]->ShowWindow(SW_HIDE);

	//----- Model View -----//
	pView = (CView*)RUNTIME_CLASS(CFormModelView)->CreateObject();
	GetDlgItem(IDC_PANEL_BODY)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_FORM_MODEL, &context);
	pView->OnInitialUpdate();
	m_pForm[FORM_MODEL] = pView;
	m_pForm[FORM_MODEL]->ShowWindow(SW_HIDE);

	//----- Interface View -----//
	pView = (CView*)RUNTIME_CLASS(CFormPlcShareMemoryView)->CreateObject();
	GetDlgItem(IDC_PANEL_BODY)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_FORM_PLC_INTERFACE, &context);
	pView->OnInitialUpdate();
	m_pForm[FORM_INTERFACE] = pView;
	m_pForm[FORM_INTERFACE]->ShowWindow(SW_HIDE);

	// kbj 2021-12-31 시스템옵션 Form 추가
	//----- SystemOption View -----//
	pView = (CView*)RUNTIME_CLASS(CFormSystemOptionView)->CreateObject();
	GetDlgItem(IDC_PANEL_BODY)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_FORM_SYSTEM_OPTION, &context);
	pView->OnInitialUpdate();
	m_pForm[FORM_SYSTEM_OPTION] = pView;
	m_pForm[FORM_SYSTEM_OPTION]->ShowWindow(SW_HIDE);

	//----- Trend View -----//
	pView = (CView*)RUNTIME_CLASS(CFormTrendView)->CreateObject();
	GetDlgItem(IDC_PANEL_BODY)->GetWindowRect(&rect);
	pView->Create(NULL, NULL, WS_CHILD, rect, this, IDD_FORM_TREND, &context);
	pView->OnInitialUpdate();
	m_pForm[FORM_TREND] = pView;
	m_pForm[FORM_TREND]->ShowWindow(SW_HIDE);
	
}
void CLET_AlignClientDlg::init_camera()
{
#ifdef _DAHUHA
	CSystem& systemObj = CSystem::getInstance();
	bool bRet = systemObj.discovery(m_vCameraPtrList);
	for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
	{
		if (m_vCameraPtrList.size() <= nCam) break;
	
		for (int i = 0; i < m_vCameraPtrList.size(); i++)
		{
			if (_tcscmp(m_stCamInfo[nCam].cSerial, m_vCameraPtrList[i]->getSerialNumber()) == 0)
			{
				m_pDahuhaCam[nCam].setCamera(m_vCameraPtrList[i]);
				if (m_pDahuhaCam[nCam].connect())
				{
					m_pDahuhaCam[nCam].initcamera();
					::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_HB_CONNECT_CAMERA, MAKELPARAM(nCam, TRUE));
				}

				m_pDahuhaCam[nCam].changeParameters(m_stCamInfo[nCam].frame_rate);
				m_pDahuhaCam[nCam].pDlg = this;
				m_pDahuhaCam[nCam].m_nCam = nCam;

				if (m_stCamInfo[nCam].use_cmd_reverse_x)	m_pDahuhaCam[nCam].setReverseX(m_stCamInfo[nCam].reverse_x);
				if (m_stCamInfo[nCam].use_cmd_reverse_y)	m_pDahuhaCam[nCam].setReverseY(m_stCamInfo[nCam].reverse_y);

				break;
			}
		}
	}
#else
	m_pBaslerCam = new CCamera*[MAX_CAMERA];

	for (int nCam = 0; nCam < MAX_CAMERA; nCam++)
	{
		m_pBaslerCam[nCam] = NULL;

		if (!m_stCamInfo[nCam].buse) continue;

		CCamera* pGrabDigitizer = new CCamera;
		pGrabDigitizer->Uninitialize();
		
		if (pGrabDigitizer->Initialize(nCam, m_stCamInfo[nCam].cSerial) == TRUE)
		{
			::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_HB_CONNECT_CAMERA, MAKELPARAM(nCam, TRUE));

			m_pBaslerCam[nCam] = pGrabDigitizer;

			pGrabDigitizer->m_hWndDlg = GetSafeHwnd();
			pGrabDigitizer->pDlg = this;
			pGrabDigitizer->SetTriggerMode(0);
			m_pBaslerCam[nCam]->m_nCam = nCam;
			m_pBaslerCam[nCam]->GrabContinuous(FALSE);

			if (m_stCamInfo[nCam].use_cmd_reverse_x)	m_pBaslerCam[nCam]->set_reverse_x(m_stCamInfo[nCam].reverse_x);
			if (m_stCamInfo[nCam].use_cmd_reverse_y)	m_pBaslerCam[nCam]->set_reverse_y(m_stCamInfo[nCam].reverse_y);
			if (m_stCamInfo[nCam].use_cmd_packet_size)	m_pBaslerCam[nCam]->set_packet_size(m_stCamInfo[nCam].packet_size);
			if (m_stCamInfo[nCam].use_cmd_fix_frame)	m_pBaslerCam[nCam]->set_frame_rate(m_stCamInfo[nCam].frame_rate);
		}
		else
		{
			if (pGrabDigitizer != NULL)	delete pGrabDigitizer;

			if (m_pSaperaCam[nCam].CreateObjects(m_stCamInfo[nCam].cSerial, nCam))
			{
				m_pSaperaCam[nCam].setOpenStatus(TRUE);
				m_pSaperaCam[nCam].setCamID(nCam);
				m_pSaperaCam[nCam].setMainPtr(this);
				//m_pSaperaCam[nCam].setTriggerMode(false);
				m_pSaperaCam[nCam].setTriggerMode(true);		// dh.jung 2021-05-27 chang continue->trigger

				m_pSaperaCam[nCam].CreateImageFullBuffer(CSize(m_stCamInfo[nCam].w, m_stCamInfo[nCam].h), _SCAN_GRAB_MAXCOUNT);
				::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_HB_CONNECT_CAMERA, MAKELPARAM(nCam, TRUE));
			}
		}

		m_pSaperaInspWorker[nCam].m_pM = (CView*)this;
		m_pSaperaInspWorker[nCam].m_pMainForm = m_pForm[FORM_MAIN];

		m_pScratchInspWorker[nCam].m_pMain = (CLET_AlignClientDlg*)this;
		m_pScratchInspWorker[nCam].m_pMainForm = m_pForm[FORM_MAIN];
	}
#endif
}
void CLET_AlignClientDlg::init_plc_connection()
{
#ifndef _USE_MC_PROTOCOL_
	if (g_CommPLC.Init(0, 1) == TRUE)
	{
		setPLCConnect();
		::SendMessage(m_pForm[FORM_MAIN]->m_hWnd, WM_VIEW_CONTROL, MSG_FMV_THREAD_CREATE, TRUE);
		KillTimer(TIMER_PLC_ALIVE_PING_PONG);
		SetTimer(TIMER_PLC_ALIVE_PING_PONG, 1000, NULL);
		theLog.logmsg(LOG_PROCESS, "PLC Connect!!");
		::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_HB_CONNECT_PLC, MAKELPARAM(0, TRUE));
	}
	else
	{
		char cData[MAX_PATH] = "PLC Disconnect!!";
		::SendMessage(m_hHeaderBar, WM_VIEW_CONTROL, MSG_HB_CONNECT_PLC, MAKELPARAM(0, FALSE));
		SetTimer(TIMER_PLC_CONNECT, 1000, NULL);

		m_bThreadPLCSignalCheckEnd = TRUE;
	}
#else
	g_CommPLC_MC.setMsgHwnd(this->m_hWnd);
	g_CommPLC.m_pMain = this;
	g_CommPLC_MC.m_pMain = this;

	CString strSocket;
	strSocket.Format("%d", m_nSockPlcPort);
	BOOL bret = g_CommPLC_MC.Connect(m_strPlcIP, strSocket);
	KillTimer(TIMER_PLC_ALIVE_PING_PONG);
	SetTimer(TIMER_PLC_ALIVE_PING_PONG, 1000, NULL);
#endif
}
void CLET_AlignClientDlg::init_manual_input_mark()
{
	for (int i = 0; i < vt_job_info.size(); i++)
	{
		if (m_pManualInputMark[i] == NULL)
		{
			m_pManualInputMark[i] = new CDlgManualInputMark();
			m_pManualInputMark[i]->job_id = i;
			m_pManualInputMark[i]->Create(IDD_DLG_MANUAL_INPUT_MARK);
			m_pManualInputMark[i]->ShowWindow(SW_HIDE);
		}
	}
	// KBJ 2022-07-05 Manual Mark 1Cam 기능 추가
	for (int i = 0; i < vt_job_info.size(); i++)
	{
		if (m_pManualInputMark1Cam[i] == NULL)
		{
			m_pManualInputMark1Cam[i] = new CDlgManualInputMark1Cam();
			m_pManualInputMark1Cam[i]->job_id = i;
			m_pManualInputMark1Cam[i]->m_nTotalPosition = vt_job_info[i].num_of_position;
			m_pManualInputMark1Cam[i]->Create(IDD_DLG_MANUAL_INPUT_MARK_1CAM);
			m_pManualInputMark1Cam[i]->ShowWindow(SW_HIDE);
		}
		for (int k = 0; k < vt_job_info[i].num_of_position; k++)
		{
			m_pManualInputMark1Cam[i]->m_StrPositionName[k].Format("%s", vt_job_info[i].position_name[0][k].c_str());
		}
	}
}
void CLET_AlignClientDlg::init_algorithm()
{
	for (int threadID = 0; threadID < vt_job_info.size(); threadID++)
	{
		switch (vt_job_info[threadID].algo_method) 	{
		case CLIENT_TYPE_ALIGN:						m_pFunc[threadID] = &CLET_AlignClientDlg::ProcessPrealignINFRA;			 break;	// 2CAM 2Align 각 카메라당 1개 Mark
		case CLIENT_TYPE_1CAM_1SHOT_ALIGN_WITH_SCRATCH_INSP: m_pFunc[threadID] = &CLET_AlignClientDlg::process1Cam1ShotPrealignWithScratchInsp; break;
		case CLIENT_TYPE_1CAM_1SHOT_ALIGN:			m_pFunc[threadID] = &CLET_AlignClientDlg::process1Cam1ShotPrealign;		 break;	// 1CAM 2Align  카메라당 2개 Mark
		case CLIENT_TYPE_1CAM_2SHOT_ALIGN:			m_pFunc[threadID] = &CLET_AlignClientDlg::process1Cam2ShotPrealign;      break;	// 1CAM 2Align  카메라당 1개 Mark
		case CLIENT_TYPE_2CAM_EACH_2SHOT_ALIGN:		m_pFunc[threadID] = &CLET_AlignClientDlg::process2Cam2ShotPrealign;		 break;	// 2Cam 2Align 카메라당 2개 Mark
		case CLIENT_TYPE_4CAM_1SHOT_ALIGN:			m_pFunc[threadID] = &CLET_AlignClientDlg::ProcessPrealign_4Cam_4Align;	 break;	// 4CAM 4Align 각 카메라당 1개 Mark
		case CLIENT_TYPE_PANEL_EXIST_INSP:			m_pFunc[threadID] = &CLET_AlignClientDlg::processAlignExist;			 break;
		case CLIENT_TYPE_1CAM_2POS_REFERENCE:       m_pFunc[threadID] = &CLET_AlignClientDlg::processAlign1Cam2PosPreAlign;  break;	// 1CAM 2Align   Mark 4개 Search
		case CLIENT_TYPE_PCB_DISTANCE_INSP:			m_pFunc[threadID] = &CLET_AlignClientDlg::processPcbDistanceInsp2;		 break;
		case CLIENT_TYPE_ASSEMBLE_INSP:				m_pFunc[threadID] = &CLET_AlignClientDlg::processAssembleInsp;			 break;
		case CLIENT_TYPE_ELB_CENTER_ALIGN :         m_pFunc[threadID] = &CLET_AlignClientDlg::processCenterAlignELB;		 break;
		case CLIENT_TYPE_NOZZLE_ALIGN :             m_pFunc[threadID] = &CLET_AlignClientDlg::processNozzleAlign;			 break;
		case CLIENT_TYPE_SCAN_INSP:                 m_pFunc[threadID] = &CLET_AlignClientDlg::processScanInsp;		    	 break;
		case CLIENT_TYPE_FILM_INSP:                 m_pFunc[threadID] = &CLET_AlignClientDlg::processFilmInsp;               break;	// 필름 부착후 검사 기능
		case CLIENT_TYPE_NOZZLE_SIDE_VIEW:          m_pFunc[threadID] = &CLET_AlignClientDlg::processNozzleStatusInsp;       break;	// 노즐 상태 검사 및 높이 측정 기능
		case CLIENT_TYPE_CENTER_NOZZLE_ALIGN:		m_pFunc[threadID] = &CLET_AlignClientDlg::processCenterNozzleAlign;      break;	// 20211205 Tkyuha 신규 노즐 얼라인			
		case CLIENT_TYPE_CENTER_SIDE_YGAP:			m_pFunc[threadID] = &CLET_AlignClientDlg::processCenterNozzleGapMeasure; break;	// 20211205 Tkyuha 스테이지 와 노즐 높이 측정			
		case CLIENT_TYPE_1CAM_1SHOT_FILM:			m_pFunc[threadID] = &CLET_AlignClientDlg::process1Cam1ShotFilmalign;	 break;	// KJH 2022-05-11 1Cam 1SHot Film Align[Grab Bit 추가 버전]			
		case CLIENT_TYPE_1CAM_4POS_ROBOT:			m_pFunc[threadID] = &CLET_AlignClientDlg::processAlign1Cam4PosRobotAlign;break;	// KJH 2022-08-04 1Cam 4Pos 2Object Robot Align 버전		
		case CLIENT_TYPE_ONLY_VIEW:                	m_pFunc[threadID] = &CLET_AlignClientDlg::processViewerSubInspection;    break; // 추가 검사 기능
		default:									m_pFunc[threadID] = &CLET_AlignClientDlg::ProcessPrealignINFRA;			 break;
		}

		AfxBeginThread(Thread_Process, new STPARAM(this, threadID));

		int camCount = vt_job_info[threadID].num_of_camera;
		std::vector<int> camBuf = vt_job_info[threadID].camera_index;

		// 90도 회전하여 내려 놓아야 되는 경우
#ifndef JOB_INFO
		for (int i = 0; i < camCount; i++)
		{
			BOOL bRevisionRotateXY = GetMachine().getRevisionRotateXY(camBuf.at(i));
			GetPrealign(threadID).setRevisionRotate_XY(bRevisionRotateXY);
		}
#else
		BOOL bRevisionRotateXY = GetMachine(threadID).getRevisionRotateXY();
		GetPrealign(threadID).setRevisionRotate_XY(bRevisionRotateXY);
#endif

		if (vt_job_info[threadID].algo_method == CLIENT_TYPE_CENTER_SIDE_YGAP)
		{
			CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

			double _offset = vt_job_info[threadID].model_info.getInspSpecParaInfo().getNozzleToStageGapOffset();

			int nViewer = vt_job_info[threadID].viewer_index[0];

			int W = pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().GetWidth();
			int H = pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().GetHeight();

			double xres = pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().getCameraResolutionX();
			double yres = pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().getCameraResolutionY();

			//stFigure tempFig;

			double centerPtX = W / 2, cetnerPtY = H / 2;
			double ylineoffset = _offset / yres;

			//tempFig.ptBegin.x = 0;
			//tempFig.ptBegin.y = (int)(cetnerPtY + ylineoffset);
			//tempFig.ptEnd.x = W - 1;
			//tempFig.ptEnd.y = (int)(cetnerPtY + ylineoffset);

			//pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().addFigureLine(tempFig, 2, 2, RGB(255, 0, 0));

			pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().AddSoftGraphic(new GraphicLine(cv::Point2f(0, cetnerPtY + ylineoffset), cv::Point2f(W, cetnerPtY + ylineoffset), Gdiplus::Color::Red));
			pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().Invalidate();
		}
		if (vt_job_info[threadID].algo_method == CLIENT_TYPE_ELB_CENTER_ALIGN)
		{
			draw_NozzleY_Distance(threadID);			
		}
	}

	/*
	for (int threadID = 0; threadID < vt_job_info.size(); threadID++)
	{
		if (vt_job_info[threadID].algo_method == CLIENT_TYPE_1CAM_1SHOT_ALIGN)
		{
			g_Job_1Cam1ShotAlign[threadID].run_thread(this, threadID);
		}
	}
	*/

}

void CLET_AlignClientDlg::LightUse(int nLightuse, int algo)
{
	/*int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);*/
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;

//#define TNWJDDL

#ifdef TNWJDDL

	if (nLightuse == LIGHT_ON)
	{
		for (int nCam = 0; nCam < camCount; nCam++)
		{
			int nIndex = 0;

#ifndef JOB_INFO
			for (int nLight = 0; nLight < m_pViewDisplayInfo[camBuf[nCam]].get_num_of_using_light(); nLight++)
			{
				int ctrl = m_pViewDisplayInfo[camBuf[nCam]].getLightController(nLight) - 1;
				int ch = m_pViewDisplayInfo[camBuf[nCam]].getLightChannel(nLight);
				int value = getModel().getMachineInfo().getLightBright(camBuf[nCam], nLight, nIndex);
				SetLightBright(ctrl, ch, value);
			}
#else
			for (int nLight = 0; nLight < vt_job_info[algo].light_info[nCam].num_of_using_light; nLight++)
			{
				int ctrl = vt_job_info[algo].light_info[nCam].controller_id[nLight] - 1;
				int ch = vt_job_info[algo].light_info[nCam].channel_id[nLight];
				int value = vt_job_info[algo].model_info.getLightInfo().getLightBright(nCam, nLight, nIndex);
   				SetLightBright(ctrl, ch, value);
			}
#endif

		}

		Sleep(200);
	}
	else if (nLightuse == LIGHT_OFF)
	{
#ifndef JOB_INFO
		for (int nCam = 0; nCam < m_pAlgorithmInfo.getAlgorithmCameraNum(algo); nCam++)
		{
			int nIndex = 0;

			for (int nLight = 0; nLight < m_pViewDisplayInfo[camBuf[nCam]].get_num_of_using_light(); nLight++)
			{
				int ctrl = m_pViewDisplayInfo[camBuf[nCam]].getLightController(nLight) - 1;
				int ch = m_pViewDisplayInfo[camBuf[nCam]].getLightChannel(nLight);
				int value = 0;
				SetLightBright(ctrl, ch, value);
			}
		}
#else
		for (int nCam = 0; nCam < vt_job_info[algo].num_of_camera; nCam++)
		{
			for (int nLight = 0; nLight < vt_job_info[algo].light_info[nCam].num_of_using_light; nLight++)
			{
				int ctrl = vt_job_info[algo].light_info[nCam].controller_id[nLight] - 1;
				int ch = vt_job_info[algo].light_info[nCam].channel_id[nLight];
				int value = 0;
				SetLightBright(ctrl, ch, value);
			}
		}
		
		Sleep(200);
#endif

	}
#endif // TNWJDDL

}
void CLET_AlignClientDlg::initPLC_Time()
{
	BOOL bUse = m_bUsePlcTime;
	if (bUse == FALSE) return;
	int index = 0;

	long lData[6];
	g_CommPLC.GetWord(14910, 6, lData);

	int nYear, nMonth, nDay, nHour, nMin, nSec;
	memcpy(&nYear, &lData[index], sizeof(int));	index += sizeof(int);
	memcpy(&nMonth, &lData[index], sizeof(int));	index += sizeof(int);
	memcpy(&nDay, &lData[index], sizeof(int));	index += sizeof(int);
	memcpy(&nHour, &lData[index], sizeof(int));	index += sizeof(int);
	memcpy(&nMin, &lData[index], sizeof(int));	index += sizeof(int);
	memcpy(&nSec, &lData[index], sizeof(int));	index += sizeof(int);

	CString strTemp;
	strTemp.Format("Time from PLC : %04d/%02d/%02d %02d:%02d:%02d", nYear, nMonth, nDay, nHour, nMin, nSec);
	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);

	SYSTEMTIME Time;
	::GetLocalTime(&Time);

	Time.wYear = nYear;		Time.wMonth = nMonth;		Time.wDay = nDay;
	Time.wHour = nHour;		Time.wMinute = nMin;		Time.wSecond = nSec;

	::SetLocalTime(&Time);
}

void CLET_AlignClientDlg::draw_line(cv::Mat& Img, cv::Scalar& color, sLine lineInfo, int nWidth, int nHeight, int nPenThickness, BOOL bDraw)
{
	// y = ax + b
	CvPoint ptLineInfo[2];
	_st32fPoint m_ptStart, m_ptEnd;

	m_ptStart.x = lineInfo.b / lineInfo.a;
	m_ptStart.y = lineInfo.b;
	m_ptEnd.x = (nWidth - lineInfo.b) / lineInfo.a;
	m_ptEnd.y = lineInfo.a * nWidth + lineInfo.b;

	double dx = abs(m_ptStart.x - m_ptEnd.x);
	double dy = abs(m_ptStart.y - m_ptEnd.y);
	double aspectratio = 2;

	if (dx != 0)	aspectratio = dy / dx;

	if (aspectratio < 1.0)
	{
		ptLineInfo[0].y = (int)(lineInfo.a * 0 + lineInfo.b);
		ptLineInfo[0].x = 0;

		ptLineInfo[1].y = (int)(lineInfo.a * nWidth + lineInfo.b);
		ptLineInfo[1].x = nWidth;
	}
	else
	{
		if (lineInfo.a == 0)
		{
			ptLineInfo[0].x = lineInfo.b;
			ptLineInfo[0].y = 0;

			ptLineInfo[1].x = lineInfo.b;
			ptLineInfo[1].y = nHeight;
		}
		else
		{
			ptLineInfo[0].x = (int)((0 - lineInfo.b) / lineInfo.a);
			ptLineInfo[0].y = 0;

			ptLineInfo[1].x = (int)((nHeight - lineInfo.b) / lineInfo.a);
			ptLineInfo[1].y = nHeight;
		}
	}

	cv::Point pt1, pt2;

	pt1.x = ptLineInfo[0].x;
	pt1.y = ptLineInfo[0].y;
	pt2.x = ptLineInfo[1].x;
	pt2.y = ptLineInfo[1].y;

	if (bDraw)
	{
		cv::line(Img, pt1, pt2, color, nPenThickness);
	}
}
void CLET_AlignClientDlg::draw_mark(cv::Mat& Img, cv::Scalar& color, int nPosx, int nPosy, int nPenLength, int nPenThickness, BOOL bDraw)
{
	if (bDraw == FALSE) return;

	cv::Point pt1, pt2;

	pt1.x = nPosx - nPenLength;
	pt1.y = nPosy;
	pt2.x = nPosx + nPenLength;
	pt2.y = nPosy;
	cv::line(Img, pt1, pt2, color, nPenThickness);

	pt1.x = nPosx;
	pt1.y = nPosy - nPenLength;
	pt2.x = nPosx;
	pt2.y = nPosy + nPenLength;
	cv::line(Img, pt1, pt2, color, nPenThickness);
}
void CLET_AlignClientDlg::draw_line(FakeDC* pDC, sLine lineInfo, int nHeight, int nWidth, BOOL bDraw)
{
	//CPen *pOldPen;
	//pOldPen = pDC->SelectObject(pPen);
	// y = ax + b
	CvPoint ptLineInfo[2];
	_st32fPoint m_ptStart, m_ptEnd;

	m_ptStart.x = lineInfo.b / lineInfo.a;
	m_ptStart.y = lineInfo.b;
	m_ptEnd.x = (nWidth - lineInfo.b) / lineInfo.a;
	m_ptEnd.y = lineInfo.a * nWidth + lineInfo.b;

	double dx = abs(m_ptStart.x - m_ptEnd.x);
	double dy = abs(m_ptStart.y - m_ptEnd.y);
	double aspectratio = 2;

	if (dx != 0)	aspectratio = dy / dx;

	if (aspectratio < 1.0)
	{
		ptLineInfo[0].y = (int)(lineInfo.a * 0 + lineInfo.b);
		ptLineInfo[0].x = 0;

		ptLineInfo[1].y = (int)(lineInfo.a * nWidth + lineInfo.b);
		ptLineInfo[1].x = nWidth;
	}
	else
	{
		if (lineInfo.a == 0)
		{
			ptLineInfo[0].x = lineInfo.b;
			ptLineInfo[0].y = 0;

			ptLineInfo[1].x = lineInfo.b;
			ptLineInfo[1].y = nHeight;
		}
		else
		{
			ptLineInfo[0].x = (int)((0 - lineInfo.b) / lineInfo.a);
			ptLineInfo[0].y = 0;

			ptLineInfo[1].x = (int)((nHeight - lineInfo.b) / lineInfo.a);
			ptLineInfo[1].y = nHeight;
		}
	}

	if (bDraw)
	{
		pDC->MoveTo(ptLineInfo[0].x, ptLineInfo[0].y);
		pDC->LineTo(ptLineInfo[1].x, ptLineInfo[1].y);
	}

	//pDC->SelectObject(pOldPen);
}
void CLET_AlignClientDlg::draw_line(CViewerEx* pView, COLORREF color, sLine lineInfo, int nHeight, int nWidth, BOOL bDraw)
{
	// y = ax + b
	CvPoint ptLineInfo[2];
	_st32fPoint m_ptStart, m_ptEnd;

	m_ptStart.x = lineInfo.b / lineInfo.a;
	m_ptStart.y = lineInfo.b;
	m_ptEnd.x = (nWidth - lineInfo.b) / lineInfo.a;
	m_ptEnd.y = lineInfo.a * nWidth + lineInfo.b;

	double dx = abs(m_ptStart.x - m_ptEnd.x);
	double dy = abs(m_ptStart.y - m_ptEnd.y);
	double aspectratio = 2;

	if (dx != 0)	aspectratio = dy / dx;

	if (aspectratio < 1.0)
	{
		ptLineInfo[0].y = (int)(lineInfo.a * 0 + lineInfo.b);
		ptLineInfo[0].x = 0;

		ptLineInfo[1].y = (int)(lineInfo.a * nWidth + lineInfo.b);
		ptLineInfo[1].x = nWidth;
	}
	else
	{
		if (lineInfo.a == 0)
		{
			ptLineInfo[0].x = lineInfo.b;
			ptLineInfo[0].y = 0;

			ptLineInfo[1].x = lineInfo.b;
			ptLineInfo[1].y = nHeight;
		}
		else
		{
			ptLineInfo[0].x = (int)((0 - lineInfo.b) / lineInfo.a);
			ptLineInfo[0].y = 0;

			ptLineInfo[1].x = (int)((nHeight - lineInfo.b) / lineInfo.a);
			ptLineInfo[1].y = nHeight;
		}
	}

	stFigure tempFig;

	if (bDraw)
	{
		stFigure tempFig;
		tempFig.ptBegin.x = ptLineInfo[0].x;
		tempFig.ptBegin.y = ptLineInfo[0].y;
		tempFig.ptEnd.x = ptLineInfo[1].x;
		tempFig.ptEnd.y = ptLineInfo[1].y;
		pView->addFigureLine(tempFig, 2, 1, color);

		//pView->AddSoftGraphic(new GraphicLine(cv::Point2f(ptLineInfo[0].x, ptLineInfo[0].y), cv::Point2f(ptLineInfo[1].x, ptLineInfo[1].y), Gdiplus::Color(color | 0xff000000)));
	}
}
void CLET_AlignClientDlg::draw_mark(FakeDC* pDC, CPen* pPen, int nPosx, int nPosy, int nPenLength, BOOL bDraw)
{
	CPen *pOldPen;
	pOldPen = pDC->SelectObject(pPen);

	if (bDraw)
	{
		pDC->MoveTo(nPosx - nPenLength, nPosy);
		pDC->LineTo(nPosx + nPenLength, nPosy);
		pDC->MoveTo(nPosx, nPosy - nPenLength);
		pDC->LineTo(nPosx, nPosy + nPenLength);
	}

	pDC->SelectObject(pOldPen);
}
void CLET_AlignClientDlg::draw_mark(CViewerEx* pView, COLORREF color, int nPosx, int nPosy, int nFitS, int nOrgS, int nPenLength, BOOL bDraw)
{
	//stFigure tempFig;

	if (bDraw)
	{
		//tempFig.ptBegin.x = nPosx - nPenLength;
		//tempFig.ptBegin.y = nPosy;
		//tempFig.ptEnd.x = nPosx + nPenLength;
		//tempFig.ptEnd.y = nPosy;
		//pView->addFigureLine(tempFig, nFitS, nOrgS, color);

		//tempFig.ptBegin.x = nPosx;
		//tempFig.ptBegin.y = nPosy - nPenLength;
		//tempFig.ptEnd.x = nPosx;
		//tempFig.ptEnd.y = nPosy + nPenLength;
		//pView->addFigureLine(tempFig, nFitS, nOrgS, color);

		if (pView != NULL) pView->AddSoftGraphic(new GraphicPoint(nPosx, nPosy, ColorRefToColor(color), 5, 1));
	}
}
void CLET_AlignClientDlg::draw_text(CViewerEx* pView, CString strText, COLORREF color, int nFitS, int nOrgS, int x, int y, bool is_show_bkg)
{
	//stFigureText tempFigText;
	//tempFigText.ptBegin.x = x;
	//tempFigText.ptBegin.y = y;
	//tempFigText.ptBeginFit.x = x;
	//tempFigText.ptBeginFit.y = y;
	//tempFigText.textString = strText;
	//tempFigText.is_show_bkg = is_show_bkg;
	//pView->addFigureText(tempFigText, nFitS, nOrgS, color);
	//pView->AddSoftGraphic(new GraphicLabel(x, y, strText, Gdiplus::Color(color | 0xff000000), Anchor::Bottom));
	if (pView != NULL) pView->AddSoftGraphic(new GraphicLabel(x, y, strText, ColorRefToColor(color), Anchor::BottomRight));
}
void CLET_AlignClientDlg::draw_arrow(CViewerEx* pView, int direction, CString strText, COLORREF color, int start_x, int start_y, int end_x, int end_y, int nText_FitS, int nText_OrgS)
{
	stFigure tempFig;

	// draw arrow Line
	tempFig.ptBegin.x = start_x;
	tempFig.ptBegin.y = start_y;
	tempFig.ptEnd.x = end_x;
	tempFig.ptEnd.y = end_y;
	pView->addFigureLine(tempFig, nText_FitS, nText_OrgS, color);

	// draw arrow 
	int margin = 20;
	
	switch (direction)
	{
	case ARROW_UP:
		//left arrow
		tempFig.ptBegin.x = end_x;
		tempFig.ptBegin.y = end_y;
		tempFig.ptEnd.x = end_x - margin;
		tempFig.ptEnd.y = end_y + margin;
		pView->addFigureLine(tempFig, nText_FitS, nText_OrgS, color);

		//right arrow
		tempFig.ptBegin.x = end_x;
		tempFig.ptBegin.y = end_y;
		tempFig.ptEnd.x = end_x + margin;
		tempFig.ptEnd.y = end_y + margin;
		pView->addFigureLine(tempFig, nText_FitS, nText_OrgS, color);
		break;
	case ARROW_RIGHT:
		//up arrow
		tempFig.ptBegin.x = end_x;
		tempFig.ptBegin.y = end_y;
		tempFig.ptEnd.x = end_x - margin;
		tempFig.ptEnd.y = end_y - margin;
		pView->addFigureLine(tempFig, nText_FitS, nText_OrgS, color);

		//down arrow
		tempFig.ptBegin.x = end_x;
		tempFig.ptBegin.y = end_y;
		tempFig.ptEnd.x = end_x - margin;
		tempFig.ptEnd.y = end_y + margin;
		pView->addFigureLine(tempFig, nText_FitS, nText_OrgS, color);
		
		break;
	case ARROW_DOWN:
		//left arrow
		tempFig.ptBegin.x = end_x;
		tempFig.ptBegin.y = end_y;
		tempFig.ptEnd.x = end_x - margin;
		tempFig.ptEnd.y = end_y - margin;
		pView->addFigureLine(tempFig, nText_FitS, nText_OrgS, color);

		//right arrow
		tempFig.ptBegin.x = end_x;
		tempFig.ptBegin.y = end_y;
		tempFig.ptEnd.x = end_x + margin;
		tempFig.ptEnd.y = end_y - margin;
		pView->addFigureLine(tempFig, nText_FitS, nText_OrgS, color);
		break;

	case ARROW_LEFT:
		//up arrow
		tempFig.ptBegin.x = end_x;
		tempFig.ptBegin.y = end_y;
		tempFig.ptEnd.x = end_x + margin;
		tempFig.ptEnd.y = end_y - margin;
		pView->addFigureLine(tempFig, nText_FitS, nText_OrgS, color);

		//down arrow
		tempFig.ptBegin.x = end_x;
		tempFig.ptBegin.y = end_y;
		tempFig.ptEnd.x = end_x + margin;
		tempFig.ptEnd.y = end_y + margin;
		pView->addFigureLine(tempFig, nText_FitS, nText_OrgS, color); break; break;
	}
	
	// arrow strat commnet
	int dCommentX, dCommentY;

	margin = 30;

	switch (direction)
	{
	case ARROW_LEFT:
		dCommentX = start_x - fabs(start_x - end_x);
		dCommentY = start_y + margin;
		break;
	case ARROW_RIGHT:
		dCommentX = start_x + fabs(start_x- end_x);
		dCommentY = start_y + margin;
		break;
	case ARROW_UP:
		dCommentX = start_x + margin;
		dCommentY = start_y - fabs(start_y - end_y);
		break;
	case ARROW_DOWN:
		dCommentX = start_x + margin;
		dCommentY = start_y + fabs(start_y - end_y);
		break;
	}

	draw_text(pView, strText, color, 12, 12, dCommentX, dCommentY);
}

void CLET_AlignClientDlg::draw_direction(CViewerEx* pView, int direction, int line_length, CString strText, COLORREF color, int start_x, int start_y, int nText_FitS, int nText_OrgS)
{
	int LUT_x[] = { -line_length, line_length, 0, 0 };
	int LUT_y[] = { 0, 0, line_length, -line_length };

	if (direction > -1 && direction < DIRECTION_EMPTY)
	{
		auto cl = ColorRefToColor(color);
		auto st = Gdiplus::PointF(start_x, start_y);
		auto ed = Gdiplus::PointF(start_x + LUT_x[direction], start_y + LUT_y[direction]);
		if (pView != NULL) pView->AddSoftGraphic(new GraphicArrow(st, ed, 11, cl));
		if (pView != NULL) pView->AddSoftGraphic(new GraphicLabel(ed.X, ed.Y, strText, cl, Anchor::BottomRight));
	}
}

BOOL CLET_AlignClientDlg::algorithm_AssembleInsp_CALC(BYTE *pImage, _stFindPattern *pPattern, int nInspMethod, BOOL bSubDir)			// 수동 계산시 사용
{
	BOOL bInspResult = TRUE;
	CString strTemp;

	int nCam = pPattern->nCam;
	int nPos = pPattern->nPos;
	int nJob = pPattern->nJob;
	int nSCount = pPattern->nSearchCount;

	int real_cam = vt_job_info[nJob].camera_index[nCam];

	m_stInsp_DistanceResult[real_cam][nPos].nCam = real_cam;
	m_stInsp_DistanceResult[real_cam][nPos].nPos = nPos;

	int W = m_stCamInfo[real_cam].w;
	int H = m_stCamInfo[real_cam].h;

	/////////////////////////////////////////////////////////////////////////////////////
	////////////////////////// 첫번째 위치(PANEL)찾기

	const int FIND_PANEL = 0;
	const int FIND_PCB_BOTTOM = 1;

	const int POINT_PANEL = 0;
	const int POINT_PCB_BOTTOM = 1;
	const int POINT_CROSS_1 = 2;
	const int POINT_CROSS_2 = 3;
	const int POINT_PROTRUDING = 4;

	const int CALIPER_PANEL_VERT = 0;
	const int CALIPER_PANEL_HORI = 1;
	const int CALIPER_PCB_VERT = 3;
	const int CALIPER_PCB_HORI = 4;

	const int FIND_CALIPER_PANEL_VERT = 0;
	const int FIND_CALIPER_PANEL_HORI = 1;
	const int FIND_CALIPER_PCB_VERT = 2;
	const int FIND_CALIPER_PCB_HORI = 3;


	BOOL bFindLine[2];								// 찾은 여부확인
	sLine line_info[2];								// 라인
	double posx[4], posy[4];						// { POINT_PANEL, POINT_PCB_BOTTOM, POINT_CROSS_1, POINT_CROSS_2}
	double dx = 0.0, dy = 0.0, dt = 0.0;			// Panel Mark Fixture
	double dx2 = 0.0, dy2 = 0.0, dt2 = 0.0;			// PCB_BOTTOM Mark Fixture

	BOOL bLineDir = vt_job_info[nJob].model_info.getAlignInfo().getAlignmentTargetDir();
	if (bSubDir) {
		bLineDir = vt_job_info[nJob].model_info.getAlignInfo().getInspectionSubDir();
	}
	m_stInsp_DistanceResult[real_cam][nPos].nInspMethodType = nInspMethod;
	m_stInsp_DistanceResult[real_cam][nPos].bInspMethodDir = bLineDir;

	switch (nInspMethod)
	{
	case DISTANCE_INSP_METHOD_M_TO_M: // Mark ( Panel )
	case DISTANCE_INSP_METHOD_M_TO_E: // Mark ( Panel )
	default:
	{
		////////////////// Position 1 Mark 찾기
		if (GetMatching(nJob).findPattern(pImage, nCam, POINT_PANEL, W, H))
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = TRUE;
			double posX1 = GetMatching(nJob).getFindInfo(nCam, POINT_PANEL).GetXPos();
			double posY1 = GetMatching(nJob).getFindInfo(nCam, POINT_PANEL).GetYPos();

			m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL] = posX1;
			m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL] = posY1;
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = FALSE;
		}
	}
	break;
	case DISTANCE_INSP_METHOD_E_TO_E: //Edge ( Panel ) 
	{
		int nMethod = vt_job_info[nJob].algo_method;
		//if (nMethod != CLIENT_TYPE_PCB_DISTANCE_INSP)
		{
			// Bending 검사 Panel 찾을 때는 Fixture 반영 하지 않도록.
			double fixtureX = 0, fixtureY = 0, posX = 0, posY = 0;
			GetMatching(nJob).findPattern(pImage, nCam, nPos, W, H); //panel
			fixtureX = GetMatching(nJob).getFixtureX(nCam, nPos);
			fixtureY = GetMatching(nJob).getFixtureY(nCam, nPos);
			posX = GetMatching(nJob).getFindInfo(nCam, nPos).GetXPos();
			posY = GetMatching(nJob).getFindInfo(nCam, nPos).GetYPos();

			if (fixtureX != 0.0 && fixtureY != 0.0)
			{
				dx = posX - fixtureX; dy = posY - fixtureY;
				dt = 0.0;
			}
		}

		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].processCaliper(pImage, W, H, dx, dy, dt, FALSE);
		m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].processCaliper(pImage, W, H, dx, dy, dt, FALSE);

		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].m_lineInfo;
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].m_lineInfo;
		bFindLine[0] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_VERT].getIsMakeLine();
		bFindLine[1] = m_pDlgCaliper->m_Caliper[real_cam][nPos][CALIPER_PANEL_HORI].getIsMakeLine();

		if (bFindLine[0] && bFindLine[1])
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = TRUE;

			sLine lineHori = line_info[0];
			sLine lineVert = line_info[1];

			m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_VERT] = line_info[0];
			m_stInsp_DistanceResult[real_cam][nPos].line[FIND_CALIPER_PANEL_HORI] = line_info[1];

			CCaliper::cramersRules(-lineHori.a, 1, -lineVert.a, 1, lineHori.b, lineVert.b, &posx[POINT_PANEL], &posy[POINT_PANEL]);

			
		}
		else
		{
			m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PANEL] = FALSE;
			break;
		}

		// PANEL 찾은 교차점 저장
		m_stInsp_DistanceResult[real_cam][nPos].nPos = nPos;
		m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PANEL] = posx[POINT_PANEL];
		m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PANEL] = posy[POINT_PANEL];
	}
	break;
	}

	//////////////////////////////////////////////////////////////////////////////////
	///////////////////// algorithm_AssembleInsp_CALC

	/// 기준 되는 위치 Position 3번 찾기
	if (GetMatching(nJob).findPattern(pImage, nCam, 2, W, H))
	{
		m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = TRUE;
		double posX1 = GetMatching(nJob).getFindInfo(nCam, 2).GetXPos();
		double posY1 = GetMatching(nJob).getFindInfo(nCam, 2).GetYPos();

		m_stInsp_DistanceResult[real_cam][nPos].xPos[POINT_PROTRUDING] = posX1;
		m_stInsp_DistanceResult[real_cam][nPos].yPos[POINT_PROTRUDING] = posY1;
	}
	else
	{
		m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = FALSE;
	}

	double posCurX = GetMatching(nJob).getFindInfo(nCam, 2).GetXPos();
	double posCurY = GetMatching(nJob).getFindInfo(nCam, 2).GetYPos();
	int nreadId = 0;
	double posX[4] = { 0, }, posY[4] = { 0, }, posX1, posY1, radians, curdegrees;
	double posRX[4] = { 0, }, posRY[4] = { 0, };
	double posNX[4] = { 0, }, posNY[4] = { 0, };
	double posTheta[4] = { 0, }, posDistance[4] = { 0, };
	// 0    1
	// 2    3 순서 인경우
	GetMachine(nJob).PixelToWorld(nCam, 0, posCurX, posCurY, &posCurX, &posCurY, FALSE);

#ifndef _USEPLC_ADDRESS
	long* lData = new long[32];
	int addr_wd_curr_calib_data = 15300; // R15300 검사 영역으로 변경
	g_CommPLC.GetWord(addr_wd_curr_calib_data, 32, lData);

	m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = TRUE;

	for (int i = 0; i < 2; i++)
	{
		posX[i] = MAKELONG(lData[i * 4], lData[i * 4 + 1]) / MOTOR_SCALE;
		posY[i] = MAKELONG(lData[i * 4 + 2], lData[i * 4 + 3]) / MOTOR_SCALE;
	}
	for (int i = 0; i < 2; i++)
	{
		posX[i + 2] = MAKELONG(lData[i * 4 + 8], lData[i * 4 + 9]) / MOTOR_SCALE;
		posY[i + 2] = MAKELONG(lData[i * 4 + 10], lData[i * 4 + 11]) / MOTOR_SCALE;
	}

	for (int k = 0; k < 4; k++)
	{
		posRX[k] = MAKELONG(lData[k * 4 + 16], lData[k * 4 + 17]) / MOTOR_SCALE;
		posRY[k] = MAKELONG(lData[k * 4 + 18], lData[k * 4 + 19]) / MOTOR_SCALE;
	}
#else
	strTemp.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, nreadId, m_nClientID, vt_job_info[nJob].main_object_id.c_str());

	for (int i = 9; i >= 0; i--)
	{
		strTemp.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, i, m_nClientID, vt_job_info[nJob].main_object_id.c_str());
		if (_access(strTemp, 0) == 0)
		{
			nreadId = i;
			break;
		}
	}

	strTemp.Format("%s\\InspResult_%d_%d_%s.txt", m_strComFolerName, nreadId, m_nClientID, vt_job_info[nJob].main_object_id.c_str());

	//strTemp = "D:\\InspResult_3_1234.txt"; //임시 테스트 사용

	if (_access(strTemp, 0) == 0)
	{
		m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = TRUE;

		ifstream openFile(strTemp);
		if (openFile.is_open()) {
			string line;

			getline(openFile, line); posX[0] = atof(line.c_str());
			getline(openFile, line); posY[0] = atof(line.c_str());
			getline(openFile, line); posX[1] = atof(line.c_str());
			getline(openFile, line); posY[1] = atof(line.c_str());
			getline(openFile, line); posX[2] = atof(line.c_str());
			getline(openFile, line); posY[2] = atof(line.c_str());
			getline(openFile, line); posX[3] = atof(line.c_str());
			getline(openFile, line); posY[3] = atof(line.c_str());

			for (int k = 0; k < 4; k++)
			{
				getline(openFile, line); posRX[k] = atof(line.c_str());
				getline(openFile, line); posRY[k] = atof(line.c_str());
			}
			openFile.close();			
		}
	}
	else
	{
		m_stInsp_DistanceResult[real_cam][nPos].bFindPattern[FIND_PCB_BOTTOM] = FALSE;
	}

#endif
	double pPanelTheata = atan2(posY[1] - posY[0], posX[1] - posX[0]) * 180.f / CV_PI;
	double pCurTheata = atan2(posCurY - posCurY, posCurX - posCurX) * 180.f / CV_PI;
	double pDiffTheata = 0;// pCurTheata - pPanelTheata;

	if (nCam > 1)
	{
		double CurX = posCurX;
		double CurY = H * 3. / 4.;

		GetMachine(nJob).PixelToWorld(nCam, 0, CurX, CurY, &CurX, &CurY, TRUE);
		posCurY = CurY + (CurY + posCurY);
	}

	posTheta[nCam] = (posRX[nCam] - posX[nCam % 2]) != 0 ? atan((posRY[nCam] - posY[nCam]) / (posRX[nCam] - posX[nCam % 2])) : 0;

	curdegrees = (posTheta[nCam] * (180.0 / CV_PI));

	radians = (curdegrees + pDiffTheata) * (CV_PI / 180.0);
	posDistance[nCam] = sqrt(pow(posRX[nCam] - posX[nCam % 2], 2) + pow(posRY[nCam] - posY[nCam ], 2));


	if (nCam % 2 == 0)	posNX[nCam] = posCurX - (posDistance[nCam] * cos(radians));
	else				posNX[nCam] = posCurX + (posDistance[nCam] * cos(radians));

	if (radians < 0)	posNY[nCam] = posCurY - (posDistance[nCam] * sin(radians));
	else 				posNY[nCam] = posCurY + (posDistance[nCam] * sin(radians));

	// 신규좌표로 계산
	GetMachine(nJob).WorldToPixel(nCam, 0, posNX[nCam], posNY[nCam], &posNX[nCam], &posNY[nCam]);

	m_stInsp_DistanceResult[real_cam][0].xPos[POINT_PCB_BOTTOM] = posNX[nCam];
	m_stInsp_DistanceResult[real_cam][0].yPos[POINT_PCB_BOTTOM] = posNY[nCam];
	posX1 = m_stInsp_DistanceResult[real_cam][0].xPos[POINT_PANEL];
	posY1 = m_stInsp_DistanceResult[real_cam][0].yPos[POINT_PANEL];

	GetMachine(nJob).PixelToWorld(nCam, 0, posNX[nCam], posNY[nCam], &posNX[nCam], &posNY[nCam], TRUE);
	GetMachine(nJob).PixelToWorld(nCam, 0, posX1, posY1, &posX1, &posY1, TRUE);

	m_stInsp_DistanceResult[real_cam][0].dDistance = sqrt(pow(posNX[nCam] - posX1, 2) + pow(posNY[nCam] - posY1, 2));
	m_stInsp_DistanceResult[real_cam][0].dWidthDistance = fabs(posNX[nCam] - posX1);
	m_stInsp_DistanceResult[real_cam][0].dHeightDistance = fabs(posNY[nCam] - posY1);		

	return bInspResult;
}
double CLET_AlignClientDlg::calcIncludedAngle(sLine line_hori, sLine line_vert)
{
	double angle = 0.0;

	double x[4];	// horiL / horiR / vertT / vertB
	double y[4];	// horiL / horiR / vertT / vertB
	double vtX[2];
	double vtY[2];


	x[0] = line_hori.sx - 300 * line_hori.mx;
	y[0] = line_hori.sy - 300 * line_hori.my;
	x[1] = line_hori.sx + 300 * line_hori.mx;
	y[1] = line_hori.sy + 300 * line_hori.my;

	x[2] = line_vert.sx - 300 * line_vert.mx;
	y[2] = line_vert.sy - 300 * line_vert.my;
	x[3] = line_vert.sx + 300 * line_vert.mx;
	y[3] = line_vert.sy + 300 * line_vert.my;


	vtX[0] = x[0] - x[1];
	vtY[0] = y[0] - y[1];

	vtX[1] = x[2] - x[3];
	vtY[1] = y[2] - y[3];

	double dotproduct = vtX[0] * vtX[1] + vtY[0] * vtY[1];
	double norm = sqrt(vtX[0] * vtX[0] + vtY[0] * vtY[0]) * sqrt(vtX[1] * vtX[1] + vtY[1] * vtY[1]);

	if (norm != 0)
	{
		double radian = acos(dotproduct / norm);
		angle = radian / 3.141592 * 180.0;
	}

	return angle;
}
double CLET_AlignClientDlg::make_included_angle_to_matching(double angle, int nJob)
{
	double spec = vt_job_info[nJob].model_info.getAlignInfo().getIncludedAngle();
	double diff = 0; 
	double rate = 100.0;

	if (spec != 0.0)
	{
		diff = fabs(angle - spec); // Top / Bottom
		rate = (spec - diff) / spec * 100.0;
	}

	return rate;
}

int CLET_AlignClientDlg::wait_flag_over_time(int wait_time, BOOL* pArrFlag, BOOL bResult, int start_1d_index, int num_of_1d, int widthStep, int start_2d_index, int num_of_2d, BOOL bVisual)
{
	MSG message;
	int nStick = GetTickCount();
	int nEtick = GetTickCount();
	BOOL all_flag_on = TRUE;
	CString str;

	BOOL InitSplash = FALSE;
	CSimpleSplashWnd* _splash = NULL;

	while (nEtick - nStick <= wait_time) {
		Sleep(10);
		if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&message);
			::DispatchMessage(&message);
		}
		nEtick = GetTickCount();

		all_flag_on = TRUE;

		// pArrFlag의 값들이 bResult가 아닐때 까지 대기
		for (int cam = start_2d_index; cam < start_2d_index + num_of_2d; cam++)
		{
			for (int pos = start_1d_index; pos < start_1d_index + num_of_1d; pos++)
			{
				if (pArrFlag[cam * widthStep + pos] == bResult)
				{
					all_flag_on = FALSE;
				}
			}
		}

		if (all_flag_on == TRUE)
		{
			break;
		}

		if (bVisual != TRUE) continue;

		if (nEtick - nStick > (wait_time / 4))
		{
			if (InitSplash != TRUE)
			{
				_splash = new CSimpleSplashWnd;
				_splash->Create(this, IDB_BMP_LOADING);
				InitSplash = TRUE;
			}
			else
			{
				double nProcess = (fabs(nEtick - nStick) / wait_time) * 100;
				str.Format("  Wait Timer..%.1f%%", nProcess);
				_splash->SetStatusText((LPCSTR)str, (int)nProcess);
				Sleep(10);
			}
		}
	}

	if (_splash != NULL) delete _splash;

	if (all_flag_on != TRUE) return -1;

	return 0;
}

BOOL CLET_AlignClientDlg::OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	//if (!m_bAutoStart) return TRUE;

	//switch (pCopyDataStruct->dwData) {
	//	case MM_TEST_DATA:
	//	{	
	//		char* p_data = (char*)pCopyDataStruct->lpData;
	//		m_strMicroFludicData = p_data;
	//		::PostMessageA(m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_MF_UPDATE, (LPARAM)&m_strMicroFludicData);
	//	}
	//	break;
	//}
	

	return CDialogEx::OnCopyData(pWnd, pCopyDataStruct);
}
LRESULT CLET_AlignClientDlg::OnMessageFunc(WPARAM wParam, LPARAM lParam)
{
	int nType = wParam;
	double dData = lParam;
	if (nType == 0)
	{
		//KJH 2021-09-02 mBar->kPa
		//m_strDopoValue.Format("%.4f mBar", dData / 10000);
		m_strDopoValue.Format("%.4f kPa", dData / 10000);
	}
	else if (nType == 1)
	{
		//KJH 2021-09-02 mBar->kPa
		//m_strSuckValue.Format("%.4f mBar", dData / 10000);
		m_strSuckValue.Format("%.4f kPa", dData / 10000);
	}
	::PostMessage(m_pPane[PANE_AUTO]->GetSafeHwnd(), WM_VIEW_CONTROL, MSG_MF_UPDATE, nType);
	return 0;
}

void CLET_AlignClientDlg::EllipseRot(CDC* pDC, sEllipse& ellipse)
{
	double ct = cos(ellipse.theta);
	double st = sin(ellipse.theta);

	for (int i = 0; i <= 360; i += 1) {
		double a = i * M_PI / 180.;
		double x = ellipse.w*cos(a);
		double y = ellipse.h*sin(a);

		double rx = x * ct - y * st;
		double ry = x * st + y * ct;

		if (!i) pDC->MoveTo((int)(ellipse.cx + rx), (int)(ellipse.cy + ry));
		else    pDC->LineTo((int)(ellipse.cx + rx), (int)(ellipse.cy + ry));
	}
}

void CLET_AlignClientDlg::read_trace_data(CString str_path)
{
	CString str_data, str_key;
	char cData[MAX_PATH] = { 0, };

	int size = 0;

	::GetPrivateProfileString("INFO", "COUNT", 0, cData, MAX_PATH, str_path);

	size = atoi(cData);
	if (size == 0)
	{
	//	AfxMessageBox("Data NULL");
		return;
	}

	m_vtTraceData.clear();

	cv::Point2f temp_pt;
	for (int i = 0; i < size; i++)
	{
		str_key.Format("%d_X", i + 1);
		::GetPrivateProfileString("INFO", str_key, 0, cData, MAX_PATH, str_path);
		temp_pt.x = atof(cData);

		str_key.Format("%d_Y", i + 1);
		::GetPrivateProfileString("INFO", str_key, 0, cData, MAX_PATH, str_path);
		temp_pt.y = atof(cData);

		m_vtTraceData.push_back(temp_pt);
	}

	if (m_vtTraceData.size() > 0)
	{
		notch_wetout_data.pt_center.clear();
		for (int i = 0; i < m_vtTraceData.size(); i++)
			notch_wetout_data.pt_center.push_back(m_vtTraceData[i]);
	}
}
void CLET_AlignClientDlg::read_trace_mask_data(CString str_path)
{
	std::vector<cv::Point> 	m_sDataRead;
	int m_nUINumber = 0;

	FILE* fp;
	fopen_s(&fp, str_path, "rb");
	if (fp)
	{
		m_ELB_vtMaskContour.clear();
		fread(&m_nUINumber, sizeof(int), 1, fp);
		for (int i = 0; i < m_nUINumber; i++)
		{
			cv::Point sDataRead;
			fread(&sDataRead, sizeof(cv::Point), 1, fp);
			m_ELB_vtMaskContour.push_back(sDataRead);
		}
		fclose(fp);
	}

	if (m_vtTraceData.size() > 0)
	{
		CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

		double xres = MAX(0.00001, GetMachine(0).getCameraResolutionX(0, 0));
		double distanceT = 0.2 / xres;
		cv::Point2f rC;
		pFormMain->m_vecInterSectionPoint.clear();
		for (int i = 0; i < m_vtTraceData.size() - 1; i++)
		{
			rC = Equation_of_Lines(m_vtTraceData[i], m_vtTraceData[i + 1], distanceT, false, true);
			pFormMain->m_vecInterSectionPoint.push_back(rC);
		}
		rC = cv::Point2f(m_vtTraceData[m_vtTraceData.size() - 1].x, m_vtTraceData[m_vtTraceData.size() - 1].y + distanceT);
		pFormMain->m_vecInterSectionPoint.push_back(rC);

		m_ELB_TraceResult.m_vTraceProfile[3].clear();
		m_ELB_TraceResult.m_vTraceProfile[4].clear();

		for (int i = 0; i < m_vtTraceData.size() ; i++)
		{
			m_ELB_TraceResult.m_vTraceProfile[0].push_back(m_vtTraceData[i].x);
			m_ELB_TraceResult.m_vTraceProfile[1].push_back(m_vtTraceData[i].y);
			m_ELB_TraceResult.m_vTraceProfile[2].push_back(0);
			m_ELB_TraceResult.m_vTraceProfile[3].push_back(m_vtTraceData[i].x);
			m_ELB_TraceResult.m_vTraceProfile[4].push_back(m_vtTraceData[i].y);
		}
	}
}
void CLET_AlignClientDlg::read_metal_trace_data(CString str_path)
{
	CString str_data, str_key;
	char cData[MAX_PATH] = { 0, };

	int size = 0;

	::GetPrivateProfileString("INFO", "COUNT", 0, cData, MAX_PATH, str_path);

	size = atoi(cData);
	if (size == 0)
	{
		//	AfxMessageBox("Data NULL");
		return;
	}

	m_vtTraceData_MetalGold.clear();
	notch_wetout_data.pt_metal.clear();

	cv::Point2f temp_pt;
	for (int i = 0; i < size; i++)
	{
		str_key.Format("%d_X", i + 1);
		::GetPrivateProfileString("INFO", str_key, 0, cData, MAX_PATH, str_path);
		temp_pt.x = atof(cData);

		str_key.Format("%d_Y", i + 1);
		::GetPrivateProfileString("INFO", str_key, 0, cData, MAX_PATH, str_path);
		temp_pt.y = atof(cData);

		m_vtTraceData_MetalGold.push_back(temp_pt);
		notch_wetout_data.pt_metal.push_back(temp_pt);
	}
}

void CLET_AlignClientDlg::add_process_history_machine(CString strText)
{
	::SendMessageA(m_pPane[PANE_MACHINE]->m_hWnd, WM_VIEW_CONTROL, MSG_PMC_ADD_PROCESS_HISTORY, (LPARAM)&strText);
}
void CLET_AlignClientDlg::add_process_history(CString strText)
{
	::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strText);
}

void CLET_AlignClientDlg::single_grab(int nCam)
{
#ifdef _DAHUHA
	if (m_pDahuhaCam[nCam].isconnected())		m_pDahuhaCam[nCam].grabSingle();
#else
	if (m_pBaslerCam[nCam])	m_pBaslerCam[nCam]->SingleGrab();
#endif
}

void CLET_AlignClientDlg::initialize_job()
{
	for(int i = 0; i < vt_job_info.size(); i++)
	{
		g_Job_1Cam1ShotAlign[i].m_pMain = this;
		g_Job_1Cam1ShotAlign[i].init_job(i);		
		m_PatternMatching[i].init_job(i);
	}
}

BOOL CLET_AlignClientDlg::write_NGresult_SummaryFile(CString serialNum, CString Msg,BOOL bjudge, int algorithm)
{
	EnterCriticalSection(&m_csScanWrite);

	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	CString strTemp, Time_str, Date_str, str_modelID, strSummary;
	CString strFileDir = m_strResultDir + m_strResultDate[algorithm];
	BOOL bWriteHeaderSummary = FALSE;

	CString algo_name = vt_job_info[algorithm].job_name.c_str();
	
	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);

	if (m_strResultTime[algorithm] == "")	Time_str.Format("%02d_%02d_%02d", csTime.wHour, csTime.wMinute, csTime.wSecond);
	else Time_str = m_strResultTime[algorithm];

	if (m_strResultDate[algorithm] == "")	Date_str.Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);
	else Date_str = m_strResultDate[algorithm];

	//D:\LET_AlignClient\Result\Files//
	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	//D:\LET_AlignClient\Result\Files\DATE//
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[algorithm].model_info.getModelID());
	strFileDir.Format("%s\\%s", strFileDir, str_modelID);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	strSummary.Format("%s\\%s_ProcSummary_Result.csv", strFileDir, algo_name);

	if ((_access(strSummary, 0)) == -1)		bWriteHeaderSummary = TRUE;

	CStdioFile SummaryFile;	
	if (SummaryFile.Open(strSummary, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strSummary.Mid(strSummary.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		LeaveCriticalSection(&m_csScanWrite);
		return 0;
	}
	
	CString strHeader, strBody;

	strTemp.Format("TIME");							strHeader += strTemp;
	strTemp.Format("%s", Time_str);					strBody += strTemp;

	strTemp.Format(",MODEL ID");					strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);	strBody += strTemp;

	strTemp.Format(",PANEL ID");					strHeader += strTemp;
	strTemp.Format(",%s", serialNum);				strBody += strTemp;
	
	strTemp.Format(",JUDGE");						strHeader += strTemp;
	strTemp.Format(",%s", bjudge ? "OK" : "NG");	strBody += strTemp;	

	strTemp.Format(",SUMMARY");					    strHeader += strTemp;
	strTemp.Format(",%s", Msg);	                    strBody += strTemp;

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeaderSummary)		SummaryFile.WriteString(strHeader);

	SummaryFile.SeekToEnd();
	SummaryFile.WriteString(strBody);
	SummaryFile.Close();

	LeaveCriticalSection(&m_csScanWrite);

	return TRUE;
}

int CLET_AlignClientDlg::copy_caliper_data(int src_cam, int src_pos, int src_line, int dst_job, int dst_cam, int dst_pos, int dst_line)
{
	int real_cam = vt_job_info[dst_job].camera_index[dst_cam];

	CCaliper* pCaliper = &m_pDlgCaliper->m_Caliper[real_cam][dst_pos][dst_line];
	m_pDlgCaliper->m_Caliper[src_cam][src_pos][src_line].copy_caliper_info(pCaliper);
	m_pDlgCaliper->m_bChanged[real_cam][dst_pos][dst_line] = TRUE;

	pCaliper->init_caliper_info();

	if (pCaliper->getCircleCaliper())	pCaliper->calcCaliperCircle();
	else								pCaliper->calcCaliperRect();

	return 0;
}
void CLET_AlignClientDlg::init_copy_caliper_info()
{
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyJob.ResetContent();
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyCam.ResetContent();
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyPos.ResetContent();
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyLine.ResetContent();

	int job = 0;

	CString str_temp;
	for (int i = 0; i < vt_job_info.size(); i++)
	{
		str_temp.Format("%s", vt_job_info[i].get_job_name());
		m_pDlgCaliper->m_pCaliperParam->m_cbCopyJob.AddString(str_temp);
	}

	for (int i = 0; i < vt_job_info[job].camera_index.size(); i++)
	{
		int real_cam = vt_job_info[job].camera_index[i];
		str_temp.Format("%s", m_stCamInfo[real_cam].cName);
		m_pDlgCaliper->m_pCaliperParam->m_cbCopyCam.AddString(str_temp);
	}

	if (vt_job_info[job].camera_index.size() > 0)
	{
		for (int i = 0; i < vt_job_info[job].num_of_position; i++)
		{
			str_temp.Format("%s", vt_job_info[job].position_name[0][i].c_str());
			m_pDlgCaliper->m_pCaliperParam->m_cbCopyPos.AddString(str_temp);
		}

		for (int i = 0; i < MAX_CALIPER_LINES; i++)
		{
			if (i < vt_job_info[job].caliper_name[0][0].size())	str_temp.Format("%s", vt_job_info[job].caliper_name[0][0][i].c_str());
			else													str_temp.Format("LINE %d", i + 1);

			m_pDlgCaliper->m_pCaliperParam->m_cbCopyLine.AddString(str_temp);
		}
	}

	m_pDlgCaliper->m_pCaliperParam->m_cbCopyJob.SetCurSel(job);
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyCam.SetCurSel(0);
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyPos.SetCurSel(0);
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyLine.SetCurSel(0);
}
void CLET_AlignClientDlg::display_copy_caliper_info()
{
	int job = m_pDlgCaliper->m_pCaliperParam->m_cbCopyJob.GetCurSel();
	int cam = m_pDlgCaliper->m_pCaliperParam->m_cbCopyCam.GetCurSel();
	int pos = m_pDlgCaliper->m_pCaliperParam->m_cbCopyPos.GetCurSel();
	int line = m_pDlgCaliper->m_pCaliperParam->m_cbCopyLine.GetCurSel();


	m_pDlgCaliper->m_pCaliperParam->m_cbCopyJob.ResetContent();
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyCam.ResetContent();
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyPos.ResetContent();
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyLine.ResetContent();

	CString str_temp;
	for (int i = 0; i < vt_job_info.size(); i++)
	{
		str_temp.Format("%s", vt_job_info[i].get_job_name());
		m_pDlgCaliper->m_pCaliperParam->m_cbCopyJob.AddString(str_temp);
	}
	
	for (int i = 0; i < vt_job_info[job].camera_index.size(); i++)
	{
		int real_cam = vt_job_info[job].camera_index[i];
		str_temp.Format("%s", m_stCamInfo[real_cam].cName);
		m_pDlgCaliper->m_pCaliperParam->m_cbCopyCam.AddString(str_temp);
	}

	if (vt_job_info[job].camera_index.size() > 0)
	{
		for (int i = 0; i < vt_job_info[job].num_of_position; i++)
		{
			str_temp.Format("%s", vt_job_info[job].position_name[cam][i].c_str());
			m_pDlgCaliper->m_pCaliperParam->m_cbCopyPos.AddString(str_temp);
		}

		for (int i = 0; i < MAX_CALIPER_LINES; i++)
		{
			if (i < vt_job_info[job].caliper_name[cam][pos].size())	str_temp.Format("%s", vt_job_info[job].caliper_name[cam][pos][i].c_str());
			else													str_temp.Format("LINE %d", i + 1);

			m_pDlgCaliper->m_pCaliperParam->m_cbCopyLine.AddString(str_temp);
		}
	}

	m_pDlgCaliper->m_pCaliperParam->m_cbCopyJob.SetCurSel(job);
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyCam.SetCurSel(0);
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyPos.SetCurSel(0);
	m_pDlgCaliper->m_pCaliperParam->m_cbCopyLine.SetCurSel(0);
}
BOOL CLET_AlignClientDlg::judge_film_inspection(int nJob, int nCam)
{
	BOOL bResult = TRUE;

	double spec_lx		= vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(0);
	double spec_lx_tor  = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(0);
	double spec_rx		= vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(1);
	double spec_rx_tor	= vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(1);

	double spec_ly = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(2);
	double spec_ly_tor = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(2);
	double spec_ry = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpec(3);
	double spec_ry_tor = vt_job_info[nJob].model_info.getAlignInfo().getDistanceInspSubSpecTolerance(3);
	double spec_min, spec_max, value;

	//KJH 2022-04-02 짧은 Tape 검사시 거리값 계산은 스칼라 계산. 입력은 벡터로받아야 되는 문제(가이드선 때문에 스펙은 벡터로)
	spec_lx = abs(spec_lx);
	spec_ly = abs(spec_ly);
	spec_rx = abs(spec_rx);
	spec_ry = abs(spec_ry);

	spec_min = spec_lx - spec_lx_tor;
	spec_max = spec_lx + spec_lx_tor;

	//HSJ 2022-01-08고객요청으로 필름검사 기준점(Center,Left,Right)다 표시할 수 있도록, 스펙은 우선 센터로...
	//KJH 2022-03-15 고객 요청으로 각 L, R 에서의 거리로 스펙 판정 변경
	//LCX -> LX
	//HSJ 2022-03-16 method에 따라 판정기준 구분
	int method = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmInspMethod();

	if (method == 4)
	{
		value = vt_result_info[nJob].pf_film_insp_data.dist_lx[1];
	}
	else
	{
		value = vt_result_info[nJob].pf_film_insp_data.dist_lx[0];
	}

	if (value < spec_min || value > spec_max)	vt_result_info[nJob].pf_film_insp_data.judge[0] = FALSE;
	else										vt_result_info[nJob].pf_film_insp_data.judge[0] = TRUE;

	vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[0] = value;

	spec_min = spec_rx - spec_rx_tor;
	spec_max = spec_rx + spec_rx_tor;

	//HSJ 2022-01-08고객요청으로 필름검사 기준점(Center,Left,Right)다 표시할 수 있도록, 스펙은 우선 센터로...
	//KJH 2022-03-15 고객 요청으로 각 L, R 에서의 거리로 스펙 판정 변경
	//RCX -> RX
	//HSJ 2022-03-16 method에 따라 판정기준 구분
	if (method == 4)
	{
		value = vt_result_info[nJob].pf_film_insp_data.dist_rx[2];
	}
	else
	{
		value = vt_result_info[nJob].pf_film_insp_data.dist_rx[0];
	}

	if (value < spec_min || value > spec_max)	vt_result_info[nJob].pf_film_insp_data.judge[1] = FALSE;
	else										vt_result_info[nJob].pf_film_insp_data.judge[1] = TRUE;

	vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[1] = value;

	spec_min = spec_ly - spec_ly_tor;
	spec_max = spec_ly + spec_ly_tor;

	//HSJ 2022-01-08고객요청으로 필름검사 기준점(Center,Left,Right)다 표시할 수 있도록, 스펙은 우선 센터로...
	//KJH 2022-03-15 고객 요청으로 각 L, R 에서의 거리로 스펙 판정 변경
	//LCY -> LY
	//HSJ 2022-03-16 method에 따라 판정기준 구분
	if (method == 4)
	{
		value = vt_result_info[nJob].pf_film_insp_data.dist_ly[1];
	}
	else
	{
		value = vt_result_info[nJob].pf_film_insp_data.dist_ly[0];
	}

	if (value < spec_min || value > spec_max)	vt_result_info[nJob].pf_film_insp_data.judge[2] = FALSE;
	else										vt_result_info[nJob].pf_film_insp_data.judge[2] = TRUE;

	vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[2] = value;

	spec_min = spec_ry - spec_ry_tor;
	spec_max = spec_ry + spec_ry_tor;

	//HSJ 2022-01-08고객요청으로 필름검사 기준점(Center,Left,Right)다 표시할 수 있도록, 스펙은 우선 센터로...
	//KJH 2022-03-15 고객 요청으로 각 L, R 에서의 거리로 스펙 판정 변경
	//RCY -> RY
	//HSJ 2022-03-16 method에 따라 판정기준 구분
	if (method == 4)
	{
		value = vt_result_info[nJob].pf_film_insp_data.dist_ry[2];
	}
	else
	{
		value = vt_result_info[nJob].pf_film_insp_data.dist_ry[0];
	}

	if (value < spec_min || value > spec_max)	vt_result_info[nJob].pf_film_insp_data.judge[3] = FALSE;
	else										vt_result_info[nJob].pf_film_insp_data.judge[3] = TRUE;

	vt_result_info[nJob].pf_film_insp_data.dbTarget_Value[3] = value;

	if (vt_result_info[nJob].pf_film_insp_data.judge[0] && vt_result_info[nJob].pf_film_insp_data.judge[1] && vt_result_info[nJob].pf_film_insp_data.judge[2] && vt_result_info[nJob].pf_film_insp_data.judge[3])
	{
		// hsj 2022-02-08 필름검사 L check 기능 추가
		if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getPanelLcheckEnable() || vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLcheckEnable())
		{
			if (nFilmInspect[nJob][0] == 1 || nFilmInspect[nJob][1] == 1)
				bResult = FALSE;
			else bResult = TRUE;
		}
		else bResult = TRUE;
	}
	else
		bResult = FALSE;

	vt_result_info[nJob].pf_film_insp_data.final_judge = bResult;

	return bResult;
}
BOOL CLET_AlignClientDlg::calculate_film_distance(BYTE* pImage, int nJob, int nCam)
{
	int real_cam = vt_job_info[nJob].camera_index[nCam];
	BOOL bResult = TRUE;
	double pos_x = 0.0, pos_y = 0.0;
	double panel_x[2] = { 0, };
	double panel_y[2] = { 0, };
	double film_x[2] = { 0, };
	double film_y[2] = { 0, };

	double panel_x_robot[2] = { 0, };
	double panel_y_robot[2] = { 0, };
	double film_x_robot[2] = { 0, };
	double film_y_robot[2] = { 0, };

	//hsj 2022-01-08 고객요청사항으로 디스플레이에 모든 길이 나타나게 계산값 수정 ________START
	double panel_px[3] = { 0.0, };
	double panel_py[3] = { 0.0, };
	
	double panel_cx_multi = 0.0;
	double panel_cy_multi = 0.0;
	double temp_x = 0.0;
	double temp_y = 0.0;

	int w = vt_job_info[nJob].camera_size[nCam].x;
	int h = vt_job_info[nJob].camera_size[nCam].y;

	sLine line_panel = { 0, };							// panel edge의 직선 정보
	//hsj 2022-01-08 고객요청사항으로 CENTER,LEFT,RIGHT 기준으로도 정보 나타내주기
	sLine normal_line_panel[3] = { 0, };			// 0: panel edge center, 1: panel edge left, 2: panel edge right 
	sPoint pt[2] = { 0, };

	if (GetMatching(nJob).getFindInfo(nCam, 0).GetFound() != FIND_OK || GetMatching(nJob).getFindInfo(nCam, 1).GetFound() != FIND_OK)
	{
		bResult = FALSE;
		return bResult;
	}

	panel_x[0] = GetMatching(nJob).getFindInfo(nCam, 0).GetXPos();
	panel_y[0] = GetMatching(nJob).getFindInfo(nCam, 0).GetYPos();
	panel_x[1] = GetMatching(nJob).getFindInfo(nCam, 1).GetXPos();
	panel_y[1] = GetMatching(nJob).getFindInfo(nCam, 1).GetYPos();

	film_x[0] = GetMatching(nJob).getFindInfo(nCam, 2).GetXPos();
	film_y[0] = GetMatching(nJob).getFindInfo(nCam, 2).GetYPos();
	film_x[1] = GetMatching(nJob).getFindInfo(nCam, 3).GetXPos();
	film_y[1] = GetMatching(nJob).getFindInfo(nCam, 3).GetYPos();

	// notch의 거리가 짧아서 y좌표가 조금만 틀어져도 theta 변화가 심해.
	// 캘리퍼로 더 먼 간격으로 찾아서 theta 반영하자.
	if (vt_job_info[nJob].model_info.getAlignInfo().getMarkFindMethod() == METHOD_MATCHING_LINE_THETA)
	{
		sLine line_info[2];
		line_info[0] = m_pDlgCaliper->m_Caliper[real_cam][0][0].m_lineInfo;
		line_info[1] = m_pDlgCaliper->m_Caliper[real_cam][1][0].m_lineInfo;

		// 양쪽 캘리퍼를 모두 찾았을때 
		if (m_pDlgCaliper->m_Caliper[real_cam][0][0].getIsMakeLine() && m_pDlgCaliper->m_Caliper[real_cam][1][0].getIsMakeLine())
		{
			sLine caliper_line_info;

			pt[0].x = line_info[0].sx;
			pt[0].y = line_info[0].sy;
			pt[1].x = line_info[1].sx;
			pt[1].y = line_info[1].sy;
			GetMatching(nJob).compute_model_parameter(pt, 2, caliper_line_info);

			// panel을 찾은 좌표들은 caliper line 선상으로 이동시키자.
			panel_y[0] = caliper_line_info.a * panel_x[0] + caliper_line_info.b;
			panel_y[1] = caliper_line_info.a * panel_x[1] + caliper_line_info.b;
		}
	}

	GetMachine(nJob).PixelToWorld(nCam, 0, panel_x[0], panel_y[0], &panel_x_robot[0], &panel_y_robot[0]);
	GetMachine(nJob).PixelToWorld(nCam, 0, panel_x[1], panel_y[1], &panel_x_robot[1], &panel_y_robot[1]);
	GetMachine(nJob).PixelToWorld(nCam, 0, film_x[0], film_y[0], &film_x_robot[0], &film_y_robot[0]);
	GetMachine(nJob).PixelToWorld(nCam, 0, film_x[1], film_y[1], &film_x_robot[1], &film_y_robot[1]);

	//HSJ 필름검사 Method
	//0:Center (패널 양끝의 가운데에서 필름 Left로 스펙 측정)
	//1:Left   (패널 왼쪽마크에서 필름 Left로 스펙 측정)
	//2:Right  (패널 오른쪽마크에서 필름 Right로 스펙 측정)
	panel_px[0] = (panel_x_robot[0] + panel_x_robot[1]) / 2.0;
	panel_py[0] = (panel_y_robot[0] + panel_y_robot[1]) / 2.0;

	panel_px[1] = panel_x_robot[0];
	panel_py[1] = panel_y_robot[0];

	panel_px[2] = panel_x_robot[1];
	panel_py[2] = panel_y_robot[1];

	// panel의 직선 방정식을 구하자.
	pt[0].x = panel_x_robot[0];
	pt[0].y = panel_y_robot[0];
	pt[1].x = panel_x_robot[1];
	pt[1].y = panel_y_robot[1];
	GetMatching(nJob).compute_model_parameter(pt, 2, line_panel);
	
	// y = ax + b
	// b = y - ax
	// panel center,left,right를 지나는 직선 방정식을 구하자.
	double dist_lx[3] = { 0.0, }, dist_ly[3] = { 0.0, }, dist_rx[3] = { 0.0, }, dist_ry[3] = { 0.0, };

	for (int i = 0; i < 3; i++)
	{
		normal_line_panel[i].a = -1.0 / line_panel.a;
		normal_line_panel[i].b = panel_py[i] - (panel_px[i] * normal_line_panel[i].a);

		// x = (y - b) / a
		temp_y = 0;
		temp_x = -normal_line_panel[i].b / normal_line_panel[i].a;
		pt[0].x = temp_x;
		pt[0].y = temp_y;
		pt[1].x = panel_px[i];
		pt[1].y = panel_py[i];
		GetMatching(nJob).compute_model_parameter(pt, 2, normal_line_panel[i]);

		if (GetMatching(nJob).getFindInfo(nCam, 2).GetFound() == FIND_OK)
		{
			pt[0].x = film_x_robot[0];
			pt[0].y = film_y_robot[0];
			// panel의 직선 방정식과 film간의 y값을 계산하자
			dist_ly[i] = GetMatching(nJob).compute_distance(line_panel, pt[0]);

			// panel 센터를 지나는 법선 방정식과 film간의 x값을 계산하자
			dist_lx[i] = GetMatching(nJob).compute_distance(normal_line_panel[i], pt[0]);

		}

		if (GetMatching(nJob).getFindInfo(nCam, 3).GetFound() == FIND_OK)
		{
			pt[0].x = film_x_robot[1];
			pt[0].y = film_y_robot[1];

			dist_ry[i] = GetMatching(nJob).compute_distance(line_panel, pt[0]);
			dist_rx[i] = GetMatching(nJob).compute_distance(normal_line_panel[i], pt[0]);
		}

		// hsj 2022-01-27 필름검사 scale 값 반영
		if (vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmScaleEnable())
		{
			double dlx, dly, drx, dry;
			dlx= vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLXScale();
			dly= vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmLYScale();
			drx= vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmRXScale();
			dry= vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmRYScale();

			vt_result_info[nJob].pf_film_insp_data.dist_lx[i] = dist_lx[i]*dlx;
			vt_result_info[nJob].pf_film_insp_data.dist_ly[i] = dist_ly[i]*dly;
			vt_result_info[nJob].pf_film_insp_data.dist_rx[i] = dist_rx[i]*drx;
			vt_result_info[nJob].pf_film_insp_data.dist_ry[i] = dist_ry[i]*dry;
		}
		else
		{
			vt_result_info[nJob].pf_film_insp_data.dist_lx[i] = dist_lx[i];
			vt_result_info[nJob].pf_film_insp_data.dist_ly[i] = dist_ly[i];
			vt_result_info[nJob].pf_film_insp_data.dist_rx[i] = dist_rx[i];
			vt_result_info[nJob].pf_film_insp_data.dist_ry[i] = dist_ry[i];
		}
		vt_result_info[nJob].pf_film_insp_data.line_panel = line_panel;
		vt_result_info[nJob].pf_film_insp_data.normal_line_panel[i] = normal_line_panel[i];

	}

	//hsj 2022-01-08 고객요청사항으로 디스플레이에 모든 길이 나타나게 계산값 수정 ________END

	vt_result_info[nJob].pf_film_insp_data.panel_pos_x[0] = GetMatching(nJob).getFindInfo(nCam, 0).GetXPos();
	vt_result_info[nJob].pf_film_insp_data.panel_pos_x[1] = GetMatching(nJob).getFindInfo(nCam, 1).GetXPos();
	vt_result_info[nJob].pf_film_insp_data.film_pos_x[0]  = GetMatching(nJob).getFindInfo(nCam, 2).GetXPos();
	vt_result_info[nJob].pf_film_insp_data.film_pos_x[1]  = GetMatching(nJob).getFindInfo(nCam, 3).GetXPos();
	vt_result_info[nJob].pf_film_insp_data.panel_pos_y[0] = GetMatching(nJob).getFindInfo(nCam, 0).GetYPos();
	vt_result_info[nJob].pf_film_insp_data.panel_pos_y[1] = GetMatching(nJob).getFindInfo(nCam, 1).GetYPos();
	vt_result_info[nJob].pf_film_insp_data.film_pos_y[0] = GetMatching(nJob).getFindInfo(nCam, 2).GetYPos();
	vt_result_info[nJob].pf_film_insp_data.film_pos_y[1] = GetMatching(nJob).getFindInfo(nCam, 3).GetYPos();

	if(panel_x_robot[1] != panel_x_robot[0])	vt_result_info[nJob].pf_film_insp_data.panel_angle = atan((panel_y_robot[1] - panel_y_robot[0]) / (panel_x_robot[1] - panel_x_robot[0])) / 3.141592 * 180.0;
	if(film_x_robot[1] != film_x_robot[0])		vt_result_info[nJob].pf_film_insp_data.film_angle = atan((film_y_robot[1] - film_y_robot[0]) / (film_x_robot[1] - film_x_robot[0])) / 3.141592 * 180.0;

	if (GetMatching(nJob).getFindInfo(nCam, 0).GetFound() == FIND_OK && GetMatching(nJob).getFindInfo(nCam, 1).GetFound() == FIND_OK && GetMatching(nJob).getFindInfo(nCam, 2).GetFound() == FIND_OK && GetMatching(nJob).getFindInfo(nCam, 3).GetFound() == FIND_OK)
		vt_result_info[nJob].pf_film_insp_data.attach_angle = vt_result_info[nJob].pf_film_insp_data.panel_angle - vt_result_info[nJob].pf_film_insp_data.film_angle;
	else
		vt_result_info[nJob].pf_film_insp_data.attach_angle = 0.0;

	return bResult;
}

BOOL CLET_AlignClientDlg::LightControllerTurnOnOff(int nJob, int nCam, int nIndex, BOOL bTotal, BOOL OnOff, BOOL SubLightOff)
{
	//Defalut = FALSE
	//bTotal = True -> Job Total Light Turn On / False -> Cam Total Light Turn On
	//OnOff  = True -> Turnoff
	//SubLightOff = Only Main Light Use Mode

	if (bTotal)
	{
		//Size Check(Num of Camera)
		for (int n = 0; n < vt_job_info[nJob].light_info.size(); n++)
		{
			//NUM_OF_USING_LIGHT
			for (int nLight = 0; nLight < vt_job_info[nJob].light_info[n].num_of_using_light; nLight++)
			{
				//LIGHT_CTRL_ID%d_1
				int ctrl = vt_job_info[nJob].light_info[n].controller_id[nLight] - 1;
				//LIGHT_CHANNEL_ID%d_1
				int ch = vt_job_info[nJob].light_info[n].channel_id[nLight];
				//LIGHT_BRIGHT_1_1_1
				int value = vt_job_info[nJob].model_info.getLightInfo().getLightBright(n, nLight, nIndex);

				if (SubLightOff && nLight != 0)
				{
					value = 0;
				}

				if (OnOff)
				{
					//True = Off
					value = 0;
				}

				if (m_stLightCtrlInfo.nType[ctrl] == LTYPE_LLIGHT_LPC_COT_232)
				{
					SetLightBright(ctrl, ch, value == 0 ? 0 : value * 10);   // dh.jung 2021-07-12
				}
				else
				{
					SetLightBright(ctrl, ch, value);
				}
				Delay(50);
			}
		}
	}
	else
	{
		for (int nLight = 0; nLight < vt_job_info[nJob].light_info[nCam].num_of_using_light; nLight++)
		{
			// LIGHT_CTRL_ID % d_1
			int ctrl = vt_job_info[nJob].light_info[nCam].controller_id[nLight] - 1;
			//LIGHT_CHANNEL_ID%d_1
			int ch = vt_job_info[nJob].light_info[nCam].channel_id[nLight];

			int value = vt_job_info[nJob].model_info.getLightInfo().getLightBright(nCam, nLight, nIndex);

			if (SubLightOff && nLight != 0)
			{
				value = 0;
			}

			if (OnOff)
			{
				//True = Off
				value = 0;
			}

			if (m_stLightCtrlInfo.nType[ctrl] == LTYPE_LLIGHT_LPC_COT_232)
			{
				SetLightBright(ctrl, ch, value == 0 ? 0 : value * 10);   // dh.jung 2021-07-12
			}
			else
			{
				SetLightBright(ctrl, ch, value);
			}
			Delay(50);
		}
	}
	
	return TRUE;
}

BOOL CLET_AlignClientDlg::InitProcessStart_Cam()
{
	return TRUE;
}

void CLET_AlignClientDlg::Save_Result_Image_Center_Nozzle_Align(BOOL bJudge, int algo, BOOL bRetryEnd)
{
	CString strImageDir, str;
	CString strTime, str_modelID, str_algo;
	SYSTEMTIME time;
	::GetLocalTime(&time);

	///////////////////////////////////// 이미지 저장 폴더
	///  D:\\ Result \\ Image \\ 날짜 \\ 모델 ID \\ JOB이름 \\ 시간 \\

	//날짜
	strTime.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	strImageDir.Format("%s%s", m_strImageDir, strTime);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//모델ID
	str_modelID.Format("%s", vt_job_info[algo].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//JOB이름
	//KJH 2022-08-03 Nozzle Log 경로 변경(요청자 김경철수석)
	//str_algo.Format(_T("%s"), vt_job_info[algo].job_name.c_str());
	//strImageDir.Format("%s\\%s", strImageDir, str_algo);
	strImageDir.Format("%s\\NOZZLE_AFTER_ALIGN", strImageDir);
	if (_access(strImageDir, 0) != 0)	CreateDirectory(strImageDir, NULL);

	//이미지저장 시간
	strTime.Format(_T("%02d_%02d_%02d_%03d"), time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);

	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	int camCount = vt_job_info[algo].num_of_camera;
	int nCam = 0;
	int real_cam = 0;

	for (nCam = 0; nCam < camCount; nCam++)
	{
		real_cam = camBuf.at(nCam);
		int W = m_stCamInfo[real_cam].w;
		int H = m_stCamInfo[real_cam].h;

		int index = m_nSaveImageRingBufIndex[algo][nCam];

		index = m_nSaveImageRingBufIndex[algo][nCam];

		//KJH 2021-08-14 Caliper 4개로 Display 이미지 저장용
		int Max_nPos = vt_job_info[algo].num_of_position;

		m_stSaveImageInfo[algo][nCam][index].bUsing1Cam = FALSE;
		m_stSaveImageInfo[algo][nCam][index].nNumPos = 1;
		m_stSaveImageInfo[algo][nCam][index].line[0] = GetMatching(algo).getFindInfo(nCam, 0).GetLine(0);
		m_stSaveImageInfo[algo][nCam][index].line[1] = GetMatching(algo).getFindInfo(nCam, 0).GetLine(1);
		m_stSaveImageInfo[algo][nCam][index].bFindline[0] = GetMatching(algo).getFindInfo(nCam, 0).GetFindline(0);
		m_stSaveImageInfo[algo][nCam][index].bFindline[1] = GetMatching(algo).getFindInfo(nCam, 0).GetFindline(1);

		for (int j = 0; j < 4; j++)
		{
			m_stSaveImageInfo[algo][nCam][index].dLineX[0][j] = GetMatching(algo).getFindInfo(nCam, 0).GetLineX(j);
			m_stSaveImageInfo[algo][nCam][index].dLineY[0][j] = GetMatching(algo).getFindInfo(nCam, 0).GetLineY(j);
		}

		m_stSaveImageInfo[algo][nCam][index].b4Align = vt_job_info[algo].model_info.getAlignInfo().getUse4PointAlign();
		m_stSaveImageInfo[algo][nCam][index].dPosX[0] = GetMatching(algo).getFindInfo(nCam, 0).GetXPos();
		m_stSaveImageInfo[algo][nCam][index].dPosY[0] = GetMatching(algo).getFindInfo(nCam, 0).GetYPos();
		m_stSaveImageInfo[algo][nCam][index].nFound[0] = GetMatching(algo).getFindInfo(nCam, 0).GetFound();
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_X] = m_dbRevisionData[algo][AXIS_X];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Y] = m_dbRevisionData[algo][AXIS_Y];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_Z] = m_dbRevisionData[algo][AXIS_Z];
		m_stSaveImageInfo[algo][nCam][index].dRevision[AXIS_T] = m_dbRevisionData[algo][AXIS_T];
		m_stSaveImageInfo[algo][nCam][index].bJudge = bJudge;
		m_stSaveImageInfo[algo][nCam][index].nRetry = m_nRetryCount[algo] - 1;
		m_stSaveImageInfo[algo][nCam][index].bFinal = bRetryEnd;
		m_stSaveImageInfo[algo][nCam][index].nAlgorithm = algo;
		m_stSaveImageInfo[algo][nCam][index].nCam = nCam;
		m_stSaveImageInfo[algo][nCam][index].bLcheckNG = m_bLcheckNG[algo];

		//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_Img.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
		str.Format("%s\\%s_%s_%s_Img.jpg", strImageDir,		// 이미지 저장 디렉토리
			vt_job_info[algo].main_object_id.c_str(),		// 모델이름
			strTime,										// 시간
			m_stCamInfo[real_cam].cName);					// 카메라 이름

		copyMemory(getSaveImageBuffer(real_cam, index), getProcBuffer(real_cam, 0), W * H);
		sprintf(m_cSaveImageRingBufPath[algo][nCam][index], "%s", (LPCTSTR)str);

		//str.Format("%s\\%s\\%s\\%s\\%s_%s_%s_ImgRaw.jpg", strImageDir, bJudge ? "OK" : "NG", str_algo, vt_job_info[algo].main_object_id.c_str(), vt_job_info[algo].main_object_id.c_str(), strTime, m_stCamInfo[real_cam].cName);
		str.Format("%s\\%s_%s_%s_ImgRaw.jpg", strImageDir,			// 이미지 저장 디렉토리
			vt_job_info[algo].main_object_id.c_str(),				// 모델이름
			strTime,												// 시간
			m_stCamInfo[real_cam].cName);							// 카메라 이름

		sprintf(m_cSaveImageRingBufPath_Raw[algo][nCam][index], "%s", (LPCTSTR)str);

		m_nSaveImageRingBufIndex[algo][nCam] = (m_nSaveImageRingBufIndex[algo][nCam] + 1) % MAX_SAVE_IMAGE_RING_BUF;
	}
}
BOOL CLET_AlignClientDlg::Write_Result_Align_Data_Center_Align_ELB(CString serialNum, BOOL bJudge, int algo) 
{
	CString strTemp, Time_str, Date_str;
	CString strFileDir = m_strResultDir + m_strResultDate[algo];
	BOOL bWriteHeader = FALSE;

#ifndef JOB_INFO
	int camCount = m_pAlgorithmInfo.getAlgorithmCameraNum(algo);
	std::vector<int> camBuf = m_pAlgorithmInfo.getAlgorithmCameraIndex(algo);
	CString algo_name = m_pAlgorithmInfo.getAlgorithmName(algo).c_str();
#else
	int camCount = vt_job_info[algo].num_of_camera;
	std::vector<int> camBuf = vt_job_info[algo].camera_index;
	CString algo_name = vt_job_info[algo].job_name.c_str();
#endif

	int cam_no[8] = { 0, };

	for (int i = 0; i < camCount; i++)
	{
		cam_no[i] = camBuf.at(i);
	}

	SYSTEMTIME	csTime;
	::GetLocalTime(&csTime);

	if (m_strResultTime[algo].IsEmpty())	m_strResultTime[algo].Format(_T("%02d_%02d_%02d_%03d"), csTime.wHour, csTime.wMinute, csTime.wSecond, csTime.wMilliseconds);
	if (m_strResultDate[algo].IsEmpty())	m_strResultDate[algo].Format("%04d%02d%02d", csTime.wYear, csTime.wMonth, csTime.wDay);

	Time_str = m_strResultTime[algo];
	Date_str = m_strResultDate[algo];

	///////////////////////////////////// 이미지 저장 폴더
///  D:\\ Result \\ Files \\ 날짜 \\ 모델 ID \\ JOB이름 \\ 시간 \\

	strFileDir.Format("%sFiles\\", m_strResultDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, Date_str);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	strFileDir.Format("%s%s\\", strFileDir, m_strCurrentModelName);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);
	//KJH 2022-08-03 Nozzle Log 경로 변경(요청자 김경철수석)
	//strFileDir.Format("%s%s\\", strFileDir, algo_name);
	strFileDir.Format("%sNOZZLE_AFTER_ALIGN\\", strFileDir);
	if (_access(strFileDir, 0) != 0)	CreateDirectory(strFileDir, NULL);

	//strTemp.Format("%s%s_Result_%s.csv", strFileDir, algo_name, Date_str);
	strTemp.Format("%sNOZZLE_AFTER_ALIGN_Result_%s.csv", strFileDir, Date_str);

	if ((_access(strTemp, 0)) == -1)
	{
		bWriteHeader = TRUE;
	}

	CStdioFile WriteFile;
	if (WriteFile.Open(strTemp, CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText) != TRUE)
	{
		CString str;
		str.Format("Fail to Open Logfile !! : %s", strTemp.Mid(strTemp.ReverseFind('\\') + 1));
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
		return 0;
	}

	// 매번 불필요하게 header 부분에 대한 처리가 들어 가지만, 
	// Header<->Body 작성시 실수를 줄이기 위함.
	CString strHeader, strBody;

	strTemp.Format("TIME");																					strHeader += strTemp;
	strTemp.Format("%s", Time_str);																			strBody += strTemp;

	strTemp.Format(",MODEL ID");																			strHeader += strTemp;
	strTemp.Format(",%s", m_strCurrentModelName);															strBody += strTemp;

	strTemp.Format(",JUDGE");																				strHeader += strTemp;
	strTemp.Format(",%s", bJudge ? "OK" : "NG");															strBody += strTemp;

	strTemp.Format(",SEQ_NUM");																				strHeader += strTemp;
	strTemp.Format(",%d", m_nSeqNozzleGrabCount);															strBody += strTemp;

	strTemp.Format(",X");																					strHeader += strTemp;
	strTemp.Format(",%.3f", GetPrealign(algo).getRevisionX());												strBody += strTemp;

	strTemp.Format(",Y");																					strHeader += strTemp;
	strTemp.Format(",%.3f", GetPrealign(algo).getRevisionY());												strBody += strTemp;

	strTemp.Format(",Z");																					strHeader += strTemp;
	strTemp.Format(",%.3f", GetPrealign(algo).getRevisionZ());												strBody += strTemp;

	strTemp.Format(",T");																					strHeader += strTemp;
	strTemp.Format(",%.3f", GetPrealign(algo).getRevisionT());												strBody += strTemp;

	strTemp.Format(",MARK X1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(0, 0).GetYPos());									strBody += strTemp;

	strTemp.Format(",REF X1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getRefX(0, 0));												strBody += strTemp;

	strTemp.Format(",REF Y1");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getRefY(0, 0));												strBody += strTemp;

	strTemp.Format(",MARK X2");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).GetXPos());									strBody += strTemp;

	strTemp.Format(",MARK Y2");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getFindInfo(1, 0).GetYPos());									strBody += strTemp;

	strTemp.Format(",REF X2");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getRefX(1, 0));												strBody += strTemp;

	strTemp.Format(",REF Y2");																				strHeader += strTemp;
	strTemp.Format(",%.1f", GetMatching(algo).getRefY(1, 0));												strBody += strTemp;

	strHeader += "\n";
	strBody += "\n";

	if (bWriteHeader)
	{
		WriteFile.WriteString(strHeader);
	}

	WriteFile.SeekToEnd();
	WriteFile.WriteString(strBody);
	WriteFile.Close();

	return TRUE;
}

//KJH 2022-03-12 PF INSP FDC 보고 추가
void CLET_AlignClientDlg::SendFDCValue_PFINSP(int nJob, int nCam)
{
	//우선 20Word 기준으로 잡아둠
	const int m_nFDCCount = 10;
	const int PLC_DATA_REVISION = 10000;
	int m_nFDCCount_Current = 0;
	long pData[2 * m_nFDCCount] = { 0, };
	double xres = GetMachine(nJob).getCameraResolutionX(0, 0);
	double yres = GetMachine(nJob).getCameraResolutionY(0, 0);

	// i == 0 ("C") , 1("L"), 2("R")
	//vt_result_info[nJob].pf_film_insp_data.dist_lx[i] = dist_lx[i] * dlx;
	//vt_result_info[nJob].pf_film_insp_data.dist_ly[i] = dist_ly[i] * dly;
	//vt_result_info[nJob].pf_film_insp_data.dist_rx[i] = dist_rx[i] * drx;
	//vt_result_info[nJob].pf_film_insp_data.dist_ry[i] = dist_ry[i] * dry;

	//FDC 보고 리스트
	//1. LX		dist_lx[1]
	//2. LY		dist_ly[1]
	//3. RX		dist_rx[2]
	//4. RY		dist_ry[2]
	//5. CLX	dist_lx[0]
	//6. CRX	dist_rx[0]

	//2022.06.24 APC 사용하기 위해 변경 Tkyuha
	double panel_x[3], panel_y[3], film_x[3], film_y[3], sign[6] = { 1,1,1,1,1,1};

	panel_x[0] 	= GetMatching(nJob).getFindInfo(nCam, 0).GetXPos();
	panel_y[0] 	= GetMatching(nJob).getFindInfo(nCam, 0).GetYPos();
	panel_x[1] 	= GetMatching(nJob).getFindInfo(nCam, 1).GetXPos();
	panel_y[1] 	= GetMatching(nJob).getFindInfo(nCam, 1).GetYPos();
	film_x[0] 	= GetMatching(nJob).getFindInfo(nCam, 2).GetXPos();
	film_y[0] 	= GetMatching(nJob).getFindInfo(nCam, 2).GetYPos();
	film_x[1] 	= GetMatching(nJob).getFindInfo(nCam, 3).GetXPos();
	film_y[1] 	= GetMatching(nJob).getFindInfo(nCam, 3).GetYPos();

	if (panel_x[0] > film_x[0]) 				sign[0] = -1; //lx check
	if (panel_y[0] < film_y[0]) 				sign[1] = -1; //ly 
	if (panel_x[1] > film_x[1]) 				sign[2] = -1; //rx
	if (panel_y[1] < film_y[1]) 				sign[3] = -1; //ry
	if ((panel_x[0]+panel_x[1])/2 > film_x[0]) 	sign[4] = -1;
	if ((panel_x[0]+panel_x[1])/2 > film_x[1]) 	sign[5] = -1;

	pData[m_nFDCCount_Current] = LOWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_lx[1] * PLC_DATA_REVISION * sign[0]));	//[1]
	m_nFDCCount_Current++;
	pData[m_nFDCCount_Current] = HIWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_lx[1] * PLC_DATA_REVISION * sign[0]));	//[1]
	m_nFDCCount_Current++;

	pData[m_nFDCCount_Current] = LOWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_ly[1] * PLC_DATA_REVISION * sign[1]));	//[2]
	m_nFDCCount_Current++;
	pData[m_nFDCCount_Current] = HIWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_ly[1] * PLC_DATA_REVISION * sign[1]));	//[2]
	m_nFDCCount_Current++;

	pData[m_nFDCCount_Current] = LOWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_rx[2] * PLC_DATA_REVISION * sign[2]));	//[3]
	m_nFDCCount_Current++;
	pData[m_nFDCCount_Current] = HIWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_rx[2] * PLC_DATA_REVISION * sign[2]));	//[3]
	m_nFDCCount_Current++;

	pData[m_nFDCCount_Current] = LOWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_ry[2] * PLC_DATA_REVISION * sign[3]));	//[4]
	m_nFDCCount_Current++;
	pData[m_nFDCCount_Current] = HIWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_ry[2] * PLC_DATA_REVISION * sign[3]));	//[4]
	m_nFDCCount_Current++;

	pData[m_nFDCCount_Current] = LOWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_lx[0] * PLC_DATA_REVISION * sign[4]));	//[5]
	m_nFDCCount_Current++;
	pData[m_nFDCCount_Current] = HIWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_lx[0] * PLC_DATA_REVISION * sign[4]));	//[5]
	m_nFDCCount_Current++;

	pData[m_nFDCCount_Current] = LOWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_rx[0] * PLC_DATA_REVISION * sign[5]));	//[6]
	m_nFDCCount_Current++;
	pData[m_nFDCCount_Current] = HIWORD(int(vt_result_info[nJob].pf_film_insp_data.dist_rx[0] * PLC_DATA_REVISION * sign[5]));	//[6]
	m_nFDCCount_Current++;

	//ATTACH INSP 01 == D16620
	//ATTACH INSP 01 == D16660

	//FDC Data 전송
	g_CommPLC.SetWord(vt_job_info[nJob].plc_addr_info.write_word_start, m_nFDCCount_Current, pData);

	CString str;

	str.Format("[%s]Send FDC Value - %dWord ", vt_job_info[nJob].job_name.c_str(), m_nFDCCount_Current);
	::SendMessage(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);

	return;
}
//KJH 2022-03-16 Act,Seq Time Display 추가
void CLET_AlignClientDlg::draw_Calc_Time(int nJob, int dir, CString strTime, int xoffset, int yoffset)
{
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
	CDlgViewer* mViewer;

	int camCount = vt_job_info[nJob].num_of_camera;
	for (int i = 0; i < camCount; i++)
	{
		int viewer = vt_job_info[nJob].machine_viewer_index[i];
		mViewer = pFormMain->m_pDlgViewerMain[viewer];

		mViewer->GetViewer().AddHardGraphic(new GraphicLabel(-10, -10, fmt("[%s]", strTime), Gdiplus::Color(0xff00ff00), Anchor::TopLeft));
		mViewer->GetViewer().HardDirtyRefresh();
	}

	//CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
	//CDlgViewer* mViewer;

	//int camCount = vt_job_info[nJob].num_of_camera;
	//CPen penROI(PS_SOLID, 7, RGB(0, 255, 0));

	//CString str;
	//CFont font, * oldFont;
	//int OLD_BKMODE = 0;
	//CBrush br(RGB(0, 0, 0)), * oldBr;
	//CPoint pt1, pt2;
	//int width = 800, height = 200, endpos = 50;

	//for (int i = 0; i < camCount; i++)
	//{
	//	int viewer = vt_job_info[nJob].machine_viewer_index[i];
	//	mViewer = pFormMain->m_pDlgViewerMain[viewer];

	//	CDC* pDC = mViewer->GetViewer().getOverlayDC();
	//	int viewWidth = mViewer->GetViewer().GetWidth();
	//	int viewHeight = mViewer->GetViewer().GetHeight();

	//	double _MAG = mViewer->GetViewer().GetMagnification();
	//	if (_MAG == 0) _MAG = 1;

	//	double _xoffset = xoffset / _MAG;

	//	font.CreateFont(int(15 / _MAG), int(15 / _MAG), 0, 0, FW_BOLD, 0, 0, 0, DEFAULT_CHARSET,
	//		OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Arial");

	//	switch (dir)
	//	{
	//	case 0: pt1.x = endpos + _xoffset;						pt1.y = endpos + yoffset;						break; // left 상단
	//	case 1: pt1.x = viewWidth / 2 - width / 2 + _xoffset;	pt1.y = endpos + yoffset;						break; // center 상단
	//	case 2: pt1.x = viewWidth - endpos + _xoffset;			pt1.y = endpos + yoffset;						break; // right 상단
	//	case 3: pt1.x = endpos + _xoffset;						pt1.y = viewHeight / 2 - height / 2 + yoffset;	break; // left 중간
	//	case 4: pt1.x = viewWidth / 2 - width / 2 + _xoffset;	pt1.y = viewHeight / 2 - height / 2 + yoffset;	break; // center 중간
	//	case 5: pt1.x = viewWidth - endpos + _xoffset;			pt1.y = viewHeight / 2 - height / 2 + yoffset;	break; // right 중간
	//	case 6: pt1.x = endpos + _xoffset;						pt1.y = viewHeight - endpos + yoffset;          break; // left 중간
	//	case 7: pt1.x = viewWidth / 2 - width / 2 + _xoffset;	pt1.y = viewHeight - endpos + yoffset;          break; // center 중간
	//	case 8: pt1.x = viewWidth - endpos + _xoffset;			pt1.y = viewHeight - endpos + yoffset;          break; // right 중간
	//	}

	//	pt2.x = pt1.x + width;
	//	pt2.y = pt1.y + height;

	//	oldBr = pDC->SelectObject(&br);
	//	pDC->SelectObject(&penROI);
	//	//pDC->Rectangle(pt1.x, pt1.y, pt2.x, pt2.y);

	//	oldFont = pDC->SelectObject(&font);
	//	OLD_BKMODE = pDC->SetBkMode(TRANSPARENT);

	//	pDC->SetTextColor(COLOR_PURPLE);
	//	str.Format("[%s]", strTime);

	//	//stFigureText tempFigText;
	//	//tempFigText.ptBegin.x = pt1.x;
	//	//tempFigText.ptBegin.y = pt1.y;
	//	//tempFigText.ptBeginFit.x = pt1.x;
	//	//tempFigText.ptBeginFit.y = pt1.y;
	//	//tempFigText.textString = str;
	//	//tempFigText.is_show_bkg = TRUE;
	//	//mViewer->GetViewer().addFigureText(tempFigText, 12, 12, COLOR_BLUE);
	//	pDC->TextOutA(pt1.x, (pt1.y + pt2.y) / 2 - 15, str);

	//	pDC->SelectObject(oldBr);
	//	pDC->SetBkMode(OLD_BKMODE);
	//	font.DeleteObject();

	//	mViewer->GetViewer().Invalidate();
	//}

	//br.DeleteObject();
	//penROI.DeleteObject();
}

void CLET_AlignClientDlg::draw_NozzleY_Distance(int threadID)
{
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	double _offset = vt_job_info[threadID].model_info.getInspSpecParaInfo().getCenterLiveViewGuideLineOffset();
	int nViewer = vt_job_info[threadID].viewer_index[1];

	int W = pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().GetWidth();
	int H = pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().GetHeight();

	double xres = pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().getCameraResolutionX();
	double yres = pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().getCameraResolutionY();

	double centerPtX = W / 2, cetnerPtY = H / 2;
	double ylineoffset = _offset / yres;

	// YCS 2022-11-21 Center LiveView 가이드라인 클리어 추가
	pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().ClearSoftGraphics();

	if (_offset != 0)
	{
		// YCS 2022-11-21 Center LiveView 가이드라인 추가
		pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().AddSoftGraphic(new GraphicLine(cv::Point2d(0, cetnerPtY - ylineoffset), cv::Point2d(W, cetnerPtY - ylineoffset), Gdiplus::Color::Blue));
	}

	ylineoffset = 0.03 / yres;
	pFormMain->m_pDlgViewerMain[nViewer]->GetViewer().AddSoftGraphic(new GraphicLine(cv::Point2d(0, cetnerPtY - ylineoffset), cv::Point2d(W, cetnerPtY - ylineoffset), Gdiplus::Color::Red));
}

double CLET_AlignClientDlg::reCalculateMarkYpos(BYTE* src, int w, int h,double refx,double refy)
{
	double dvalue = 0.0;

	if (refx < 25 || refx > w - 25) return dvalue;
	if (refy < 25 || refy > h - 25) return dvalue;

	cv::Mat img(h, w, CV_8UC1, src), iproc;
	cv::Rect roi = cv::Rect(int(refx-25), int(refy-25), 50, 50);

	cv::threshold(img(roi), iproc, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);

	int sptx = 25;

	for (int j = 2; j < 48 ; j++)
	{
		if (iproc.data[int((50-j) * iproc.cols + sptx)] >128)
		{
			dvalue = roi.y + 50-j;
			break;
		}
	}

	iproc.release();
	img.release();

	return dvalue;
}

double CLET_AlignClientDlg::reCalculateMarkZGapYpos(BYTE* src, int w, int h, double refx, double refy)
{
	double dvalue = 0.0;

	if (refx < 25 || refx > w - 25) return dvalue;
	if (refy < 25 || refy > h - 25) return dvalue;

	cv::Mat img(h, w, CV_8UC1, src), iproc;
	cv::Rect roi = cv::Rect(int(refx - 25), int(refy - 25), 50, 50);

	cv::threshold(img(roi), iproc, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);

	int _max_y = -999999999;

	for (int i = -8; i < 8; i++)
	{
		for (int j = 2; j < 48; j++)
		{
			if (iproc.data[int((50-j) * iproc.cols +25+i)] > 128)
			{
				dvalue = roi.y + 50-j;
				if (_max_y<dvalue)
				{
					_max_y = dvalue;
					break;
				}
			}
		}
	}

	if (_max_y > 0) dvalue=_max_y;
	else dvalue = 0;

	iproc.release();
	img.release();

	return dvalue;
}

double CLET_AlignClientDlg::reCalculateMarkZGapYpos2(BYTE* src, int w, int h, double refx, double refy)
{
	double dvalue = 0.0;

	if (refx < 25 || refx > w - 25) return dvalue;
	if (refy < 25 || refy > h - 25) return dvalue;

	cv::Mat img(h, w, CV_8UC1, src), iproc;
	cv::Rect roi = cv::Rect(int(refx - 50), int(refy - 50), 100, 100);

	cv::threshold(img(roi), iproc, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
	int _max_y = -999999999;

	for (int j = 2; j < 98; j++)
	{
		if (iproc.data[int((100 - j) * iproc.cols + 50)] > 128)
		{
			dvalue = roi.y + 100 - j;
			if (_max_y < dvalue)
			{
				_max_y = dvalue;
				break;
			}
		}
	}

	//cv::imwrite("D:\\Test_Image.jpg", iproc);

	if (_max_y > 0) dvalue = _max_y;
	else dvalue = 0;

	iproc.release();
	img.release();

	return dvalue;
}

// KBJ 2022-12-06
void CLET_AlignClientDlg::reCalculateMarkZGapYpos3(int nJob, BYTE* src, int w, int h, double *refx, double *refy)
{
	cv::Mat img(h, w, CV_8UC1, src), iproc;
	
	int nCam = 0;
	int nMethod = vt_job_info[nJob].algo_method;
	//==================================== 사이드에서 보는 노즐 위치 파악 ====================================

	// FLASE = 왼쪽, TRUE = 오른쪽
	bool Nozzle_Location = FALSE;

	double xres = GetMachine(nJob).getCameraResolutionX(nCam, 0);
	int nozzle_check_size = (int)(0.3 / xres); // 사이드에서 보는 노즐 위치 파악하기위한 ROI 크기는 3mm
	cv::Rect Nozzle_location_check_left		= cv::Rect((int(*refx) - nozzle_check_size	), (int(*refy) - nozzle_check_size), nozzle_check_size, nozzle_check_size);
	cv::Rect Nozzle_location_check_right	= cv::Rect((int(*refx)									), (int(*refy) - nozzle_check_size), nozzle_check_size, nozzle_check_size);
	
	cv::Mat InspImg = img(cv::Rect(Nozzle_location_check_left));
	cv::Scalar left = cv::mean(InspImg);
	double left_gray = left.val[0];

	InspImg = img(cv::Rect(Nozzle_location_check_right));
	cv::Scalar right = cv::mean(InspImg);
	double right_gray = right.val[0];

	if (left_gray >= right_gray)
	{
		if( nMethod == CLIENT_TYPE_CENTER_NOZZLE_ALIGN )		Nozzle_Location = TRUE;
		else if (nMethod == CLIENT_TYPE_CENTER_SIDE_YGAP)		Nozzle_Location = FALSE;
	}
	else
	{
		if (nMethod == CLIENT_TYPE_CENTER_NOZZLE_ALIGN)		Nozzle_Location = FALSE;
		else if (nMethod == CLIENT_TYPE_CENTER_SIDE_YGAP)		Nozzle_Location = TRUE;
	}
	//==============================================================================================

	cv::Rect roi = cv::Rect(int(*refx - 50), int(*refy - 50), 100, 100);
	
	cv::Mat sobelMagnitude, sobelOrientation;

	cv::threshold(img(roi), iproc, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
	//cvShowImage("Zgap Proc 1 Otsu ", iproc);

	cv::Sobel(iproc, sobelMagnitude, CV_32F, 1, 0, 3);
	cv::Sobel(iproc, sobelOrientation, CV_32F, 0, 1, 3);

	cv::cartToPolar(sobelMagnitude, sobelOrientation, sobelMagnitude, sobelOrientation);
	//displayCartToPolar(sobelMagnitude, sobelOrientation);

	normalize(sobelMagnitude, iproc, 0, 255, NORM_MINMAX, CV_8UC1);
	//cvShowImage("Zgap Proc 2 Sobel", iproc);

	

	bool bFind = FALSE;

	if (Nozzle_Location == TRUE)
	{
		// 노즐이 오른쪽 상단에 있을경우 왼쪽에서부터 
		for (int y = 2; y < roi.height - 2; y++)
		{
			for (int x = 2; x < iproc.cols; x++)
			{
				if (iproc.data[int((roi.height - y) * iproc.cols + x)] > 200)
				{
					*refx = roi.x + x;
					*refy = roi.y + roi.height - y;
					
					bFind = true;
					break;
				}
			}
			if (bFind == true) break;
		}
	}
	else
	{
		// 노즐이 왼쪽 상단에 있을경우 오른쪽에서부터 
		for (int y = 2; y < roi.height - 2; y++)
		{
			for (int x = iproc.cols - 2; x > 2; x--)
			{
				if (iproc.data[int((roi.height - y) * iproc.cols + x)] > 200)
				{
					*refx = roi.x + x;
					*refy = roi.y + roi.height - y;

					bFind = true;
					break;
				}
			}
			if (bFind == true) break;
		}
	}

	iproc.release();
	img.release();

	return;
}

BOOL CLET_AlignClientDlg::find_pattern_caliper(BYTE* pImg, int w, int h, int job, int cam, int pos, CFindInfo* pInfo)
{
	int real_cam = vt_job_info[job].camera_index[cam];
	CCaliper* pCaliper = &m_pDlgCaliper->m_Caliper[real_cam][pos][0];

	if (pInfo == NULL)	pInfo = &GetMatching(job).getFindInfo(cam, pos);

	BOOL is_circle_caliper = pCaliper->getCircleCaliper();
	BOOL bFind = FALSE;

	if (is_circle_caliper)
	{
		pCaliper->processCaliper_circle(pImg, w, h, 0.0, 0.0, 0.0, TRUE);
		bFind = pCaliper->getIsMakeLine();

		if (bFind)
		{
			pInfo->SetXPos(pCaliper->m_circle_info.x);
			pInfo->SetYPos(pCaliper->m_circle_info.y);
			pInfo->SetScore(100.0);
			pInfo->SetFound(FIND_OK);
		}
		else
		{
			pInfo->SetXPos(0.0);
			pInfo->SetYPos(0.0);
			pInfo->SetScore(0.0);
			pInfo->SetFound(FIND_ERR);
		}
	}
	else
	{
		m_pDlgCaliper->m_Caliper[real_cam][pos][0].processCaliper(pImg, w, h, 0.0, 0.0, 0.0, TRUE);
		m_pDlgCaliper->m_Caliper[real_cam][pos][1].processCaliper(pImg, w, h, 0.0, 0.0, 0.0, TRUE);

		double pos_x, pos_y;
		if (m_pDlgCaliper->m_Caliper[real_cam][pos][0].getIsMakeLine() && m_pDlgCaliper->m_Caliper[real_cam][pos][1].getIsMakeLine())
		{
			bFind = TRUE;
		}


		if (bFind)
		{
			sLine lineInfo[2];
			lineInfo[0] = m_pDlgCaliper->m_Caliper[real_cam][pos][0].m_lineInfo;
			lineInfo[1] = m_pDlgCaliper->m_Caliper[real_cam][pos][1].m_lineInfo;

			pCaliper->cramersRules(-lineInfo[0].a, 1, -lineInfo[1].a, 1, lineInfo[0].b, lineInfo[1].b, &pos_x, &pos_y);

			pInfo->SetXPos(pos_x);
			pInfo->SetYPos(pos_y);
			pInfo->SetScore(100.0);
			pInfo->SetFound(FIND_OK);
		}
		else
		{
			pInfo->SetXPos(0.0);
			pInfo->SetYPos(0.0);
			pInfo->SetScore(0.0);
			pInfo->SetFound(FIND_ERR);
		}
	}

	return bFind;
}

BOOL CLET_AlignClientDlg::Load_Align_PanelImage(int nJob, CViewerEx* pViewer, CString strPanelID, BOOL bJudge, int nRealCam)
{
	BOOL bFindPanelImage = FALSE;

	CString strCameraName;
	strCameraName.Format("%s", m_stCamInfo[nRealCam].cName);

	CString strImagePath;

	SYSTEMTIME time;
	::GetLocalTime(&time);

	CString str_modelID;
	CString str_algo;
	CString strImageDir;
	CString strDate;

	//JOB이름
	str_algo.Format("%s", vt_job_info[nJob].job_name.c_str());
	strImageDir.Format("%s\\%s\\", strImageDir, str_algo);

	//날짜
	strDate.Format("%04d%02d%02d", time.wYear, time.wMonth, time.wDay);
	strImageDir.Format("%s%s", m_strImageDir, strDate);
	if (_access(strImageDir, 0) != 0)	return FALSE;

	//모델ID
	str_modelID.Format("%s", vt_job_info[nJob].model_info.getModelID());
	strImageDir.Format("%s\\%s", strImageDir, str_modelID);
	if (_access(strImageDir, 0) != 0)	return FALSE;

	//JOB이름
	str_algo.Format("%s", vt_job_info[nJob].job_name.c_str());
	strImageDir.Format("%s\\%s", strImageDir, str_algo);
	if (_access(strImageDir, 0) != 0)	return FALSE;

	// OK, NG 풀더
	if (bJudge == TRUE)
	{
		//OK
		strImageDir.Format("%s\\OK", strImageDir);
		if (_access(strImageDir, 0) != 0)	return FALSE;
	}
	else
	{
		//NG
		strImageDir.Format("%s\\NG", strImageDir);
		if (_access(strImageDir, 0) != 0)	return FALSE;
	}

	// PANELID 폴더
	strImageDir.Format("%s\\%s", strImageDir, strPanelID);
	if (_access(strImageDir, 0) != 0)	return FALSE;

	// Image 찾기
	CString fname;
	BOOL bFind = FALSE;
	CFileFind findImage;
	bFind = findImage.FindFile(strImageDir + _T("\\*.*"));
	try {
		while (bFind)
		{
			bFind = findImage.FindNextFile();

			if (findImage.IsDots() || findImage.IsDirectory())	// '.', '..', '파일' 인 경우 continue;
				continue;

			fname = findImage.GetFilePath();	// 찾은 Image

			if (fname.Find(strCameraName) > -1)
			{
				if (fname.Find("_Img.jpg") > -1)
				{
					strImagePath = fname;
					bFindPanelImage = TRUE;
					break;
				}
			}
		}
	}
	catch (...)
	{
		CString str;
		str.Format("Did catch the error to Load_Align_PanelImage");
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str);
	}

	if (bFindPanelImage == TRUE)
	{
		// Viewer Reset 이후에 표시되도록 Delay
		Delay(100);
		pViewer->OnLoadImage(strImagePath);
	}

	return bFindPanelImage;
}

void CLET_AlignClientDlg::replaceWindowPos(CDialog* pDlg, int i)
{
	CRect rcRect;
	pDlg->GetWindowRect(&rcRect);

	int screenx = GetSystemMetrics(SM_CXSCREEN);
	int screeny = GetSystemMetrics(SM_CYSCREEN);

	int nCol = screenx / rcRect.Width();
	int nRow = screeny / rcRect.Height();

	int nIntervalX = screenx / nCol;
	int nIntervalY = screeny / nRow;

	int nOffsetX = (screenx - rcRect.Width() * nCol - (nIntervalX - rcRect.Width()) * (nCol - 1)) / 2;
	int nOffsetY = (screeny - rcRect.Height() * nRow - (nIntervalY - rcRect.Height()) * (nRow - 1)) / 2;

	pDlg->MoveWindow(nOffsetX + nIntervalX * (i % nCol), nOffsetY + nIntervalY * ((i / nRow) % nRow), rcRect.Width(), rcRect.Height());
}

void CLET_AlignClientDlg::setAlarmMessage(int nUnit, BOOL bShow, CString strText)
{
	if (nUnit < 0 || nUnit >= MAX_ALARM_DLG) return;

	if (bShow)
	{
		m_pDlgAlarm[nUnit]->m_LbAlarmMessage.SetText(strText);
		m_pDlgAlarm[nUnit]->ShowWindow(SW_SHOW);
	}
	else
	{
		m_pDlgAlarm[nUnit]->ShowWindow(SW_HIDE);
	}
}

// KBJ 2022-09-02 SendMessage -> (x)SendMessage 
void CLET_AlignClientDlg::Camera_Grab(int real_cam)
{
#ifndef _DAHUHA
	if (m_pBaslerCam[real_cam])
	{
		AfxBeginThread(Thread_ImageGrab, m_pBaslerCam[real_cam], THREAD_PRIORITY_NORMAL);
	}
#endif // !_DAHUHA
#ifdef _DAHUHA
	if (m_pDahuhaCam[real_cam].isconnected())
	{
		AfxBeginThread(Thread_ImageGrab, &m_pDahuhaCam[real_cam], THREAD_PRIORITY_NORMAL);
	}
#endif // _DAHUHA
#ifndef _DAHUHA
	if (m_pSaperaCam[real_cam].IsOpend())
	{
		AfxBeginThread(Thread_ImageGrabSapera, &m_pSaperaCam[real_cam], THREAD_PRIORITY_NORMAL);
	}
#endif // !_DAHUHA
}

// KBJ 2022-09-22 모델 프로세스 2022버젼 추가
void CLET_AlignClientDlg::init_model_process_addr()
{
	model_process_addres.PLC_WD_PLC_MODEL_CURRENT_ID	  = 15000;
	model_process_addres.PLC_WD_PLC_MODEL_TARGET_ID		  = 15010;
	model_process_addres.PLC_WD_PLC_MODEL_PANEL_DATA	  = 17000;

	model_process_addres.PLC_WD_PLC_MODEL_NACK_CODE		  = m_nStartWriteWordAddr	  + 10;	// D 영역
							  
	model_process_addres.PLC_RB_PLC_MODEL_CREAT			  = m_nStartReadBitAddr_Org + 4;
	model_process_addres.PLC_RB_PLC_MODEL_CHANGE		  = m_nStartReadBitAddr_Org + 4;
	model_process_addres.PLC_RB_PLC_MODEL_MODIFY		  = m_nStartReadBitAddr_Org + 4;
	model_process_addres.PLC_RB_PLC_MODEL_DELETE		  = m_nStartReadBitAddr_Org + 4;
							  
	model_process_addres.PLC_WB_PLC_MODEL_CREAT_ACK		  = m_nStartWriteBitAddr_Org + 4;
	model_process_addres.PLC_WB_PLC_MODEL_CHANGE_ACK	  = m_nStartWriteBitAddr_Org + 5;
	model_process_addres.PLC_WB_PLC_MODEL_MODIFY_ACK	  = m_nStartWriteBitAddr_Org + 6;
	model_process_addres.PLC_WB_PLC_MODEL_DELETE_ACK	  = m_nStartWriteBitAddr_Org + 7;
	model_process_addres.PLC_WB_PLC_MODEL_PROCESS_ABLE	  = m_nStartWriteBitAddr_Org + 8;
	model_process_addres.PLC_WB_PLC_MODEL_NACK			  = m_nStartWriteBitAddr_Org + 9;
}

void CLET_AlignClientDlg::ScratchInsp(int nJob)
{
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];

	int nCam = 0;

	int real_cam = vt_job_info[nJob].camera_index[nCam];
	int nViewer = vt_job_info[nJob].viewer_index[nCam];

	int W = m_stCamInfo[real_cam].w;
	int H = m_stCamInfo[real_cam].h;

	CViewerEx* pViewer = &pFormMain->m_pDlgViewerMain[nViewer]->GetViewer();
	CString strTemp="Scratch Check";

	CPaneSimulation* pPane = (CPaneSimulation*)m_pPane[PANE_SIMULATION];
	if (m_bSimulationStart != TRUE || pPane->m_bUseLive == TRUE) 
		copyMemory(getProcBuffer(real_cam, 0), getSrcBuffer(real_cam), W * H);

	BOOL r_inspAck = FALSE;

	if (1) // 20221122 Tkyuha 스크레치 테스트 확인 // 느려지는 경우 else문으로 사용 할것
	{
		AcquireSRWLockExclusive(&pFormMain->m_pMain->g_srScratchwlock); // 동기화 시킴 Tkyuha 20221121
		r_inspAck = pFormMain->Inspection_ScratchHole(nJob, 0, getProcBuffer(real_cam, 0), pViewer);
		ReleaseSRWLockExclusive(&pFormMain->m_pMain->g_srScratchwlock);
	}
	else
	{
		r_inspAck = m_pScratchInspWorker[real_cam].Inspection_ScratchHole(nJob, 0, getProcBuffer(real_cam, 0), pViewer);
	}

	if (r_inspAck == FALSE)
	{
		strTemp.Format("[Scratch Inspection !] Panel Scratch Check !!!");
		pFormMain->ShowErrorMessageBlink(strTemp);

		if (g_CommPLC.GetBit(m_nAlignRequestRead[nJob] + 2) == TRUE) m_bSubInspJudge[real_cam] = FALSE;
		else if (m_bSimulationStart == TRUE)						 m_bSubInspJudge[real_cam] = FALSE;
		::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&strTemp);
	}
	
	SetEvent(m_hInspEndEvent[real_cam]);
	return;
}

// YCS 2022-11-09 필름얼라인용 필름 상부 라인 찾기 함수
BOOL CLET_AlignClientDlg::Film_Align_Compare_Angle(BYTE* pImage, int nJob, int nCam)
{
	BOOL bReturn = TRUE;

	CPatternMatching* pPattern = &GetMatching(nJob);
	int real_cam = vt_job_info[nJob].camera_index[nCam];
	int nWidth = vt_job_info[nJob].camera_size[nCam].x;
	int nHeight = vt_job_info[nJob].camera_size[nCam].y;

	double dPattern_Angle = -9999.0;
	double dFilm_Angle = -9999.0;

#pragma region 찾은 패턴 각도 찾기
	double posX1 = GetMatching(nJob).getFindInfo(nCam, 0).GetXPos();
	double posY1 = GetMatching(nJob).getFindInfo(nCam, 0).GetYPos();
	double posX2 = GetMatching(nJob).getFindInfo(nCam, 1).GetXPos();
	double posY2 = GetMatching(nJob).getFindInfo(nCam, 1).GetYPos();

	double dDeltaX = posX2 - posX1;
	double dDeltaY = posY2 - posY1;
	double dDerivitive = dDeltaY / dDeltaX;

	if (GetMatching(nJob).getFindInfo(nCam, 0).GetFound() == FIND_OK &&
		GetMatching(nJob).getFindInfo(nCam, 1).GetFound() == FIND_OK)
	{
		dPattern_Angle = atan(dDerivitive) * 180 / CV_PI;
	}

#pragma endregion

#pragma region 캘리퍼 각도 찾기
	sLine film_line;
	m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].processCaliper(pImage, nWidth, nHeight, 0, 0, 0, TRUE);
	film_line = m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].m_lineInfo;
	BOOL bFindLine = m_pDlgCaliper->m_Caliper[real_cam][0][C_CALIPER_POS_1].getIsMakeLine();
	if(bFindLine == TRUE) dFilm_Angle = film_line.a * 180 / CV_PI;
#pragma endregion

#pragma region 각도 비교
	// YCS 2022-11-19 
	double dAngleSpec = vt_job_info[nJob].model_info.getInspSpecParaInfo().getFilmAngleSpec();
	double compareAngle = fabs(dFilm_Angle - dPattern_Angle);
	if (compareAngle > dAngleSpec) bReturn = FALSE; //절대값이 스팩낮으면 NG
#pragma endregion

#pragma region 그리기
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
	int nViewer = vt_job_info[nJob].viewer_index[0];
	CViewerEx* pViewer = &pFormMain->m_pDlgViewerMain[nViewer]->GetViewer();
	FakeDC *pDC = pViewer->getOverlayDC();
	
	pViewer->ClearOverlayDC();
	pViewer->clearAllFigures();
	COLORREF color;
	CString str;
	CFont font;
	font.CreateFont(20, 20, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET,
		OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Arial");
	pDC->SelectObject(&font);

	// YCS 2022-11-30 필름 각도검사 오버레이 통합
	CString strCompareAngle, strCaliperAngle, strFilmAngle;

	if (bReturn == TRUE)
	{
		color = COLOR_GREEN;
		pDC->SetTextColor(COLOR_GREEN);
		strCompareAngle.Format("Compare Angle = %.2f < %.2f", compareAngle, dAngleSpec);
	}
	else
	{
		color = COLOR_RED;
		pDC->SetTextColor(COLOR_RED);
		strCaliperAngle.Format("Compare Angle = %.2f > %.2f", compareAngle, dAngleSpec);
	}

	if (bFindLine == TRUE)
	{
		draw_line(pViewer, color, film_line, nHeight, nWidth);
	}

	if(dFilm_Angle == -9999) strCaliperAngle.Format("Caliper Angle = Not Find Line 1");
	else					strCaliperAngle.Format("Caliper Angle = %.2f", dFilm_Angle);

	if(dPattern_Angle == -9999)	strFilmAngle.Format("Pattern Angle = Not Find Pattern");
	else						strFilmAngle.Format("Pattern Angle = %.2f", dPattern_Angle);

	// YCS 2022-11-30 오버레이 한 줄로 통합 - 텍스트 크기 변경 시 겹치는 현상 발생
	str.Format("%s\n%s\n%s", strCompareAngle, strCaliperAngle, strFilmAngle);
	pDC->TextOutA(nWidth / 2 - 400, 0, str);
#pragma endregion

	return bReturn;
}

// YCS 2022-11-18 스크래치 뷰어도 OK, NG 갱신하도록 추가
void CLET_AlignClientDlg::set_viewer_judge_scratch_insp(int nJob, BOOL bJudge)
{
	CString str_temp;
	CFormMainView* pFormMain = (CFormMainView*)m_pForm[FORM_MAIN];
	int real_cam = vt_job_info[nJob].camera_index[0];

#pragma region 스크래치 검사결과 판정
	if (vt_job_info[nJob].num_of_viewer != 1)
	{
		int viewer = vt_job_info[nJob].viewer_index[1];

		if (m_bSubInspJudge[real_cam] == TRUE)
		{
			pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
		}
		else pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(FALSE);
	}
#pragma endregion

	for (int i = 0; i < vt_job_info[nJob].num_of_camera; i++)
	{
		if (i < vt_job_info[nJob].viewer_index.size())
		{
			if (bJudge)
			{
				int viewer = vt_job_info[nJob].viewer_index[i];
				pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);

			}	
			else
			{
				int viewer = vt_job_info[nJob].viewer_index[i];
				if (vt_result_info[nJob].each_Judge[i][0])	pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(TRUE);
				else										pFormMain->m_pDlgViewerMain[viewer]->setViewerJudge(FALSE);
			}
		}
		else
		{
			str_temp.Format("[%s] set_viewer_judge_%s - viewer index invalid!!", vt_job_info[nJob].get_job_name(), bJudge ? "ok" : "ng");
			::SendMessageA(m_pPane[PANE_AUTO]->m_hWnd, WM_VIEW_CONTROL, MSG_PA_ADD_PROCESS_HISTORY, (LPARAM)&str_temp);
		}
	}
}